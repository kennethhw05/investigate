package dataconverter

import (
	"fmt"
	"strconv"
	"strings"

	"gitlab.com/siimpl/esp-betting/betting-feed/pkg/math/betting"

	"gitlab.com/siimpl/esp-betting/betting-feed/pkg/external/oddsgg"
	"gitlab.com/siimpl/esp-betting/betting-feed/pkg/repository"

	"github.com/shopspring/decimal"
	"github.com/sirupsen/logrus"
	"gitlab.com/siimpl/esp-betting/betting-feed/pkg/models"
)

// OddsggConverter converts oddsgg data to various outputs
type OddsggConverter struct {
	Logger *logrus.Logger
}

// ToEsportsEvent Convert oddsgg tournament to generic esports tournament
func (converter *OddsggConverter) ToEsportsEvent(tournament oddsgg.Tournament, game models.Game) *models.Event {
	event := models.Event{
		ExternalID:      strconv.Itoa(tournament.ID),
		Name:            tournament.Name,
		Game:            game,
		IsAutogenerated: true,
		IsActive:        true,
		Type:            models.EventTypeTournament,
	}
	return &event
}

// ToEsportsMatch Convert oddsgg match to generic esports match
func (converter *OddsggConverter) ToEsportsMatch(match oddsgg.Match, tournamentID string) *models.Match {
	matchName := fmt.Sprintf("%s vs %s", match.HomeTeamName, match.AwayTeamName)
	if match.OutrightName != nil {
		matchName = *match.OutrightName
	}
	return &models.Match{
		Name:            matchName,
		ExternalID:      strconv.Itoa(match.ID),
		StartTime:       match.GetStartTime(),
		EventID:         repository.NewSQLCompatUUIDFromStr(tournamentID),
		InternalStatus:  converter.ToEsportsStatus(match),
		IsAutogenerated: true,
	}
}

// ToEsportsStatus Convert oddsgg match status to generic esports match status
func (converter *OddsggConverter) ToEsportsStatus(match oddsgg.Match) models.MatchInternalStatus {
	if match.Suspended {
		return models.MatchInternalStatusSuspended
	}

	switch match.Status {
	case oddsgg.MatchStatusNotStarted:
		return models.MatchInternalStatusScheduled
	case oddsgg.MatchStatusInPlay:
		return models.MatchInternalStatusInProgress
	case oddsgg.MatchStatusFinished:
		return models.MatchInternalStatusFinished
	case oddsgg.MatchStatusCanceled:
		return models.MatchInternalStatusCancelled
	}
	return models.MatchInternalStatusUnknown
}

// ToEsportsCompetitorScores Convert oddsgg scores to correct formatted score map
func (converter *OddsggConverter) ToEsportsCompetitorScores(match oddsgg.Match) map[string]int {
	scoreMap := make(map[string]int)
	scores := strings.Split(match.Score, ":")
	if len(scores) != 2 {
		return scoreMap
	}

	homescore, err := strconv.Atoi(scores[0])
	if err != nil {
		return scoreMap
	}
	awayScore, err := strconv.Atoi(scores[1])
	if err != nil {
		return scoreMap
	}

	scoreMap[strconv.Itoa(match.HomeTeamID)] = homescore
	scoreMap[strconv.Itoa(match.AwayTeamID)] = awayScore
	return scoreMap
}

// ToEsportsTeamWinProbabilities Convert sportradar match probability payload to a internal team odds map
func (converter *OddsggConverter) ToEsportsTeamWinProbabilities(markets []oddsgg.Market, match oddsgg.Match) map[string]decimal.Decimal {
	probabilityMap := make(map[string]decimal.Decimal)
	probabilityMap[strconv.Itoa(match.HomeTeamID)] = decimal.NewFromFloat(50.0)
	probabilityMap[strconv.Itoa(match.AwayTeamID)] = decimal.NewFromFloat(50.0)

	if len(markets) == 0 {
		return probabilityMap
	}

	for _, market := range markets {
		if market.Name == oddsgg.MarketNameMatchWinner {
			for _, probability := range market.Odds {
				impliedProb := betting.DecimalOddsToImpliedProbability(decimal.NewFromFloat(probability.Value))
				// 1 is home team, 2 is away team
				if probability.Name == "1" {
					probabilityMap[strconv.Itoa(match.HomeTeamID)] = impliedProb
				} else if probability.Name == "2" {
					probabilityMap[strconv.Itoa(match.AwayTeamID)] = impliedProb
				}
			}
		}
	}

	return probabilityMap
}

func (converter *OddsggConverter) ToEsportsCompetitor(competitorID int, competitorName string) *models.Competitor {
	return &models.Competitor{
		ExternalID: strconv.Itoa(competitorID),
		Name:       competitorName,
	}
}

// ToEsportsGame Convert oddsgg game to valid internal game type
func (converter *OddsggConverter) ToEsportsGame(game oddsgg.GameCategory) models.Game {
	switch game {
	case oddsgg.GameCategoryDota2:
		return models.GameDota2
	case oddsgg.GameCategoryOverwatch:
		return models.GameOverwatch
	case oddsgg.GameCategoryStarCraft2:
		return models.GameStarcraft2
	case oddsgg.GameCategoryStarCraftBroodwar:
		return models.GameStarcraftBroodwar
	case oddsgg.GameCategoryWarcraft3:
		return models.GameWarcraft3
	case oddsgg.GameCategoryKingOfGlory:
		return models.GameKingOfGlory
	case oddsgg.GameCategoryNBA2K:
		return models.GameNba2k
	case oddsgg.GameCategoryRainbowSix:
		return models.GameRainbowSixSiege
	case oddsgg.GameCategoryStreetFighter:
		return models.GameStreetFighter
	case oddsgg.GameCategoryMagicTheGathering:
		return models.GameMagicTheGathering
	case oddsgg.GameCategoryCallOfDuty:
		return models.GameCallOfDuty
	case oddsgg.GameCategoryHearthstone:
		return models.GameHearthstone
	case oddsgg.GameCategorySmite:
		return models.GameSmite
	case oddsgg.GameCategoryCounterStrike:
		return models.GameCounterStrikeGlobalOffensive
	case oddsgg.GameCategoryLeagueOfLegends:
		return models.GameLeagueOfLegends
	case oddsgg.GameCategoryRocketLeague:
		return models.GameRocketLeague
	default:
		converter.Logger.Warnf("Encountered unknown game type: %s", game)
		return models.GameUnknown
	}
}

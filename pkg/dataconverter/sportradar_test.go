package dataconverter

import (
	"github.com/gofrs/uuid"
	"testing"

	"github.com/sirupsen/logrus"
	"gitlab.com/siimpl/esp-betting/betting-feed/pkg/external/sportradar"
	"gitlab.com/siimpl/esp-betting/betting-feed/pkg/external/sportradar/csgo"
	"gitlab.com/siimpl/esp-betting/betting-feed/pkg/models"
	"gitlab.com/siimpl/esp-betting/betting-feed/testutils"
)

func TestSportradarToEsportsTeamWinProbabilities(t *testing.T) {
	t.Parallel()

	sc := SportradarConverter{
		Logger: logrus.New(),
	}
	matchProbabilities := sportradar.MatchProbabilities{}
	err := testutils.ReadFileToStruct("csgo_match_probabilities.json", &matchProbabilities)
	if err != nil {
		t.Fatalf("Error processing file to struct in test %s", t.Name())
	}
	probabilityMap := sc.ToEsportsTeamWinProbabilities(&matchProbabilities)
	if len(probabilityMap) != 2 {
		t.Errorf("Expected 2 competitor probabilities in map but got %d", len(probabilityMap))
	}
	probC1 := probabilityMap["sr:competitor:341010"].String()
	if probC1 != "55.5" {
		t.Errorf("Expected probability of 55.5 for team sr:competitor:341010, but got %s", probC1)
	}
	probC2 := probabilityMap["sr:competitor:384604"].String()
	if probC2 != "44.5" {
		t.Errorf("Expected probability of 44.5 for team sr:competitor:341010, but got %s", probC2)
	}
}

func TestSportradarEventToEsportsEvent(t *testing.T) {
	t.Parallel()

	sc := SportradarConverter{
		Logger: logrus.New(),
	}
	tournaments := sportradar.TournamentsResponse{}
	err := testutils.ReadFileToStruct("csgo_tournaments.json", &tournaments)
	if err != nil {
		t.Fatalf("Error processing file to struct in test %s, err: %s", t.Name(), err.Error())
	}
	event := sc.ToEsportsEvent(&tournaments.Tournaments[0], models.GameCounterStrikeGlobalOffensive)
	if event.StartDate.IsZero() {
		t.Error("Start time failed to parse for sportradar event to esports event")
	}
	if event.EndDate.IsZero() {
		t.Error("End time failed to parse for sportradar event to esports event")
	}
	if event.ExternalID == "" {
		t.Error("External ID not populated for sportradar event to esports event")
	}
	if event.Game != models.GameCounterStrikeGlobalOffensive {
		t.Errorf(
			"Expected event game to be %s but got %s for sportradar event to esports event",
			models.GameCounterStrikeGlobalOffensive,
			event.Game,
		)
	}
	if event.Name == "" {
		t.Error("Name not populated for sportradar event to esports event")
	}
	if !event.IsAutogenerated {
		t.Error("Expected is autogenerate to be true for sportradar event to esports event")
	}
}

func TestSportradarMatchToEsportsMatch(t *testing.T) {
	t.Parallel()

	sc := SportradarConverter{
		Logger: logrus.New(),
	}
	match := csgo.MatchSummary{}
	err := testutils.ReadFileToStruct("csgo_match.json", &match)
	if err != nil {
		t.Fatalf("Error processing file to struct in test %s, err: %s", t.Name(), err.Error())
	}

	uuid, _ := uuid.NewV4()
	internalMatch := sc.ToEsportsMatch(&match, uuid.String())
	if internalMatch.EventID.UUID.String() != uuid.String() {
		t.Errorf(
			"Expected match event id to be %s but got %s for sportradar match to esports match",
			uuid.String(),
			internalMatch.EventID.UUID.String(),
		)
	}

	stage := "ESL Meisterschaft_group_3_regular_season"
	if internalMatch.EventStage != stage {
		t.Errorf(
			"Expected match event stage to be %s but got %s for sportradar match to esports match",
			stage,
			internalMatch.EventStage,
		)
	}

	name := "Berzerk vs Sprout"
	if internalMatch.Name != name {
		t.Errorf(
			"Expected match event stage to be %s but got %s for sportradar match to esports match",
			name,
			internalMatch.Name,
		)
	}
}

// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package models

import (
	"fmt"
	"io"
	"strconv"
	"time"
)

type AuditFilter struct {
	ID         *string     `json:"id"`
	TargetID   *string     `json:"targetId"`
	TargetType *string     `json:"targetType"`
	UserID     *string     `json:"userId"`
	EditAction *EditAction `json:"editAction"`
	Ids        []string    `json:"ids"`
}

type AuthInput struct {
	Email    string `json:"email"`
	Password string `json:"password"`
}

type CompetitorFilter struct {
	ID         *string  `json:"id"`
	Name       *string  `json:"name"`
	ExternalID *string  `json:"externalId"`
	MatchID    *string  `json:"match_id"`
	Ids        []string `json:"ids"`
}

type CreateCompetitorInput struct {
	Name string  `json:"name"`
	Logo *string `json:"logo"`
}

type CreateEventInput struct {
	Name      string    `json:"name"`
	Type      EventType `json:"type"`
	Game      Game      `json:"game"`
	Logo      *string   `json:"logo"`
	StartDate time.Time `json:"startDate"`
	EndDate   time.Time `json:"endDate"`
	IsActive  *bool     `json:"isActive"`
}

type CreateLegInput struct {
	MatchID   string  `json:"matchId"`
	PoolID    string  `json:"poolId"`
	Threshold *string `json:"threshold"`
}

type CreateMatchInput struct {
	Name           string              `json:"name"`
	EventID        string              `json:"eventId"`
	Description    *string             `json:"description"`
	StartTime      time.Time           `json:"startTime"`
	IsActive       *bool               `json:"isActive"`
	InternalStatus MatchInternalStatus `json:"internalStatus"`
	EventStage     string              `json:"eventStage"`
	Format         MatchFormat         `json:"format"`
}

type CreateOverUnderDefaultInput struct {
	Game             Game        `json:"game"`
	MatchFormat      MatchFormat `json:"matchFormat"`
	EvenThreshold    string      `json:"evenThreshold"`
	FavoredThreshold string      `json:"favoredThreshold"`
	Note             *string     `json:"note"`
}

type CreatePlayerInput struct {
	Name     string  `json:"name"`
	Nickname *string `json:"nickname"`
	TeamID   string  `json:"teamId"`
}

type CreatePoolDefaultInput struct {
	LegCount         string       `json:"legCount"`
	Game             Game         `json:"game"`
	Type             PoolType     `json:"type"`
	Guarantee        string       `json:"guarantee"`
	CarryIn          string       `json:"carryIn"`
	Allocation       string       `json:"allocation"`
	UnitValue        string       `json:"unitValue"`
	MinUnitPerLine   string       `json:"minUnitPerLine"`
	MaxUnitPerLine   string       `json:"maxUnitPerLine"`
	MinUnitPerTicket string       `json:"minUnitPerTicket"`
	MaxUnitPerTicket string       `json:"maxUnitPerTicket"`
	Currency         PoolCurrency `json:"currency"`
	Note             *string      `json:"note"`
}

type CreatePoolInput struct {
	Name             string       `json:"name"`
	Type             PoolType     `json:"type"`
	Guarantee        string       `json:"guarantee"`
	CarryIn          string       `json:"carryIn"`
	Allocation       string       `json:"allocation"`
	Game             Game         `json:"game"`
	Note             *string      `json:"note"`
	UnitValue        string       `json:"unitValue"`
	Currency         PoolCurrency `json:"currency"`
	MinUnitPerLine   string       `json:"minUnitPerLine"`
	MaxUnitPerLine   string       `json:"maxUnitPerLine"`
	MinUnitPerTicket string       `json:"minUnitPerTicket"`
	MaxUnitPerTicket string       `json:"maxUnitPerTicket"`
}

type CreateUserInput struct {
	Email    string     `json:"email"`
	Password string     `json:"password"`
	Role     AccessRole `json:"role"`
}

type EventFilter struct {
	ID         *string  `json:"id"`
	Name       *string  `json:"name"`
	IsActive   *bool    `json:"isActive"`
	Game       *Game    `json:"game"`
	ExternalID *string  `json:"externalId"`
	Ids        []string `json:"ids"`
}

type LegFilter struct {
	ID      *string  `json:"id"`
	MatchID *string  `json:"matchId"`
	PoolID  *string  `json:"poolId"`
	Ids     []string `json:"ids"`
}

type ListMetadata struct {
	Count int `json:"count"`
}

type MatchFilter struct {
	ID              *string              `json:"id"`
	Name            *string              `json:"name"`
	ExternalID      *string              `json:"externalId"`
	IsActive        *bool                `json:"isActive"`
	IsAutogenerated *bool                `json:"isAutogenerated"`
	InternalStatus  *MatchInternalStatus `json:"internalStatus"`
	Format          *MatchFormat         `json:"format"`
	EventStage      *string              `json:"eventStage"`
	EventID         *string              `json:"eventId"`
	Ids             []string             `json:"ids"`
}

type OverUnderDefaultFilter struct {
	Game        *Game        `json:"game"`
	MatchFormat *MatchFormat `json:"matchFormat"`
	Ids         []string     `json:"ids"`
}

type PlayerFilter struct {
	ID         *string  `json:"id"`
	Name       *string  `json:"name"`
	Nickname   *string  `json:"nickname"`
	ExternalID *string  `json:"externalId"`
	TeamID     *string  `json:"teamId"`
	Ids        []string `json:"ids"`
}

type PoolDefaultFilter struct {
	Type *PoolType `json:"type"`
	Game *Game     `json:"game"`
}

type PoolFilter struct {
	ID                 *string     `json:"id"`
	Name               *string     `json:"name"`
	IsActive           *bool       `json:"isActive"`
	IsAutogenerated    *bool       `json:"isAutogenerated"`
	PoolStatus         *PoolStatus `json:"poolStatus"`
	Guarantee          *string     `json:"guarantee"`
	LegCount           *string     `json:"legCount"`
	Type               *PoolType   `json:"type"`
	Game               *Game       `json:"game"`
	EventID            *string     `json:"eventId"`
	LastSyncTimeBefore *time.Time  `json:"lastSyncTimeBefore"`
	LastSyncTimeAfter  *time.Time  `json:"lastSyncTimeAfter"`
	Ids                []string    `json:"ids"`
}

type Session struct {
	Token string `json:"token"`
}

type TeamProbabilities struct {
	TeamID      string  `json:"teamId"`
	Probability float64 `json:"probability"`
}

type TeamScore struct {
	TeamID string `json:"teamId"`
	Score  int    `json:"score"`
}

type TeamScores struct {
	TeamID string `json:"teamId"`
	Score  int    `json:"score"`
}

type TeamWinProbability struct {
	TeamID      string `json:"teamId"`
	Probability string `json:"probability"`
}

type UpdateCompetitorInput struct {
	ID   string  `json:"id"`
	Name *string `json:"name"`
	Logo *string `json:"logo"`
}

type UpdateConsolationPrize struct {
	Guarantee  string `json:"guarantee"`
	CarryIn    string `json:"carryIn"`
	Allocation string `json:"allocation"`
}

type UpdateEventInput struct {
	ID        string     `json:"id"`
	Name      *string    `json:"name"`
	Type      *EventType `json:"type"`
	Game      *Game      `json:"game"`
	Logo      *string    `json:"logo"`
	StartDate *time.Time `json:"startDate"`
	EndDate   *time.Time `json:"endDate"`
	IsActive  *bool      `json:"isActive"`
}

type UpdateLegInput struct {
	ID        string  `json:"id"`
	Threshold *string `json:"threshold"`
	MatchID   *string `json:"matchId"`
	PoolID    *string `json:"poolId"`
}

type UpdateMatchInput struct {
	ID                   string                     `json:"id"`
	Name                 *string                    `json:"name"`
	Description          *string                    `json:"description"`
	StartTime            *time.Time                 `json:"startTime"`
	IsActive             *bool                      `json:"isActive"`
	InternalStatus       *MatchInternalStatus       `json:"internalStatus"`
	EventStage           *string                    `json:"eventStage"`
	EventID              *string                    `json:"eventId"`
	TeamScores           []*UpdateTeamScores        `json:"teamScores"`
	TeamOuScores         []*UpdateTeamScores        `json:"teamOuScores"`
	TeamWinProbabilities []*UpdateTeamProbabilities `json:"teamWinProbabilities"`
	Format               *MatchFormat               `json:"format"`
}

type UpdateOverUnderDefaultInput struct {
	ID               string  `json:"id"`
	EvenThreshold    *string `json:"evenThreshold"`
	FavoredThreshold *string `json:"favoredThreshold"`
	Note             *string `json:"note"`
}

type UpdatePlayerInput struct {
	ID       string  `json:"id"`
	Name     *string `json:"name"`
	Nickname *string `json:"nickname"`
	TeamID   *string `json:"teamId"`
}

type UpdatePoolDefaultInput struct {
	ID               string        `json:"id"`
	LegCount         *string       `json:"legCount"`
	Game             *Game         `json:"game"`
	Type             *PoolType     `json:"type"`
	Guarantee        *string       `json:"guarantee"`
	CarryIn          *string       `json:"carryIn"`
	Allocation       *string       `json:"allocation"`
	UnitValue        *string       `json:"unitValue"`
	MinUnitPerLine   *string       `json:"minUnitPerLine"`
	MaxUnitPerLine   *string       `json:"maxUnitPerLine"`
	MinUnitPerTicket *string       `json:"minUnitPerTicket"`
	MaxUnitPerTicket *string       `json:"maxUnitPerTicket"`
	Currency         *PoolCurrency `json:"currency"`
	Note             *string       `json:"note"`
}

type UpdatePoolInput struct {
	ID                   string                    `json:"id"`
	Name                 *string                   `json:"name"`
	IsActive             *bool                     `json:"isActive"`
	Guarantee            string                    `json:"guarantee"`
	CarryIn              string                    `json:"carryIn"`
	Allocation           string                    `json:"allocation"`
	Note                 *string                   `json:"note"`
	UnitValue            *string                   `json:"unitValue"`
	MinUnitPerLine       *string                   `json:"minUnitPerLine"`
	MaxUnitPerLine       *string                   `json:"maxUnitPerLine"`
	MinUnitPerTicket     *string                   `json:"minUnitPerTicket"`
	MaxUnitPerTicket     *string                   `json:"maxUnitPerTicket"`
	Currency             *PoolCurrency             `json:"currency"`
	SyncedColossusStatus *PoolStatus               `json:"syncedColossusStatus"`
	LegsIds              []string                  `json:"legsIds"`
	ConsolationPrizes    []*UpdateConsolationPrize `json:"consolationPrizes"`
}

type UpdateTeamProbabilities struct {
	TeamID      string  `json:"teamId"`
	Probability float64 `json:"probability"`
}

type UpdateTeamScores struct {
	TeamID string `json:"teamId"`
	Score  int    `json:"score"`
}

type UpdateUserInput struct {
	ID         string      `json:"id"`
	Email      *string     `json:"email"`
	Password   *string     `json:"password"`
	AccessRole *AccessRole `json:"accessRole"`
}

type UserFilter struct {
	Email *string     `json:"email"`
	Role  *AccessRole `json:"role"`
	Ids   []string    `json:"ids"`
}

type AccessRole string

const (
	AccessRoleSuperAdmin   AccessRole = "SUPER_ADMIN"
	AccessRoleAdmin        AccessRole = "ADMIN"
	AccessRoleUser         AccessRole = "USER"
	AccessRoleGuestAPIOnly AccessRole = "GUEST_API_ONLY"
)

var AllAccessRole = []AccessRole{
	AccessRoleSuperAdmin,
	AccessRoleAdmin,
	AccessRoleUser,
	AccessRoleGuestAPIOnly,
}

func (e AccessRole) IsValid() bool {
	switch e {
	case AccessRoleSuperAdmin, AccessRoleAdmin, AccessRoleUser, AccessRoleGuestAPIOnly:
		return true
	}
	return false
}

func (e AccessRole) String() string {
	return string(e)
}

func (e *AccessRole) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AccessRole(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AccessRole", str)
	}
	return nil
}

func (e AccessRole) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EditAction string

const (
	EditActionCreate EditAction = "CREATE"
	EditActionUpdate EditAction = "UPDATE"
	EditActionDelete EditAction = "DELETE"
)

var AllEditAction = []EditAction{
	EditActionCreate,
	EditActionUpdate,
	EditActionDelete,
}

func (e EditAction) IsValid() bool {
	switch e {
	case EditActionCreate, EditActionUpdate, EditActionDelete:
		return true
	}
	return false
}

func (e EditAction) String() string {
	return string(e)
}

func (e *EditAction) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EditAction(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EditAction", str)
	}
	return nil
}

func (e EditAction) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EventType string

const (
	EventTypeTournament EventType = "TOURNAMENT"
)

var AllEventType = []EventType{
	EventTypeTournament,
}

func (e EventType) IsValid() bool {
	switch e {
	case EventTypeTournament:
		return true
	}
	return false
}

func (e EventType) String() string {
	return string(e)
}

func (e *EventType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EventType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EventType", str)
	}
	return nil
}

func (e EventType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Game string

const (
	GameCounterStrikeGlobalOffensive Game = "COUNTER_STRIKE_GLOBAL_OFFENSIVE"
	GameDota2                        Game = "DOTA_2"
	GameLeagueOfLegends              Game = "LEAGUE_OF_LEGENDS"
	GamePubg                         Game = "PUBG"
	GameApexLegends                  Game = "APEX_LEGENDS"
	GameUnderlords                   Game = "UNDERLORDS"
	GameTeamfightTactics             Game = "TEAMFIGHT_TACTICS"
	GameAutoChess                    Game = "AUTO_CHESS"
	GameStarcraft2                   Game = "STARCRAFT_2"
	GameOverwatch                    Game = "OVERWATCH"
	GameRainbowSixSiege              Game = "RAINBOW_SIX_SIEGE"
	GameHearthstone                  Game = "HEARTHSTONE"
	GameHeroesOfTheStorm             Game = "HEROES_OF_THE_STORM"
	GameWarcraft3                    Game = "WARCRAFT_3"
	GameRocketLeague                 Game = "ROCKET_LEAGUE"
	GameCallOfDuty                   Game = "CALL_OF_DUTY"
	GameVainGlory                    Game = "VAIN_GLORY"
	GameHalo                         Game = "HALO"
	GameQuake                        Game = "QUAKE"
	GameKingOfGlory                  Game = "KING_OF_GLORY"
	GameWorldOfWarcraft              Game = "WORLD_OF_WARCRAFT"
	GameFifa                         Game = "FIFA"
	GameSmite                        Game = "SMITE"
	GameWorldOfTanks                 Game = "WORLD_OF_TANKS"
	GameGwent                        Game = "GWENT"
	GameMadden                       Game = "MADDEN"
	GameBattlefield5                 Game = "BATTLEFIELD_5"
	GameNba2k                        Game = "NBA2K"
	GameStreetFighter                Game = "STREET_FIGHTER"
	GameStarcraftBroodwar            Game = "STARCRAFT_BROODWAR"
	GameMagicTheGathering            Game = "MAGIC_THE_GATHERING"
	GameUnknown                      Game = "UNKNOWN"
)

var AllGame = []Game{
	GameCounterStrikeGlobalOffensive,
	GameDota2,
	GameLeagueOfLegends,
	GamePubg,
	GameApexLegends,
	GameUnderlords,
	GameTeamfightTactics,
	GameAutoChess,
	GameStarcraft2,
	GameOverwatch,
	GameRainbowSixSiege,
	GameHearthstone,
	GameHeroesOfTheStorm,
	GameWarcraft3,
	GameRocketLeague,
	GameCallOfDuty,
	GameVainGlory,
	GameHalo,
	GameQuake,
	GameKingOfGlory,
	GameWorldOfWarcraft,
	GameFifa,
	GameSmite,
	GameWorldOfTanks,
	GameGwent,
	GameMadden,
	GameBattlefield5,
	GameNba2k,
	GameStreetFighter,
	GameStarcraftBroodwar,
	GameMagicTheGathering,
	GameUnknown,
}

func (e Game) IsValid() bool {
	switch e {
	case GameCounterStrikeGlobalOffensive, GameDota2, GameLeagueOfLegends, GamePubg, GameApexLegends, GameUnderlords, GameTeamfightTactics, GameAutoChess, GameStarcraft2, GameOverwatch, GameRainbowSixSiege, GameHearthstone, GameHeroesOfTheStorm, GameWarcraft3, GameRocketLeague, GameCallOfDuty, GameVainGlory, GameHalo, GameQuake, GameKingOfGlory, GameWorldOfWarcraft, GameFifa, GameSmite, GameWorldOfTanks, GameGwent, GameMadden, GameBattlefield5, GameNba2k, GameStreetFighter, GameStarcraftBroodwar, GameMagicTheGathering, GameUnknown:
		return true
	}
	return false
}

func (e Game) String() string {
	return string(e)
}

func (e *Game) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Game(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Game", str)
	}
	return nil
}

func (e Game) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type MatchColossusStatus string

const (
	MatchColossusStatusUnknown    MatchColossusStatus = "UNKNOWN"
	MatchColossusStatusNotStarted MatchColossusStatus = "NOT_STARTED"
	MatchColossusStatusSyncError  MatchColossusStatus = "SYNC_ERROR"
	MatchColossusStatusInPlay     MatchColossusStatus = "IN_PLAY"
	MatchColossusStatusCompleted  MatchColossusStatus = "COMPLETED"
	MatchColossusStatusOfficial   MatchColossusStatus = "OFFICIAL"
	MatchColossusStatusAbandoned  MatchColossusStatus = "ABANDONED"
)

var AllMatchColossusStatus = []MatchColossusStatus{
	MatchColossusStatusUnknown,
	MatchColossusStatusNotStarted,
	MatchColossusStatusSyncError,
	MatchColossusStatusInPlay,
	MatchColossusStatusCompleted,
	MatchColossusStatusOfficial,
	MatchColossusStatusAbandoned,
}

func (e MatchColossusStatus) IsValid() bool {
	switch e {
	case MatchColossusStatusUnknown, MatchColossusStatusNotStarted, MatchColossusStatusSyncError, MatchColossusStatusInPlay, MatchColossusStatusCompleted, MatchColossusStatusOfficial, MatchColossusStatusAbandoned:
		return true
	}
	return false
}

func (e MatchColossusStatus) String() string {
	return string(e)
}

func (e *MatchColossusStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MatchColossusStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MatchColossusStatus", str)
	}
	return nil
}

func (e MatchColossusStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type MatchFormat string

const (
	MatchFormatBo2     MatchFormat = "bo2"
	MatchFormatBo3     MatchFormat = "bo3"
	MatchFormatBo5     MatchFormat = "bo5"
	MatchFormatUnknown MatchFormat = "UNKNOWN"
)

var AllMatchFormat = []MatchFormat{
	MatchFormatBo2,
	MatchFormatBo3,
	MatchFormatBo5,
	MatchFormatUnknown,
}

func (e MatchFormat) IsValid() bool {
	switch e {
	case MatchFormatBo2, MatchFormatBo3, MatchFormatBo5, MatchFormatUnknown:
		return true
	}
	return false
}

func (e MatchFormat) String() string {
	return string(e)
}

func (e *MatchFormat) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MatchFormat(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MatchFormat", str)
	}
	return nil
}

func (e MatchFormat) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type MatchInternalStatus string

const (
	MatchInternalStatusNotReady    MatchInternalStatus = "NOT_READY"
	MatchInternalStatusScheduled   MatchInternalStatus = "SCHEDULED"
	MatchInternalStatusInProgress  MatchInternalStatus = "IN_PROGRESS"
	MatchInternalStatusFinished    MatchInternalStatus = "FINISHED"
	MatchInternalStatusClosed      MatchInternalStatus = "CLOSED"
	MatchInternalStatusPostponed   MatchInternalStatus = "POSTPONED"
	MatchInternalStatusSuspended   MatchInternalStatus = "SUSPENDED"
	MatchInternalStatusDelayed     MatchInternalStatus = "DELAYED"
	MatchInternalStatusCancelled   MatchInternalStatus = "CANCELLED"
	MatchInternalStatusInterrupted MatchInternalStatus = "INTERRUPTED"
	MatchInternalStatusAbandoned   MatchInternalStatus = "ABANDONED"
	MatchInternalStatusUnknown     MatchInternalStatus = "UNKNOWN"
)

var AllMatchInternalStatus = []MatchInternalStatus{
	MatchInternalStatusNotReady,
	MatchInternalStatusScheduled,
	MatchInternalStatusInProgress,
	MatchInternalStatusFinished,
	MatchInternalStatusClosed,
	MatchInternalStatusPostponed,
	MatchInternalStatusSuspended,
	MatchInternalStatusDelayed,
	MatchInternalStatusCancelled,
	MatchInternalStatusInterrupted,
	MatchInternalStatusAbandoned,
	MatchInternalStatusUnknown,
}

func (e MatchInternalStatus) IsValid() bool {
	switch e {
	case MatchInternalStatusNotReady, MatchInternalStatusScheduled, MatchInternalStatusInProgress, MatchInternalStatusFinished, MatchInternalStatusClosed, MatchInternalStatusPostponed, MatchInternalStatusSuspended, MatchInternalStatusDelayed, MatchInternalStatusCancelled, MatchInternalStatusInterrupted, MatchInternalStatusAbandoned, MatchInternalStatusUnknown:
		return true
	}
	return false
}

func (e MatchInternalStatus) String() string {
	return string(e)
}

func (e *MatchInternalStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MatchInternalStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MatchInternalStatus", str)
	}
	return nil
}

func (e MatchInternalStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PoolCurrency string

const (
	PoolCurrencyStr PoolCurrency = "STR"
)

var AllPoolCurrency = []PoolCurrency{
	PoolCurrencyStr,
}

func (e PoolCurrency) IsValid() bool {
	switch e {
	case PoolCurrencyStr:
		return true
	}
	return false
}

func (e PoolCurrency) String() string {
	return string(e)
}

func (e *PoolCurrency) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PoolCurrency(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PoolCurrency", str)
	}
	return nil
}

func (e PoolCurrency) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PoolStatus string

const (
	PoolStatusNotReady      PoolStatus = "NOT_READY"
	PoolStatusNeedsApproval PoolStatus = "NEEDS_APPROVAL"
	PoolStatusSyncError     PoolStatus = "SYNC_ERROR"
	PoolStatusApproved      PoolStatus = "APPROVED"
	PoolStatusCreated       PoolStatus = "CREATED"
	PoolStatusVisible       PoolStatus = "VISIBLE"
	PoolStatusTradingOpen   PoolStatus = "TRADING_OPEN"
	PoolStatusTradingClosed PoolStatus = "TRADING_CLOSED"
	PoolStatusOfficial      PoolStatus = "OFFICIAL"
	PoolStatusSettled       PoolStatus = "SETTLED"
	PoolStatusAbandoned     PoolStatus = "ABANDONED"
)

var AllPoolStatus = []PoolStatus{
	PoolStatusNotReady,
	PoolStatusNeedsApproval,
	PoolStatusSyncError,
	PoolStatusApproved,
	PoolStatusCreated,
	PoolStatusVisible,
	PoolStatusTradingOpen,
	PoolStatusTradingClosed,
	PoolStatusOfficial,
	PoolStatusSettled,
	PoolStatusAbandoned,
}

func (e PoolStatus) IsValid() bool {
	switch e {
	case PoolStatusNotReady, PoolStatusNeedsApproval, PoolStatusSyncError, PoolStatusApproved, PoolStatusCreated, PoolStatusVisible, PoolStatusTradingOpen, PoolStatusTradingClosed, PoolStatusOfficial, PoolStatusSettled, PoolStatusAbandoned:
		return true
	}
	return false
}

func (e PoolStatus) String() string {
	return string(e)
}

func (e *PoolStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PoolStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PoolStatus", str)
	}
	return nil
}

func (e PoolStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PoolType string

const (
	PoolTypeH2h       PoolType = "H2H"
	PoolTypeOverUnder PoolType = "OVER_UNDER"
	PoolTypeFantasy   PoolType = "FANTASY"
)

var AllPoolType = []PoolType{
	PoolTypeH2h,
	PoolTypeOverUnder,
	PoolTypeFantasy,
}

func (e PoolType) IsValid() bool {
	switch e {
	case PoolTypeH2h, PoolTypeOverUnder, PoolTypeFantasy:
		return true
	}
	return false
}

func (e PoolType) String() string {
	return string(e)
}

func (e *PoolType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PoolType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PoolType", str)
	}
	return nil
}

func (e PoolType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ProductType string

const (
	ProductTypeOutlast ProductType = "OUTLAST"
	ProductTypeBrawl   ProductType = "BRAWL"
	ProductTypeHero    ProductType = "HERO"
)

var AllProductType = []ProductType{
	ProductTypeOutlast,
	ProductTypeBrawl,
	ProductTypeHero,
}

func (e ProductType) IsValid() bool {
	switch e {
	case ProductTypeOutlast, ProductTypeBrawl, ProductTypeHero:
		return true
	}
	return false
}

func (e ProductType) String() string {
	return string(e)
}

func (e *ProductType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProductType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProductType", str)
	}
	return nil
}

func (e ProductType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

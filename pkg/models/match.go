package models

import (
	"reflect"
	"time"

	"github.com/go-pg/pg"
	"github.com/gofrs/uuid"
	"github.com/shopspring/decimal"
	"gitlab.com/siimpl/esp-betting/betting-feed/pkg/repository"
)

var DB *pg.DB

// Match are a group of GameSessions that have a overall winner and loser.
type Match struct {
	TableName            struct{} `sql:"matches,alias:match"`
	StartTime            time.Time
	Competitors          []Competitor `pg:"many2many:competitor_match"`
	ColossusMatches      []ColossusMatch
	ExternalID           string
	Name                 string
	Description          string
	EventStage           string
	InternalStatus       MatchInternalStatus
	TeamScores           map[string]int
	TeamOuScores         map[string]int
	TeamWinProbabilities map[string]decimal.Decimal
	Statistics           map[string]interface{}
	ID                   uuid.NullUUID
	EventID              uuid.NullUUID `pg:",fk"`
	IsActive             bool          `sql:",notnull"`
	IsAutogenerated      bool          `sql:",notnull"`
	Format               MatchFormat
}

type MatchWithAssociatedLegsCount struct {
	Match               `pg:",inherit"`
	AssociatedLegsCount int
}

func (m *Match) GetID() string {
	return m.ID.UUID.String()
}

func (m *Match) GetEventID() string {
	return m.EventID.UUID.String()
}

func (m *Match) GetTotalTeamProbabilities() decimal.Decimal {
	totalProb := decimal.NewFromFloat(0)
	for _, team := range m.Competitors {
		totalProb = totalProb.Add(m.TeamWinProbabilities[team.ExternalID])
	}
	return totalProb
}

// Tests Equality of parts of the model that are not child objects or the ID
// Does not test colossus related statuses
func (m *Match) EqualsShallow(b *Match) bool {

	return (m.StartTime.Equal(b.StartTime) &&
		m.ExternalID == b.ExternalID &&
		m.Description == b.Description &&
		m.EventStage == b.EventStage &&
		m.EventID == b.EventID &&
		m.IsActive == b.IsActive &&
		m.IsAutogenerated == b.IsAutogenerated &&
		m.InternalStatus == b.InternalStatus &&
		reflect.DeepEqual(m.TeamScores, b.TeamScores) &&
		reflect.DeepEqual(m.Statistics, b.Statistics) &&
		reflect.DeepEqual(m.TeamOuScores, b.TeamOuScores))
}

func (m *Match) AddProbabilities(competitor Competitor, db repository.DataSource) error {
	match := Match{ID: m.ID}
	err := db.Select(&match)

	if err != nil {
		return err
	}

	if match.TeamScores == nil {
		match.TeamScores = make(map[string]int)
	}

	if _, exists := match.TeamScores[competitor.ExternalID]; !exists {
		match.TeamScores[competitor.ExternalID] = 0
	}

	if match.TeamOuScores == nil {
		match.TeamOuScores = make(map[string]int)
	}

	if _, exists := match.TeamOuScores[competitor.ExternalID]; !exists {
		match.TeamOuScores[competitor.ExternalID] = 0
	}

	if match.TeamWinProbabilities == nil {
		match.TeamWinProbabilities = make(map[string]decimal.Decimal)
	}

	if _, exists := match.TeamWinProbabilities[competitor.ExternalID]; !exists {
		match.TeamWinProbabilities[competitor.ExternalID] = decimal.NewFromFloat(50)
	}

	_, err = db.Model(&match).WherePK().Update()

	return err
}

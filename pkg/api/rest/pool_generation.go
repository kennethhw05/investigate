package rest

import (
	"encoding/json"
	"fmt"
	"net/http"
	"time"

	"github.com/gofrs/uuid"
	"github.com/sirupsen/logrus"
	"gitlab.com/siimpl/esp-betting/betting-feed/pkg/auth"
	"gitlab.com/siimpl/esp-betting/betting-feed/pkg/config"
	"gitlab.com/siimpl/esp-betting/betting-feed/pkg/datafeeder"
	"gitlab.com/siimpl/esp-betting/betting-feed/pkg/models"
	"gitlab.com/siimpl/esp-betting/betting-feed/pkg/repository"
)

// PoolGenerationHandler handles restful calls for generating test pools
type PoolGenerationHandler struct {
	CFG    *config.Config
	DB     repository.DataSource
	Logger *logrus.Logger
}

type generatedEvent struct {
	ID uuid.NullUUID `json:"id"`
}

func (h *PoolGenerationHandler) generatePool() (uuid.NullUUID, error) {
	eventStage := "Test Stage"

	// Generate Event
	event := models.Event{
		StartDate:       time.Now(),
		EndDate:         time.Now().Add(time.Hour * 24 * 7),
		Name:            fmt.Sprintf("Autogenerated event %v", time.Now()),
		Type:            models.EventTypeTournament,
		Game:            models.GameDota2,
		IsAutogenerated: true,
		IsActive:        true,
	}
	_, err := h.DB.Model(&event).Insert()
	if err != nil {
		return event.ID, err
	}

	// Generate Matches with Teams
	legCount := 4
	matchIds := []uuid.NullUUID{}
	for i := 0; i < legCount; i++ {
		match := models.Match{
			Name:           fmt.Sprintf("Test match %d of %d", i+1, legCount),
			EventID:        event.ID,
			StartTime:      time.Now().Add(time.Hour * time.Duration(i+1)),
			InternalStatus: models.MatchInternalStatusScheduled,
			EventStage:     eventStage,
			Format:         "bo3",
			Description:    "Autogenerated test match",
			IsActive:       true,
		}

		err = h.DB.Insert(&match)

		if err != nil {
			return event.ID, err
		}

		match.ExternalID = models.GenerateInternalXID(&models.Match{}, match.GetID())

		_, err = h.DB.Model(&match).WherePK().Update()

		if err != nil {
			return event.ID, err
		}

		matchIds = append(matchIds, match.ID)

		// Add Competitors to Match
		for j := 0; j < 2; j++ {
			competitor := models.Competitor{
				Name: fmt.Sprintf("Competitor %d-%d", i+1, j+1),
			}

			err = h.DB.Insert(&competitor)

			if err != nil {
				return event.ID, err
			}

			//update competitor External ID
			competitor.ExternalID = models.GenerateInternalXID(&models.Competitor{}, competitor.GetID())
			_, err = h.DB.Model(&competitor).WherePK().Update()

			if err != nil {
				return event.ID, err
			}

			//add competitor -> match mapping
			competitorMatch := models.CompetitorMatch{}
			err = competitorMatch.AddRelationship(&competitor, &match, h.DB)
			if err != nil {
				return event.ID, err
			}

			err = match.AddProbabilities(competitor, h.DB)

			if err != nil {
				return event.ID, err
			}
		}
	}

	// Generate Pool
	tuple := datafeeder.EventStageTuple{
		EventStage: eventStage,
		EventID:    event.ID,
	}

	feeder := datafeeder.InternalToInternalFeeder(h.CFG, h.DB, h.Logger)

	feeder.CreatePoolsFromStage(&tuple)

	return event.ID, err
}

// GeneratePool creates a pool and returns the pool id
func (h *PoolGenerationHandler) GeneratePool(w http.ResponseWriter, r *http.Request) {
	println("GeneratePool start")
	ctx := r.Context()

	_, err := auth.Authorize(ctx, []models.AccessRole{
		models.AccessRoleSuperAdmin,
		models.AccessRoleAdmin,
	})

	if err != nil {
		w.WriteHeader(http.StatusForbidden)
		return
	}

	eventID, err := h.generatePool()

	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
	} else {
		w.WriteHeader(http.StatusOK)
		json.NewEncoder(w).Encode(generatedEvent{
			ID: eventID,
		})
	}
}

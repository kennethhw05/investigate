package graphql

import (
	context "context"
	"fmt"
	"time"

	"github.com/shopspring/decimal"

	sq "github.com/Masterminds/squirrel"
	"gitlab.com/siimpl/esp-betting/betting-feed/pkg/audit"
	"gitlab.com/siimpl/esp-betting/betting-feed/pkg/auth"
	models "gitlab.com/siimpl/esp-betting/betting-feed/pkg/models"
	"gitlab.com/siimpl/esp-betting/betting-feed/pkg/repository"
)

type poolResolver struct{ *Resolver }

func (r *poolResolver) ID(ctx context.Context, obj *models.Pool) (string, error) {
	return obj.GetID(), nil
}

func (r *poolResolver) Guarantee(ctx context.Context, obj *models.Pool) (string, error) {
	return obj.Guarantee.Decimal.String(), nil
}

func (r *poolResolver) CarryIn(ctx context.Context, obj *models.Pool) (string, error) {
	return obj.CarryIn.Decimal.String(), nil
}

func (r *poolResolver) Allocation(ctx context.Context, obj *models.Pool) (string, error) {
	return obj.Allocation.Decimal.String(), nil
}

func (r *poolResolver) MinUnitPerLine(ctx context.Context, obj *models.Pool) (string, error) {
	return obj.MinUnitPerLine.Decimal.String(), nil
}

func (r *poolResolver) MaxUnitPerLine(ctx context.Context, obj *models.Pool) (string, error) {
	return obj.MaxUnitPerLine.Decimal.String(), nil
}

func (r *poolResolver) MinUnitPerTicket(ctx context.Context, obj *models.Pool) (string, error) {
	return obj.MinUnitPerTicket.Decimal.String(), nil
}

func (r *poolResolver) MaxUnitPerTicket(ctx context.Context, obj *models.Pool) (string, error) {
	return obj.MaxUnitPerTicket.Decimal.String(), nil
}

func (r *poolResolver) UnitValue(ctx context.Context, obj *models.Pool) (string, error) {
	return obj.UnitValue.Decimal.String(), nil
}

// ConsolationPrizes(ctx context.Context, obj *models.Pool) ([]models.ConsolationPrize, error)
func (r *poolResolver) ConsolationPrizes(ctx context.Context, obj *models.Pool) ([]*models.ConsolationPrize, error) {
	return obj.Consolations, nil
}

func (r *queryResolver) Pool(ctx context.Context, id string) (*models.Pool, error) {
	_, err := auth.Authorize(ctx, []models.AccessRole{
		models.AccessRoleSuperAdmin,
		models.AccessRoleAdmin,
		models.AccessRoleUser,
		models.AccessRoleGuestAPIOnly,
	})

	pool := models.Pool{}
	sqlmatches := sq.Select("pools.*").From("pools").Where(sq.Eq{fmt.Sprintf("%s.id", "pools"): id})

	sql, args, _ := sqlmatches.ToSql()
	_, err = r.DB.QueryOne(&pool, sql, args...)

	r.DB.Query(&pool.Legs, "select * from legs where pool_id = ?", pool.GetID())

	return &pool, err
}

func (r *queryResolver) AllPools(ctx context.Context, filter *models.PoolFilter, page *int, perPage *int, sortField *string, sortOrder *string) ([]*models.Pool, error) {
	_, err := auth.Authorize(ctx, []models.AccessRole{
		models.AccessRoleSuperAdmin,
		models.AccessRoleAdmin,
		models.AccessRoleUser,
	})
	if err != nil {
		return []*models.Pool{}, err
	}

	var pools []*models.Pool

	sqlbuilder := sq.Select("pools.*").From("pools")
	sql, args := createAllPoolsSQL(sqlbuilder, filter, page, perPage, sortField, sortOrder)
	_, err = r.DB.Query(&pools, sql, args...)
	return pools, err
}

func (r *queryResolver) _allPoolsMeta(ctx context.Context, filter *models.PoolFilter, page *int, perPage *int) (*models.ListMetadata, error) {
	_, err := auth.Authorize(ctx, []models.AccessRole{
		models.AccessRoleSuperAdmin,
		models.AccessRoleAdmin,
		models.AccessRoleUser,
	})
	if err != nil {
		return &models.ListMetadata{}, err
	}

	var count int
	sqlbuilder := sq.Select("COUNT(distinct pools.id)").From("pools")
	sql, args := createAllPoolsSQL(sqlbuilder, filter, nil, nil, nil, nil)
	_, err = r.DB.Query(&count, sql, args...)

	return &models.ListMetadata{Count: count}, err
}

func createAllPoolsSQL(builder sq.SelectBuilder, filter *models.PoolFilter, page *int, perPage *int, sortField *string, sortOrder *string) (sql string, args []interface{}) {
	if filter != nil {
		if filter.Name != nil {
			builder = builder.Where("pools.name ILIKE ?", fmt.Sprint("%", *filter.Name, "%"))
		}

		if filter.IsActive != nil {
			val := false
			if *filter.IsActive {
				val = true
			}
			builder = builder.Where("pools.is_active = ?", val)
		}
		if filter.IsAutogenerated != nil {
			val := false
			if *filter.IsAutogenerated {
				val = true
			}
			builder = builder.Where("pools.is_autogenerated = ?", val)
		}
		if filter.Game != nil {
			builder = builder.Where("pools.game = ?", filter.Game.String())
		}

		if filter.EventID != nil {
			builder = builder.
				Join("legs on legs.pool_id = pools.id").
				Join("matches on legs.match_id = matches.id").
				Where("matches.event_id = ?", filter.EventID).
				GroupBy("pools.id").
				Having("COUNT(legs) > 0")
		}

		if filter.PoolStatus != nil {
			builder = builder.Where("pools.synced_colossus_status = ?", filter.PoolStatus.String())
		}

		if filter.Type != nil {
			builder = builder.Where("pools.type = ?", filter.Type.String())
		}

		if filter.Guarantee != nil {
			builder = builder.Where("pools.guarantee = ?", parseNullDecimal(*filter.Guarantee))
		}

		if filter.LegCount != nil {
			builder = builder.Where("(select count(legs.id) from legs where legs.pool_id = pools.id) = ?", parseNullDecimal(*filter.LegCount))
		}

		if filter.LastSyncTimeBefore != nil {
			builder = builder.Where("pools.last_sync_time <= ?", filter.LastSyncTimeBefore.Format(time.RFC3339))
		}

		if filter.LastSyncTimeAfter != nil {
			builder = builder.Where("pools.last_sync_time >= ?", filter.LastSyncTimeAfter.Format(time.RFC3339))
		}

		if filter.ID != nil {
			filter.Ids = append(filter.Ids, *filter.ID)
		}

		builder = filterByIDs(builder, filter.Ids, "pools")
	}

	builder = addDefaultSort(builder, sortField, sortOrder)
	builder = addStandardPagination(builder, page, perPage)

	sql, args, _ = builder.ToSql()
	return sql, args
}

func (r *mutationResolver) CreatePool(ctx context.Context, input models.CreatePoolInput) (*models.Pool, error) {
	userID, err := auth.Authorize(ctx, []models.AccessRole{
		models.AccessRoleSuperAdmin,
		models.AccessRoleAdmin,
	})
	if err != nil {
		return &models.Pool{}, err
	}

	pool := models.Pool{
		Name:                 input.Name,
		Type:                 input.Type,
		Game:                 input.Game,
		SyncedColossusStatus: models.PoolStatusNotReady,
		Currency:             input.Currency,
		UnitValue:            parseNullDecimal(input.UnitValue),
		MinUnitPerLine:       parseNullDecimal(input.MinUnitPerLine),
		MaxUnitPerLine:       parseNullDecimal(input.MaxUnitPerLine),
		MinUnitPerTicket:     parseNullDecimal(input.MinUnitPerTicket),
		MaxUnitPerTicket:     parseNullDecimal(input.MaxUnitPerTicket),
		Guarantee:            parseNullDecimal(input.Guarantee),
		CarryIn:              parseNullDecimal(input.CarryIn),
		Allocation:           parseNullDecimal(input.Allocation),
		IsAutogenerated:      false,
	}

	if input.Note != nil {
		pool.Note = *input.Note
	}

	err = r.DB.Insert(&pool)
	if err != nil {
		return &models.Pool{}, err
	}

	audit.CreateAudit(r.DB, pool.ID, repository.NewSQLCompatUUIDFromStr(userID), models.EditActionCreate, pool)
	return &pool, err
}

func (r *mutationResolver) UpdatePool(ctx context.Context, input models.UpdatePoolInput) (*models.Pool, error) {
	userID, err := auth.Authorize(ctx, []models.AccessRole{
		models.AccessRoleSuperAdmin,
		models.AccessRoleAdmin,
	})
	if err != nil {
		return &models.Pool{}, err
	}

	var pool models.Pool

	sqlbuilder := sq.Update("pools")
	field := fmt.Sprintf("%s.id", "pools")
	sqlbuilder = sqlbuilder.Where(sq.Eq{field: input.ID})

	if input.SyncedColossusStatus != nil {
		sqlbuilder = sqlbuilder.Set("synced_colossus_status", input.SyncedColossusStatus)
	}

	if input.Note != nil {
		sqlbuilder = sqlbuilder.Set("note", *input.Note)
	}

	if input.Name != nil {
		sqlbuilder = sqlbuilder.Set("name", *input.Name)
	}

	if input.IsActive != nil {
		sqlbuilder = sqlbuilder.Set("is_active", *input.IsActive)
	}

	if input.UnitValue != nil {
		sqlbuilder = sqlbuilder.Set("unit_value", parseNullDecimal(*input.UnitValue))
	}

	if input.MinUnitPerLine != nil {
		sqlbuilder = sqlbuilder.Set("min_unit_per_line", parseNullDecimal(*input.MinUnitPerLine))
	}

	if input.MaxUnitPerLine != nil {
		sqlbuilder = sqlbuilder.Set("max_unit_per_line", parseNullDecimal(*input.MaxUnitPerLine))
	}

	if input.MinUnitPerTicket != nil {
		sqlbuilder = sqlbuilder.Set("min_unit_per_ticket", parseNullDecimal(*input.MinUnitPerTicket))
	}

	if input.MaxUnitPerTicket != nil {
		sqlbuilder = sqlbuilder.Set("max_unit_per_ticket", parseNullDecimal(*input.MaxUnitPerTicket))
	}

	sqlbuilder = sqlbuilder.Set("allocation", parseNullDecimal(input.Allocation))
	sqlbuilder = sqlbuilder.Set("guarantee", parseNullDecimal(input.Guarantee))
	sqlbuilder = sqlbuilder.Set("carry_in", parseNullDecimal(input.CarryIn))

	if input.ConsolationPrizes != nil {
		totalAllocation := parseNullDecimal(input.Allocation)
		for i := 0; i < len(input.ConsolationPrizes); i++ {
			dec := parseNullDecimal(input.ConsolationPrizes[i].Allocation)
			if dec.Valid {
				totalAllocation.Decimal = totalAllocation.Decimal.Add(dec.Decimal)
			} else {
				return &pool, fmt.Errorf("Invalid Allocation Value %s", input.ConsolationPrizes[i].Allocation)
			}
		}

		if !totalAllocation.Decimal.Equal(decimal.NewFromFloat(1.0)) {
			return &pool, fmt.Errorf("Total of Allocations must Equal 1.0, got: %s", totalAllocation.Decimal)
		}
		sqlbuilder = sqlbuilder.Set("consolations", input.ConsolationPrizes)
	}

	sqlbuilder = sqlbuilder.Suffix("RETURNING *")

	sql, args, _ := sqlbuilder.ToSql()
	_, err = r.DB.Query(&pool, sql, args...)

	if err == nil {
		audit.CreateAudit(r.DB, pool.ID, repository.NewSQLCompatUUIDFromStr(userID), models.EditActionUpdate, pool)
	}

	return &pool, err
}

func (r *mutationResolver) DeletePool(ctx context.Context, id string) (*models.Pool, error) {
	_, err := auth.Authorize(ctx, []models.AccessRole{
		models.AccessRoleSuperAdmin,
		models.AccessRoleAdmin,
	})
	if err != nil {
		return &models.Pool{}, err
	}
	panic("not implemented")
}

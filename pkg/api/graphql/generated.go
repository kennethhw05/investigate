// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graphql

import (
	"bytes"
	"context"
	"errors"
	"strconv"
	"sync"
	"sync/atomic"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/vektah/gqlparser"
	"github.com/vektah/gqlparser/ast"
	"gitlab.com/siimpl/esp-betting/betting-feed/pkg/models"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Audit() AuditResolver
	Competitor() CompetitorResolver
	ConsolationPrize() ConsolationPrizeResolver
	Event() EventResolver
	Leg() LegResolver
	Match() MatchResolver
	Mutation() MutationResolver
	OverUnderDefault() OverUnderDefaultResolver
	Player() PlayerResolver
	Pool() PoolResolver
	PoolDefault() PoolDefaultResolver
	Query() QueryResolver
	User() UserResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	Audit struct {
		Content    func(childComplexity int) int
		EditAction func(childComplexity int) int
		ID         func(childComplexity int) int
		TargetID   func(childComplexity int) int
		TargetType func(childComplexity int) int
		Time       func(childComplexity int) int
		User       func(childComplexity int) int
	}

	Competitor struct {
		ExternalID func(childComplexity int) int
		ID         func(childComplexity int) int
		Logo       func(childComplexity int) int
		Matches    func(childComplexity int) int
		Name       func(childComplexity int) int
	}

	ConsolationPrize struct {
		Allocation func(childComplexity int) int
		CarryIn    func(childComplexity int) int
		Guarantee  func(childComplexity int) int
	}

	Event struct {
		EndDate         func(childComplexity int) int
		ExternalID      func(childComplexity int) int
		Game            func(childComplexity int) int
		ID              func(childComplexity int) int
		IsActive        func(childComplexity int) int
		IsAutogenerated func(childComplexity int) int
		Logo            func(childComplexity int) int
		Matches         func(childComplexity int) int
		Name            func(childComplexity int) int
		StartDate       func(childComplexity int) int
		Type            func(childComplexity int) int
	}

	Leg struct {
		ID           func(childComplexity int) int
		LastSyncTime func(childComplexity int) int
		MatchID      func(childComplexity int) int
		PoolID       func(childComplexity int) int
		Threshold    func(childComplexity int) int
	}

	ListMetadata struct {
		Count func(childComplexity int) int
	}

	Match struct {
		Competitors          func(childComplexity int) int
		Description          func(childComplexity int) int
		EventID              func(childComplexity int) int
		EventStage           func(childComplexity int) int
		ExternalID           func(childComplexity int) int
		Format               func(childComplexity int) int
		History              func(childComplexity int) int
		ID                   func(childComplexity int) int
		InternalStatus       func(childComplexity int) int
		IsActive             func(childComplexity int) int
		IsAutogenerated      func(childComplexity int) int
		Name                 func(childComplexity int) int
		StartTime            func(childComplexity int) int
		Statistics           func(childComplexity int) int
		TeamOuScores         func(childComplexity int) int
		TeamScores           func(childComplexity int) int
		TeamWinProbabilities func(childComplexity int) int
	}

	Mutation struct {
		CreateCompetitor       func(childComplexity int, input models.CreateCompetitorInput) int
		CreateEvent            func(childComplexity int, input models.CreateEventInput) int
		CreateLeg              func(childComplexity int, input models.CreateLegInput) int
		CreateMatch            func(childComplexity int, input models.CreateMatchInput) int
		CreateOverUnderDefault func(childComplexity int, input models.CreateOverUnderDefaultInput) int
		CreatePlayer           func(childComplexity int, input models.CreatePlayerInput) int
		CreatePool             func(childComplexity int, input models.CreatePoolInput) int
		CreatePoolDefault      func(childComplexity int, input models.CreatePoolDefaultInput) int
		CreateSession          func(childComplexity int, input models.AuthInput) int
		CreateUser             func(childComplexity int, input models.CreateUserInput) int
		DeleteCompetitor       func(childComplexity int, id string) int
		DeleteEvent            func(childComplexity int, id string) int
		DeleteLeg              func(childComplexity int, id string) int
		DeleteMatch            func(childComplexity int, id string) int
		DeleteOverUnderDefault func(childComplexity int, id string) int
		DeletePlayer           func(childComplexity int, id string) int
		DeletePool             func(childComplexity int, id string) int
		DeletePoolDefault      func(childComplexity int, id string) int
		UpdateCompetitor       func(childComplexity int, input models.UpdateCompetitorInput) int
		UpdateEvent            func(childComplexity int, input models.UpdateEventInput) int
		UpdateLeg              func(childComplexity int, input models.UpdateLegInput) int
		UpdateMatch            func(childComplexity int, input models.UpdateMatchInput) int
		UpdateOverUnderDefault func(childComplexity int, input models.UpdateOverUnderDefaultInput) int
		UpdatePlayer           func(childComplexity int, input models.UpdatePlayerInput) int
		UpdatePool             func(childComplexity int, input models.UpdatePoolInput) int
		UpdatePoolDefault      func(childComplexity int, input models.UpdatePoolDefaultInput) int
		UpdateUser             func(childComplexity int, input models.UpdateUserInput) int
	}

	OverUnderDefault struct {
		EvenThreshold    func(childComplexity int) int
		FavoredThreshold func(childComplexity int) int
		Game             func(childComplexity int) int
		ID               func(childComplexity int) int
		MatchFormat      func(childComplexity int) int
		Note             func(childComplexity int) int
	}

	Player struct {
		ExternalID func(childComplexity int) int
		ID         func(childComplexity int) int
		Name       func(childComplexity int) int
		Nickname   func(childComplexity int) int
		TeamID     func(childComplexity int) int
	}

	Pool struct {
		Allocation           func(childComplexity int) int
		CarryIn              func(childComplexity int) int
		ConsolationPrizes    func(childComplexity int) int
		Currency             func(childComplexity int) int
		Game                 func(childComplexity int) int
		Guarantee            func(childComplexity int) int
		ID                   func(childComplexity int) int
		IsActive             func(childComplexity int) int
		IsAutogenerated      func(childComplexity int) int
		LastSyncTime         func(childComplexity int) int
		Legs                 func(childComplexity int) int
		MaxUnitPerLine       func(childComplexity int) int
		MaxUnitPerTicket     func(childComplexity int) int
		MinUnitPerLine       func(childComplexity int) int
		MinUnitPerTicket     func(childComplexity int) int
		Name                 func(childComplexity int) int
		Note                 func(childComplexity int) int
		SyncedColossusStatus func(childComplexity int) int
		Type                 func(childComplexity int) int
		UnitValue            func(childComplexity int) int
	}

	PoolDefault struct {
		Allocation       func(childComplexity int) int
		CarryIn          func(childComplexity int) int
		Currency         func(childComplexity int) int
		Game             func(childComplexity int) int
		Guarantee        func(childComplexity int) int
		ID               func(childComplexity int) int
		LegCount         func(childComplexity int) int
		MaxUnitPerLine   func(childComplexity int) int
		MaxUnitPerTicket func(childComplexity int) int
		MinUnitPerLine   func(childComplexity int) int
		MinUnitPerTicket func(childComplexity int) int
		Note             func(childComplexity int) int
		Type             func(childComplexity int) int
		UnitValue        func(childComplexity int) int
	}

	Query struct {
		AllAudits                 func(childComplexity int, filter *models.AuditFilter, page *int, perPage *int, sortField *string, sortOrder *string) int
		AllCompetitors            func(childComplexity int, filter *models.CompetitorFilter, page *int, perPage *int, sortField *string, sortOrder *string) int
		AllEvents                 func(childComplexity int, filter *models.EventFilter, page *int, perPage *int, sortField *string, sortOrder *string) int
		AllLegs                   func(childComplexity int, filter *models.LegFilter, page *int, perPage *int, sortField *string, sortOrder *string) int
		AllMatches                func(childComplexity int, filter *models.MatchFilter, page *int, perPage *int, sortField *string, sortOrder *string) int
		AllOverUnderDefaults      func(childComplexity int, filter *models.OverUnderDefaultFilter, page *int, perPage *int, sortField *string, sortOrder *string) int
		AllPlayers                func(childComplexity int, filter *models.PlayerFilter, page *int, perPage *int, sortField *string, sortOrder *string) int
		AllPoolDefaults           func(childComplexity int, filter *models.PoolDefaultFilter, page *int, perPage *int, sortField *string, sortOrder *string) int
		AllPools                  func(childComplexity int, filter *models.PoolFilter, page *int, perPage *int, sortField *string, sortOrder *string) int
		AllUsers                  func(childComplexity int, filter *models.UserFilter, page *int, perPage *int, sortField *string, sortOrder *string) int
		Audit                     func(childComplexity int, id string) int
		Competitor                func(childComplexity int, id string) int
		Event                     func(childComplexity int, id string) int
		Leg                       func(childComplexity int, id string) int
		Match                     func(childComplexity int, id string) int
		OverUnderDefault          func(childComplexity int, id string) int
		Player                    func(childComplexity int, id string) int
		Pool                      func(childComplexity int, id string) int
		PoolDefault               func(childComplexity int, id string) int
		User                      func(childComplexity int, id string) int
		_allAuditsMeta            func(childComplexity int, filter *models.AuditFilter, page *int, perPage *int) int
		_allCompetitorsMeta       func(childComplexity int, filter *models.CompetitorFilter, page *int, perPage *int) int
		_allEventsMeta            func(childComplexity int, filter *models.EventFilter, page *int, perPage *int) int
		_allLegsMeta              func(childComplexity int, filter *models.LegFilter, page *int, perPage *int) int
		_allMatchesMeta           func(childComplexity int, filter *models.MatchFilter, page *int, perPage *int) int
		_allOverUnderDefaultsMeta func(childComplexity int, filter *models.OverUnderDefaultFilter, page *int, perPage *int) int
		_allPlayersMeta           func(childComplexity int, filter *models.PlayerFilter, page *int, perPage *int) int
		_allPoolDefaultsMeta      func(childComplexity int, filter *models.PoolDefaultFilter, page *int, perPage *int) int
		_allPoolsMeta             func(childComplexity int, filter *models.PoolFilter, page *int, perPage *int) int
		_allUsersMeta             func(childComplexity int, filter *models.UserFilter, page *int, perPage *int) int
	}

	Session struct {
		Token func(childComplexity int) int
	}

	TeamProbabilities struct {
		Probability func(childComplexity int) int
		TeamID      func(childComplexity int) int
	}

	TeamScore struct {
		Score  func(childComplexity int) int
		TeamID func(childComplexity int) int
	}

	TeamScores struct {
		Score  func(childComplexity int) int
		TeamID func(childComplexity int) int
	}

	TeamWinProbability struct {
		Probability func(childComplexity int) int
		TeamID      func(childComplexity int) int
	}

	User struct {
		AccessRole func(childComplexity int) int
		Email      func(childComplexity int) int
		ID         func(childComplexity int) int
		Token      func(childComplexity int) int
	}
}

type AuditResolver interface {
	ID(ctx context.Context, obj *models.Audit) (string, error)

	TargetID(ctx context.Context, obj *models.Audit) (string, error)

	User(ctx context.Context, obj *models.Audit) (*models.User, error)
}
type CompetitorResolver interface {
	ID(ctx context.Context, obj *models.Competitor) (string, error)
}
type ConsolationPrizeResolver interface {
	Guarantee(ctx context.Context, obj *models.ConsolationPrize) (string, error)
	CarryIn(ctx context.Context, obj *models.ConsolationPrize) (string, error)
	Allocation(ctx context.Context, obj *models.ConsolationPrize) (string, error)
}
type EventResolver interface {
	ID(ctx context.Context, obj *models.Event) (string, error)
}
type LegResolver interface {
	ID(ctx context.Context, obj *models.Leg) (string, error)

	Threshold(ctx context.Context, obj *models.Leg) (string, error)
	MatchID(ctx context.Context, obj *models.Leg) (string, error)
	PoolID(ctx context.Context, obj *models.Leg) (string, error)
}
type MatchResolver interface {
	ID(ctx context.Context, obj *models.Match) (string, error)
	EventID(ctx context.Context, obj *models.Match) (string, error)

	Statistics(ctx context.Context, obj *models.Match) (string, error)
	TeamScores(ctx context.Context, obj *models.Match) ([]*models.TeamScore, error)
	TeamOuScores(ctx context.Context, obj *models.Match) ([]*models.TeamScore, error)
	TeamWinProbabilities(ctx context.Context, obj *models.Match) ([]*models.TeamWinProbability, error)

	History(ctx context.Context, obj *models.Match) ([]*models.Audit, error)
}
type MutationResolver interface {
	CreateUser(ctx context.Context, input models.CreateUserInput) (*models.User, error)
	UpdateUser(ctx context.Context, input models.UpdateUserInput) (*models.User, error)
	CreateSession(ctx context.Context, input models.AuthInput) (*models.Session, error)
	CreateEvent(ctx context.Context, input models.CreateEventInput) (*models.Event, error)
	UpdateEvent(ctx context.Context, input models.UpdateEventInput) (*models.Event, error)
	DeleteEvent(ctx context.Context, id string) (*models.Event, error)
	CreateMatch(ctx context.Context, input models.CreateMatchInput) (*models.Match, error)
	UpdateMatch(ctx context.Context, input models.UpdateMatchInput) (*models.Match, error)
	DeleteMatch(ctx context.Context, id string) (*models.Match, error)
	CreateCompetitor(ctx context.Context, input models.CreateCompetitorInput) (*models.Competitor, error)
	UpdateCompetitor(ctx context.Context, input models.UpdateCompetitorInput) (*models.Competitor, error)
	DeleteCompetitor(ctx context.Context, id string) (*models.Competitor, error)
	CreatePlayer(ctx context.Context, input models.CreatePlayerInput) (*models.Player, error)
	UpdatePlayer(ctx context.Context, input models.UpdatePlayerInput) (*models.Player, error)
	DeletePlayer(ctx context.Context, id string) (*models.Player, error)
	CreatePool(ctx context.Context, input models.CreatePoolInput) (*models.Pool, error)
	UpdatePool(ctx context.Context, input models.UpdatePoolInput) (*models.Pool, error)
	DeletePool(ctx context.Context, id string) (*models.Pool, error)
	CreatePoolDefault(ctx context.Context, input models.CreatePoolDefaultInput) (*models.PoolDefault, error)
	UpdatePoolDefault(ctx context.Context, input models.UpdatePoolDefaultInput) (*models.PoolDefault, error)
	DeletePoolDefault(ctx context.Context, id string) (*models.PoolDefault, error)
	CreateLeg(ctx context.Context, input models.CreateLegInput) (*models.Leg, error)
	UpdateLeg(ctx context.Context, input models.UpdateLegInput) (*models.Leg, error)
	DeleteLeg(ctx context.Context, id string) (*models.Leg, error)
	CreateOverUnderDefault(ctx context.Context, input models.CreateOverUnderDefaultInput) (*models.OverUnderDefault, error)
	UpdateOverUnderDefault(ctx context.Context, input models.UpdateOverUnderDefaultInput) (*models.OverUnderDefault, error)
	DeleteOverUnderDefault(ctx context.Context, id string) (*models.OverUnderDefault, error)
}
type OverUnderDefaultResolver interface {
	ID(ctx context.Context, obj *models.OverUnderDefault) (string, error)

	EvenThreshold(ctx context.Context, obj *models.OverUnderDefault) (string, error)
	FavoredThreshold(ctx context.Context, obj *models.OverUnderDefault) (string, error)
}
type PlayerResolver interface {
	ID(ctx context.Context, obj *models.Player) (string, error)

	TeamID(ctx context.Context, obj *models.Player) (string, error)
}
type PoolResolver interface {
	ID(ctx context.Context, obj *models.Pool) (string, error)

	Guarantee(ctx context.Context, obj *models.Pool) (string, error)
	CarryIn(ctx context.Context, obj *models.Pool) (string, error)
	Allocation(ctx context.Context, obj *models.Pool) (string, error)

	UnitValue(ctx context.Context, obj *models.Pool) (string, error)
	MinUnitPerLine(ctx context.Context, obj *models.Pool) (string, error)
	MaxUnitPerLine(ctx context.Context, obj *models.Pool) (string, error)
	MinUnitPerTicket(ctx context.Context, obj *models.Pool) (string, error)
	MaxUnitPerTicket(ctx context.Context, obj *models.Pool) (string, error)

	ConsolationPrizes(ctx context.Context, obj *models.Pool) ([]*models.ConsolationPrize, error)
}
type PoolDefaultResolver interface {
	ID(ctx context.Context, obj *models.PoolDefault) (string, error)
	LegCount(ctx context.Context, obj *models.PoolDefault) (string, error)

	Guarantee(ctx context.Context, obj *models.PoolDefault) (string, error)
	CarryIn(ctx context.Context, obj *models.PoolDefault) (string, error)
	Allocation(ctx context.Context, obj *models.PoolDefault) (string, error)
	UnitValue(ctx context.Context, obj *models.PoolDefault) (string, error)
	MinUnitPerLine(ctx context.Context, obj *models.PoolDefault) (string, error)
	MaxUnitPerLine(ctx context.Context, obj *models.PoolDefault) (string, error)
	MinUnitPerTicket(ctx context.Context, obj *models.PoolDefault) (string, error)
	MaxUnitPerTicket(ctx context.Context, obj *models.PoolDefault) (string, error)
}
type QueryResolver interface {
	Event(ctx context.Context, id string) (*models.Event, error)
	AllEvents(ctx context.Context, filter *models.EventFilter, page *int, perPage *int, sortField *string, sortOrder *string) ([]*models.Event, error)
	_allEventsMeta(ctx context.Context, filter *models.EventFilter, page *int, perPage *int) (*models.ListMetadata, error)
	Pool(ctx context.Context, id string) (*models.Pool, error)
	AllPools(ctx context.Context, filter *models.PoolFilter, page *int, perPage *int, sortField *string, sortOrder *string) ([]*models.Pool, error)
	_allPoolsMeta(ctx context.Context, filter *models.PoolFilter, page *int, perPage *int) (*models.ListMetadata, error)
	PoolDefault(ctx context.Context, id string) (*models.PoolDefault, error)
	AllPoolDefaults(ctx context.Context, filter *models.PoolDefaultFilter, page *int, perPage *int, sortField *string, sortOrder *string) ([]*models.PoolDefault, error)
	_allPoolDefaultsMeta(ctx context.Context, filter *models.PoolDefaultFilter, page *int, perPage *int) (*models.ListMetadata, error)
	Leg(ctx context.Context, id string) (*models.Leg, error)
	AllLegs(ctx context.Context, filter *models.LegFilter, page *int, perPage *int, sortField *string, sortOrder *string) ([]*models.Leg, error)
	_allLegsMeta(ctx context.Context, filter *models.LegFilter, page *int, perPage *int) (*models.ListMetadata, error)
	Match(ctx context.Context, id string) (*models.Match, error)
	AllMatches(ctx context.Context, filter *models.MatchFilter, page *int, perPage *int, sortField *string, sortOrder *string) ([]*models.Match, error)
	_allMatchesMeta(ctx context.Context, filter *models.MatchFilter, page *int, perPage *int) (*models.ListMetadata, error)
	Competitor(ctx context.Context, id string) (*models.Competitor, error)
	AllCompetitors(ctx context.Context, filter *models.CompetitorFilter, page *int, perPage *int, sortField *string, sortOrder *string) ([]*models.Competitor, error)
	_allCompetitorsMeta(ctx context.Context, filter *models.CompetitorFilter, page *int, perPage *int) (*models.ListMetadata, error)
	Player(ctx context.Context, id string) (*models.Player, error)
	AllPlayers(ctx context.Context, filter *models.PlayerFilter, page *int, perPage *int, sortField *string, sortOrder *string) ([]*models.Player, error)
	_allPlayersMeta(ctx context.Context, filter *models.PlayerFilter, page *int, perPage *int) (*models.ListMetadata, error)
	User(ctx context.Context, id string) (*models.User, error)
	AllUsers(ctx context.Context, filter *models.UserFilter, page *int, perPage *int, sortField *string, sortOrder *string) ([]*models.User, error)
	_allUsersMeta(ctx context.Context, filter *models.UserFilter, page *int, perPage *int) (*models.ListMetadata, error)
	Audit(ctx context.Context, id string) (*models.Audit, error)
	AllAudits(ctx context.Context, filter *models.AuditFilter, page *int, perPage *int, sortField *string, sortOrder *string) ([]*models.Audit, error)
	_allAuditsMeta(ctx context.Context, filter *models.AuditFilter, page *int, perPage *int) (*models.ListMetadata, error)
	OverUnderDefault(ctx context.Context, id string) (*models.OverUnderDefault, error)
	AllOverUnderDefaults(ctx context.Context, filter *models.OverUnderDefaultFilter, page *int, perPage *int, sortField *string, sortOrder *string) ([]*models.OverUnderDefault, error)
	_allOverUnderDefaultsMeta(ctx context.Context, filter *models.OverUnderDefaultFilter, page *int, perPage *int) (*models.ListMetadata, error)
}
type UserResolver interface {
	ID(ctx context.Context, obj *models.User) (string, error)
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec
	switch typeName + "." + field {

	case "Audit.content":
		if e.complexity.Audit.Content == nil {
			break
		}

		return e.complexity.Audit.Content(childComplexity), true

	case "Audit.editAction":
		if e.complexity.Audit.EditAction == nil {
			break
		}

		return e.complexity.Audit.EditAction(childComplexity), true

	case "Audit.id":
		if e.complexity.Audit.ID == nil {
			break
		}

		return e.complexity.Audit.ID(childComplexity), true

	case "Audit.targetId":
		if e.complexity.Audit.TargetID == nil {
			break
		}

		return e.complexity.Audit.TargetID(childComplexity), true

	case "Audit.targetType":
		if e.complexity.Audit.TargetType == nil {
			break
		}

		return e.complexity.Audit.TargetType(childComplexity), true

	case "Audit.time":
		if e.complexity.Audit.Time == nil {
			break
		}

		return e.complexity.Audit.Time(childComplexity), true

	case "Audit.user":
		if e.complexity.Audit.User == nil {
			break
		}

		return e.complexity.Audit.User(childComplexity), true

	case "Competitor.externalId":
		if e.complexity.Competitor.ExternalID == nil {
			break
		}

		return e.complexity.Competitor.ExternalID(childComplexity), true

	case "Competitor.id":
		if e.complexity.Competitor.ID == nil {
			break
		}

		return e.complexity.Competitor.ID(childComplexity), true

	case "Competitor.logo":
		if e.complexity.Competitor.Logo == nil {
			break
		}

		return e.complexity.Competitor.Logo(childComplexity), true

	case "Competitor.matches":
		if e.complexity.Competitor.Matches == nil {
			break
		}

		return e.complexity.Competitor.Matches(childComplexity), true

	case "Competitor.name":
		if e.complexity.Competitor.Name == nil {
			break
		}

		return e.complexity.Competitor.Name(childComplexity), true

	case "ConsolationPrize.allocation":
		if e.complexity.ConsolationPrize.Allocation == nil {
			break
		}

		return e.complexity.ConsolationPrize.Allocation(childComplexity), true

	case "ConsolationPrize.carryIn":
		if e.complexity.ConsolationPrize.CarryIn == nil {
			break
		}

		return e.complexity.ConsolationPrize.CarryIn(childComplexity), true

	case "ConsolationPrize.guarantee":
		if e.complexity.ConsolationPrize.Guarantee == nil {
			break
		}

		return e.complexity.ConsolationPrize.Guarantee(childComplexity), true

	case "Event.endDate":
		if e.complexity.Event.EndDate == nil {
			break
		}

		return e.complexity.Event.EndDate(childComplexity), true

	case "Event.externalId":
		if e.complexity.Event.ExternalID == nil {
			break
		}

		return e.complexity.Event.ExternalID(childComplexity), true

	case "Event.game":
		if e.complexity.Event.Game == nil {
			break
		}

		return e.complexity.Event.Game(childComplexity), true

	case "Event.id":
		if e.complexity.Event.ID == nil {
			break
		}

		return e.complexity.Event.ID(childComplexity), true

	case "Event.isActive":
		if e.complexity.Event.IsActive == nil {
			break
		}

		return e.complexity.Event.IsActive(childComplexity), true

	case "Event.isAutogenerated":
		if e.complexity.Event.IsAutogenerated == nil {
			break
		}

		return e.complexity.Event.IsAutogenerated(childComplexity), true

	case "Event.logo":
		if e.complexity.Event.Logo == nil {
			break
		}

		return e.complexity.Event.Logo(childComplexity), true

	case "Event.matches":
		if e.complexity.Event.Matches == nil {
			break
		}

		return e.complexity.Event.Matches(childComplexity), true

	case "Event.name":
		if e.complexity.Event.Name == nil {
			break
		}

		return e.complexity.Event.Name(childComplexity), true

	case "Event.startDate":
		if e.complexity.Event.StartDate == nil {
			break
		}

		return e.complexity.Event.StartDate(childComplexity), true

	case "Event.type":
		if e.complexity.Event.Type == nil {
			break
		}

		return e.complexity.Event.Type(childComplexity), true

	case "Leg.id":
		if e.complexity.Leg.ID == nil {
			break
		}

		return e.complexity.Leg.ID(childComplexity), true

	case "Leg.lastSyncTime":
		if e.complexity.Leg.LastSyncTime == nil {
			break
		}

		return e.complexity.Leg.LastSyncTime(childComplexity), true

	case "Leg.matchId":
		if e.complexity.Leg.MatchID == nil {
			break
		}

		return e.complexity.Leg.MatchID(childComplexity), true

	case "Leg.poolId":
		if e.complexity.Leg.PoolID == nil {
			break
		}

		return e.complexity.Leg.PoolID(childComplexity), true

	case "Leg.threshold":
		if e.complexity.Leg.Threshold == nil {
			break
		}

		return e.complexity.Leg.Threshold(childComplexity), true

	case "ListMetadata.count":
		if e.complexity.ListMetadata.Count == nil {
			break
		}

		return e.complexity.ListMetadata.Count(childComplexity), true

	case "Match.competitors":
		if e.complexity.Match.Competitors == nil {
			break
		}

		return e.complexity.Match.Competitors(childComplexity), true

	case "Match.description":
		if e.complexity.Match.Description == nil {
			break
		}

		return e.complexity.Match.Description(childComplexity), true

	case "Match.eventId":
		if e.complexity.Match.EventID == nil {
			break
		}

		return e.complexity.Match.EventID(childComplexity), true

	case "Match.eventStage":
		if e.complexity.Match.EventStage == nil {
			break
		}

		return e.complexity.Match.EventStage(childComplexity), true

	case "Match.externalId":
		if e.complexity.Match.ExternalID == nil {
			break
		}

		return e.complexity.Match.ExternalID(childComplexity), true

	case "Match.format":
		if e.complexity.Match.Format == nil {
			break
		}

		return e.complexity.Match.Format(childComplexity), true

	case "Match.history":
		if e.complexity.Match.History == nil {
			break
		}

		return e.complexity.Match.History(childComplexity), true

	case "Match.id":
		if e.complexity.Match.ID == nil {
			break
		}

		return e.complexity.Match.ID(childComplexity), true

	case "Match.internalStatus":
		if e.complexity.Match.InternalStatus == nil {
			break
		}

		return e.complexity.Match.InternalStatus(childComplexity), true

	case "Match.isActive":
		if e.complexity.Match.IsActive == nil {
			break
		}

		return e.complexity.Match.IsActive(childComplexity), true

	case "Match.isAutogenerated":
		if e.complexity.Match.IsAutogenerated == nil {
			break
		}

		return e.complexity.Match.IsAutogenerated(childComplexity), true

	case "Match.name":
		if e.complexity.Match.Name == nil {
			break
		}

		return e.complexity.Match.Name(childComplexity), true

	case "Match.startTime":
		if e.complexity.Match.StartTime == nil {
			break
		}

		return e.complexity.Match.StartTime(childComplexity), true

	case "Match.statistics":
		if e.complexity.Match.Statistics == nil {
			break
		}

		return e.complexity.Match.Statistics(childComplexity), true

	case "Match.teamOuScores":
		if e.complexity.Match.TeamOuScores == nil {
			break
		}

		return e.complexity.Match.TeamOuScores(childComplexity), true

	case "Match.teamScores":
		if e.complexity.Match.TeamScores == nil {
			break
		}

		return e.complexity.Match.TeamScores(childComplexity), true

	case "Match.teamWinProbabilities":
		if e.complexity.Match.TeamWinProbabilities == nil {
			break
		}

		return e.complexity.Match.TeamWinProbabilities(childComplexity), true

	case "Mutation.createCompetitor":
		if e.complexity.Mutation.CreateCompetitor == nil {
			break
		}

		args, err := ec.field_Mutation_createCompetitor_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateCompetitor(childComplexity, args["input"].(models.CreateCompetitorInput)), true

	case "Mutation.createEvent":
		if e.complexity.Mutation.CreateEvent == nil {
			break
		}

		args, err := ec.field_Mutation_createEvent_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateEvent(childComplexity, args["input"].(models.CreateEventInput)), true

	case "Mutation.createLeg":
		if e.complexity.Mutation.CreateLeg == nil {
			break
		}

		args, err := ec.field_Mutation_createLeg_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateLeg(childComplexity, args["input"].(models.CreateLegInput)), true

	case "Mutation.createMatch":
		if e.complexity.Mutation.CreateMatch == nil {
			break
		}

		args, err := ec.field_Mutation_createMatch_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateMatch(childComplexity, args["input"].(models.CreateMatchInput)), true

	case "Mutation.createOverUnderDefault":
		if e.complexity.Mutation.CreateOverUnderDefault == nil {
			break
		}

		args, err := ec.field_Mutation_createOverUnderDefault_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateOverUnderDefault(childComplexity, args["input"].(models.CreateOverUnderDefaultInput)), true

	case "Mutation.createPlayer":
		if e.complexity.Mutation.CreatePlayer == nil {
			break
		}

		args, err := ec.field_Mutation_createPlayer_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreatePlayer(childComplexity, args["input"].(models.CreatePlayerInput)), true

	case "Mutation.createPool":
		if e.complexity.Mutation.CreatePool == nil {
			break
		}

		args, err := ec.field_Mutation_createPool_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreatePool(childComplexity, args["input"].(models.CreatePoolInput)), true

	case "Mutation.createPoolDefault":
		if e.complexity.Mutation.CreatePoolDefault == nil {
			break
		}

		args, err := ec.field_Mutation_createPoolDefault_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreatePoolDefault(childComplexity, args["input"].(models.CreatePoolDefaultInput)), true

	case "Mutation.createSession":
		if e.complexity.Mutation.CreateSession == nil {
			break
		}

		args, err := ec.field_Mutation_createSession_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateSession(childComplexity, args["input"].(models.AuthInput)), true

	case "Mutation.createUser":
		if e.complexity.Mutation.CreateUser == nil {
			break
		}

		args, err := ec.field_Mutation_createUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateUser(childComplexity, args["input"].(models.CreateUserInput)), true

	case "Mutation.deleteCompetitor":
		if e.complexity.Mutation.DeleteCompetitor == nil {
			break
		}

		args, err := ec.field_Mutation_deleteCompetitor_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteCompetitor(childComplexity, args["id"].(string)), true

	case "Mutation.deleteEvent":
		if e.complexity.Mutation.DeleteEvent == nil {
			break
		}

		args, err := ec.field_Mutation_deleteEvent_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteEvent(childComplexity, args["id"].(string)), true

	case "Mutation.deleteLeg":
		if e.complexity.Mutation.DeleteLeg == nil {
			break
		}

		args, err := ec.field_Mutation_deleteLeg_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteLeg(childComplexity, args["id"].(string)), true

	case "Mutation.deleteMatch":
		if e.complexity.Mutation.DeleteMatch == nil {
			break
		}

		args, err := ec.field_Mutation_deleteMatch_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteMatch(childComplexity, args["id"].(string)), true

	case "Mutation.deleteOverUnderDefault":
		if e.complexity.Mutation.DeleteOverUnderDefault == nil {
			break
		}

		args, err := ec.field_Mutation_deleteOverUnderDefault_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteOverUnderDefault(childComplexity, args["id"].(string)), true

	case "Mutation.deletePlayer":
		if e.complexity.Mutation.DeletePlayer == nil {
			break
		}

		args, err := ec.field_Mutation_deletePlayer_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeletePlayer(childComplexity, args["id"].(string)), true

	case "Mutation.deletePool":
		if e.complexity.Mutation.DeletePool == nil {
			break
		}

		args, err := ec.field_Mutation_deletePool_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeletePool(childComplexity, args["id"].(string)), true

	case "Mutation.deletePoolDefault":
		if e.complexity.Mutation.DeletePoolDefault == nil {
			break
		}

		args, err := ec.field_Mutation_deletePoolDefault_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeletePoolDefault(childComplexity, args["id"].(string)), true

	case "Mutation.updateCompetitor":
		if e.complexity.Mutation.UpdateCompetitor == nil {
			break
		}

		args, err := ec.field_Mutation_updateCompetitor_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateCompetitor(childComplexity, args["input"].(models.UpdateCompetitorInput)), true

	case "Mutation.updateEvent":
		if e.complexity.Mutation.UpdateEvent == nil {
			break
		}

		args, err := ec.field_Mutation_updateEvent_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateEvent(childComplexity, args["input"].(models.UpdateEventInput)), true

	case "Mutation.updateLeg":
		if e.complexity.Mutation.UpdateLeg == nil {
			break
		}

		args, err := ec.field_Mutation_updateLeg_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateLeg(childComplexity, args["input"].(models.UpdateLegInput)), true

	case "Mutation.updateMatch":
		if e.complexity.Mutation.UpdateMatch == nil {
			break
		}

		args, err := ec.field_Mutation_updateMatch_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateMatch(childComplexity, args["input"].(models.UpdateMatchInput)), true

	case "Mutation.updateOverUnderDefault":
		if e.complexity.Mutation.UpdateOverUnderDefault == nil {
			break
		}

		args, err := ec.field_Mutation_updateOverUnderDefault_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateOverUnderDefault(childComplexity, args["input"].(models.UpdateOverUnderDefaultInput)), true

	case "Mutation.updatePlayer":
		if e.complexity.Mutation.UpdatePlayer == nil {
			break
		}

		args, err := ec.field_Mutation_updatePlayer_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdatePlayer(childComplexity, args["input"].(models.UpdatePlayerInput)), true

	case "Mutation.updatePool":
		if e.complexity.Mutation.UpdatePool == nil {
			break
		}

		args, err := ec.field_Mutation_updatePool_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdatePool(childComplexity, args["input"].(models.UpdatePoolInput)), true

	case "Mutation.updatePoolDefault":
		if e.complexity.Mutation.UpdatePoolDefault == nil {
			break
		}

		args, err := ec.field_Mutation_updatePoolDefault_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdatePoolDefault(childComplexity, args["input"].(models.UpdatePoolDefaultInput)), true

	case "Mutation.updateUser":
		if e.complexity.Mutation.UpdateUser == nil {
			break
		}

		args, err := ec.field_Mutation_updateUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateUser(childComplexity, args["input"].(models.UpdateUserInput)), true

	case "OverUnderDefault.evenThreshold":
		if e.complexity.OverUnderDefault.EvenThreshold == nil {
			break
		}

		return e.complexity.OverUnderDefault.EvenThreshold(childComplexity), true

	case "OverUnderDefault.favoredThreshold":
		if e.complexity.OverUnderDefault.FavoredThreshold == nil {
			break
		}

		return e.complexity.OverUnderDefault.FavoredThreshold(childComplexity), true

	case "OverUnderDefault.game":
		if e.complexity.OverUnderDefault.Game == nil {
			break
		}

		return e.complexity.OverUnderDefault.Game(childComplexity), true

	case "OverUnderDefault.id":
		if e.complexity.OverUnderDefault.ID == nil {
			break
		}

		return e.complexity.OverUnderDefault.ID(childComplexity), true

	case "OverUnderDefault.matchFormat":
		if e.complexity.OverUnderDefault.MatchFormat == nil {
			break
		}

		return e.complexity.OverUnderDefault.MatchFormat(childComplexity), true

	case "OverUnderDefault.note":
		if e.complexity.OverUnderDefault.Note == nil {
			break
		}

		return e.complexity.OverUnderDefault.Note(childComplexity), true

	case "Player.externalId":
		if e.complexity.Player.ExternalID == nil {
			break
		}

		return e.complexity.Player.ExternalID(childComplexity), true

	case "Player.id":
		if e.complexity.Player.ID == nil {
			break
		}

		return e.complexity.Player.ID(childComplexity), true

	case "Player.name":
		if e.complexity.Player.Name == nil {
			break
		}

		return e.complexity.Player.Name(childComplexity), true

	case "Player.nickname":
		if e.complexity.Player.Nickname == nil {
			break
		}

		return e.complexity.Player.Nickname(childComplexity), true

	case "Player.teamId":
		if e.complexity.Player.TeamID == nil {
			break
		}

		return e.complexity.Player.TeamID(childComplexity), true

	case "Pool.allocation":
		if e.complexity.Pool.Allocation == nil {
			break
		}

		return e.complexity.Pool.Allocation(childComplexity), true

	case "Pool.carryIn":
		if e.complexity.Pool.CarryIn == nil {
			break
		}

		return e.complexity.Pool.CarryIn(childComplexity), true

	case "Pool.consolationPrizes":
		if e.complexity.Pool.ConsolationPrizes == nil {
			break
		}

		return e.complexity.Pool.ConsolationPrizes(childComplexity), true

	case "Pool.currency":
		if e.complexity.Pool.Currency == nil {
			break
		}

		return e.complexity.Pool.Currency(childComplexity), true

	case "Pool.game":
		if e.complexity.Pool.Game == nil {
			break
		}

		return e.complexity.Pool.Game(childComplexity), true

	case "Pool.guarantee":
		if e.complexity.Pool.Guarantee == nil {
			break
		}

		return e.complexity.Pool.Guarantee(childComplexity), true

	case "Pool.id":
		if e.complexity.Pool.ID == nil {
			break
		}

		return e.complexity.Pool.ID(childComplexity), true

	case "Pool.isActive":
		if e.complexity.Pool.IsActive == nil {
			break
		}

		return e.complexity.Pool.IsActive(childComplexity), true

	case "Pool.isAutogenerated":
		if e.complexity.Pool.IsAutogenerated == nil {
			break
		}

		return e.complexity.Pool.IsAutogenerated(childComplexity), true

	case "Pool.lastSyncTime":
		if e.complexity.Pool.LastSyncTime == nil {
			break
		}

		return e.complexity.Pool.LastSyncTime(childComplexity), true

	case "Pool.legs":
		if e.complexity.Pool.Legs == nil {
			break
		}

		return e.complexity.Pool.Legs(childComplexity), true

	case "Pool.maxUnitPerLine":
		if e.complexity.Pool.MaxUnitPerLine == nil {
			break
		}

		return e.complexity.Pool.MaxUnitPerLine(childComplexity), true

	case "Pool.maxUnitPerTicket":
		if e.complexity.Pool.MaxUnitPerTicket == nil {
			break
		}

		return e.complexity.Pool.MaxUnitPerTicket(childComplexity), true

	case "Pool.minUnitPerLine":
		if e.complexity.Pool.MinUnitPerLine == nil {
			break
		}

		return e.complexity.Pool.MinUnitPerLine(childComplexity), true

	case "Pool.minUnitPerTicket":
		if e.complexity.Pool.MinUnitPerTicket == nil {
			break
		}

		return e.complexity.Pool.MinUnitPerTicket(childComplexity), true

	case "Pool.name":
		if e.complexity.Pool.Name == nil {
			break
		}

		return e.complexity.Pool.Name(childComplexity), true

	case "Pool.note":
		if e.complexity.Pool.Note == nil {
			break
		}

		return e.complexity.Pool.Note(childComplexity), true

	case "Pool.syncedColossusStatus":
		if e.complexity.Pool.SyncedColossusStatus == nil {
			break
		}

		return e.complexity.Pool.SyncedColossusStatus(childComplexity), true

	case "Pool.type":
		if e.complexity.Pool.Type == nil {
			break
		}

		return e.complexity.Pool.Type(childComplexity), true

	case "Pool.unitValue":
		if e.complexity.Pool.UnitValue == nil {
			break
		}

		return e.complexity.Pool.UnitValue(childComplexity), true

	case "PoolDefault.allocation":
		if e.complexity.PoolDefault.Allocation == nil {
			break
		}

		return e.complexity.PoolDefault.Allocation(childComplexity), true

	case "PoolDefault.carryIn":
		if e.complexity.PoolDefault.CarryIn == nil {
			break
		}

		return e.complexity.PoolDefault.CarryIn(childComplexity), true

	case "PoolDefault.currency":
		if e.complexity.PoolDefault.Currency == nil {
			break
		}

		return e.complexity.PoolDefault.Currency(childComplexity), true

	case "PoolDefault.game":
		if e.complexity.PoolDefault.Game == nil {
			break
		}

		return e.complexity.PoolDefault.Game(childComplexity), true

	case "PoolDefault.guarantee":
		if e.complexity.PoolDefault.Guarantee == nil {
			break
		}

		return e.complexity.PoolDefault.Guarantee(childComplexity), true

	case "PoolDefault.id":
		if e.complexity.PoolDefault.ID == nil {
			break
		}

		return e.complexity.PoolDefault.ID(childComplexity), true

	case "PoolDefault.legCount":
		if e.complexity.PoolDefault.LegCount == nil {
			break
		}

		return e.complexity.PoolDefault.LegCount(childComplexity), true

	case "PoolDefault.maxUnitPerLine":
		if e.complexity.PoolDefault.MaxUnitPerLine == nil {
			break
		}

		return e.complexity.PoolDefault.MaxUnitPerLine(childComplexity), true

	case "PoolDefault.maxUnitPerTicket":
		if e.complexity.PoolDefault.MaxUnitPerTicket == nil {
			break
		}

		return e.complexity.PoolDefault.MaxUnitPerTicket(childComplexity), true

	case "PoolDefault.minUnitPerLine":
		if e.complexity.PoolDefault.MinUnitPerLine == nil {
			break
		}

		return e.complexity.PoolDefault.MinUnitPerLine(childComplexity), true

	case "PoolDefault.minUnitPerTicket":
		if e.complexity.PoolDefault.MinUnitPerTicket == nil {
			break
		}

		return e.complexity.PoolDefault.MinUnitPerTicket(childComplexity), true

	case "PoolDefault.note":
		if e.complexity.PoolDefault.Note == nil {
			break
		}

		return e.complexity.PoolDefault.Note(childComplexity), true

	case "PoolDefault.type":
		if e.complexity.PoolDefault.Type == nil {
			break
		}

		return e.complexity.PoolDefault.Type(childComplexity), true

	case "PoolDefault.unitValue":
		if e.complexity.PoolDefault.UnitValue == nil {
			break
		}

		return e.complexity.PoolDefault.UnitValue(childComplexity), true

	case "Query.allAudits":
		if e.complexity.Query.AllAudits == nil {
			break
		}

		args, err := ec.field_Query_allAudits_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AllAudits(childComplexity, args["filter"].(*models.AuditFilter), args["page"].(*int), args["perPage"].(*int), args["sortField"].(*string), args["sortOrder"].(*string)), true

	case "Query.allCompetitors":
		if e.complexity.Query.AllCompetitors == nil {
			break
		}

		args, err := ec.field_Query_allCompetitors_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AllCompetitors(childComplexity, args["filter"].(*models.CompetitorFilter), args["page"].(*int), args["perPage"].(*int), args["sortField"].(*string), args["sortOrder"].(*string)), true

	case "Query.allEvents":
		if e.complexity.Query.AllEvents == nil {
			break
		}

		args, err := ec.field_Query_allEvents_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AllEvents(childComplexity, args["filter"].(*models.EventFilter), args["page"].(*int), args["perPage"].(*int), args["sortField"].(*string), args["sortOrder"].(*string)), true

	case "Query.allLegs":
		if e.complexity.Query.AllLegs == nil {
			break
		}

		args, err := ec.field_Query_allLegs_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AllLegs(childComplexity, args["filter"].(*models.LegFilter), args["page"].(*int), args["perPage"].(*int), args["sortField"].(*string), args["sortOrder"].(*string)), true

	case "Query.allMatches":
		if e.complexity.Query.AllMatches == nil {
			break
		}

		args, err := ec.field_Query_allMatches_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AllMatches(childComplexity, args["filter"].(*models.MatchFilter), args["page"].(*int), args["perPage"].(*int), args["sortField"].(*string), args["sortOrder"].(*string)), true

	case "Query.allOverUnderDefaults":
		if e.complexity.Query.AllOverUnderDefaults == nil {
			break
		}

		args, err := ec.field_Query_allOverUnderDefaults_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AllOverUnderDefaults(childComplexity, args["filter"].(*models.OverUnderDefaultFilter), args["page"].(*int), args["perPage"].(*int), args["sortField"].(*string), args["sortOrder"].(*string)), true

	case "Query.allPlayers":
		if e.complexity.Query.AllPlayers == nil {
			break
		}

		args, err := ec.field_Query_allPlayers_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AllPlayers(childComplexity, args["filter"].(*models.PlayerFilter), args["page"].(*int), args["perPage"].(*int), args["sortField"].(*string), args["sortOrder"].(*string)), true

	case "Query.allPoolDefaults":
		if e.complexity.Query.AllPoolDefaults == nil {
			break
		}

		args, err := ec.field_Query_allPoolDefaults_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AllPoolDefaults(childComplexity, args["filter"].(*models.PoolDefaultFilter), args["page"].(*int), args["perPage"].(*int), args["sortField"].(*string), args["sortOrder"].(*string)), true

	case "Query.allPools":
		if e.complexity.Query.AllPools == nil {
			break
		}

		args, err := ec.field_Query_allPools_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AllPools(childComplexity, args["filter"].(*models.PoolFilter), args["page"].(*int), args["perPage"].(*int), args["sortField"].(*string), args["sortOrder"].(*string)), true

	case "Query.allUsers":
		if e.complexity.Query.AllUsers == nil {
			break
		}

		args, err := ec.field_Query_allUsers_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AllUsers(childComplexity, args["filter"].(*models.UserFilter), args["page"].(*int), args["perPage"].(*int), args["sortField"].(*string), args["sortOrder"].(*string)), true

	case "Query.Audit":
		if e.complexity.Query.Audit == nil {
			break
		}

		args, err := ec.field_Query_Audit_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Audit(childComplexity, args["id"].(string)), true

	case "Query.Competitor":
		if e.complexity.Query.Competitor == nil {
			break
		}

		args, err := ec.field_Query_Competitor_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Competitor(childComplexity, args["id"].(string)), true

	case "Query.Event":
		if e.complexity.Query.Event == nil {
			break
		}

		args, err := ec.field_Query_Event_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Event(childComplexity, args["id"].(string)), true

	case "Query.Leg":
		if e.complexity.Query.Leg == nil {
			break
		}

		args, err := ec.field_Query_Leg_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Leg(childComplexity, args["id"].(string)), true

	case "Query.Match":
		if e.complexity.Query.Match == nil {
			break
		}

		args, err := ec.field_Query_Match_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Match(childComplexity, args["id"].(string)), true

	case "Query.OverUnderDefault":
		if e.complexity.Query.OverUnderDefault == nil {
			break
		}

		args, err := ec.field_Query_OverUnderDefault_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.OverUnderDefault(childComplexity, args["id"].(string)), true

	case "Query.Player":
		if e.complexity.Query.Player == nil {
			break
		}

		args, err := ec.field_Query_Player_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Player(childComplexity, args["id"].(string)), true

	case "Query.Pool":
		if e.complexity.Query.Pool == nil {
			break
		}

		args, err := ec.field_Query_Pool_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Pool(childComplexity, args["id"].(string)), true

	case "Query.PoolDefault":
		if e.complexity.Query.PoolDefault == nil {
			break
		}

		args, err := ec.field_Query_PoolDefault_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.PoolDefault(childComplexity, args["id"].(string)), true

	case "Query.User":
		if e.complexity.Query.User == nil {
			break
		}

		args, err := ec.field_Query_User_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.User(childComplexity, args["id"].(string)), true

	case "Query._allAuditsMeta":
		if e.complexity.Query._allAuditsMeta == nil {
			break
		}

		args, err := ec.field_Query__allAuditsMeta_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query._allAuditsMeta(childComplexity, args["filter"].(*models.AuditFilter), args["page"].(*int), args["perPage"].(*int)), true

	case "Query._allCompetitorsMeta":
		if e.complexity.Query._allCompetitorsMeta == nil {
			break
		}

		args, err := ec.field_Query__allCompetitorsMeta_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query._allCompetitorsMeta(childComplexity, args["filter"].(*models.CompetitorFilter), args["page"].(*int), args["perPage"].(*int)), true

	case "Query._allEventsMeta":
		if e.complexity.Query._allEventsMeta == nil {
			break
		}

		args, err := ec.field_Query__allEventsMeta_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query._allEventsMeta(childComplexity, args["filter"].(*models.EventFilter), args["page"].(*int), args["perPage"].(*int)), true

	case "Query._allLegsMeta":
		if e.complexity.Query._allLegsMeta == nil {
			break
		}

		args, err := ec.field_Query__allLegsMeta_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query._allLegsMeta(childComplexity, args["filter"].(*models.LegFilter), args["page"].(*int), args["perPage"].(*int)), true

	case "Query._allMatchesMeta":
		if e.complexity.Query._allMatchesMeta == nil {
			break
		}

		args, err := ec.field_Query__allMatchesMeta_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query._allMatchesMeta(childComplexity, args["filter"].(*models.MatchFilter), args["page"].(*int), args["perPage"].(*int)), true

	case "Query._allOverUnderDefaultsMeta":
		if e.complexity.Query._allOverUnderDefaultsMeta == nil {
			break
		}

		args, err := ec.field_Query__allOverUnderDefaultsMeta_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query._allOverUnderDefaultsMeta(childComplexity, args["filter"].(*models.OverUnderDefaultFilter), args["page"].(*int), args["perPage"].(*int)), true

	case "Query._allPlayersMeta":
		if e.complexity.Query._allPlayersMeta == nil {
			break
		}

		args, err := ec.field_Query__allPlayersMeta_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query._allPlayersMeta(childComplexity, args["filter"].(*models.PlayerFilter), args["page"].(*int), args["perPage"].(*int)), true

	case "Query._allPoolDefaultsMeta":
		if e.complexity.Query._allPoolDefaultsMeta == nil {
			break
		}

		args, err := ec.field_Query__allPoolDefaultsMeta_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query._allPoolDefaultsMeta(childComplexity, args["filter"].(*models.PoolDefaultFilter), args["page"].(*int), args["perPage"].(*int)), true

	case "Query._allPoolsMeta":
		if e.complexity.Query._allPoolsMeta == nil {
			break
		}

		args, err := ec.field_Query__allPoolsMeta_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query._allPoolsMeta(childComplexity, args["filter"].(*models.PoolFilter), args["page"].(*int), args["perPage"].(*int)), true

	case "Query._allUsersMeta":
		if e.complexity.Query._allUsersMeta == nil {
			break
		}

		args, err := ec.field_Query__allUsersMeta_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query._allUsersMeta(childComplexity, args["filter"].(*models.UserFilter), args["page"].(*int), args["perPage"].(*int)), true

	case "Session.token":
		if e.complexity.Session.Token == nil {
			break
		}

		return e.complexity.Session.Token(childComplexity), true

	case "TeamProbabilities.probability":
		if e.complexity.TeamProbabilities.Probability == nil {
			break
		}

		return e.complexity.TeamProbabilities.Probability(childComplexity), true

	case "TeamProbabilities.teamId":
		if e.complexity.TeamProbabilities.TeamID == nil {
			break
		}

		return e.complexity.TeamProbabilities.TeamID(childComplexity), true

	case "TeamScore.score":
		if e.complexity.TeamScore.Score == nil {
			break
		}

		return e.complexity.TeamScore.Score(childComplexity), true

	case "TeamScore.teamId":
		if e.complexity.TeamScore.TeamID == nil {
			break
		}

		return e.complexity.TeamScore.TeamID(childComplexity), true

	case "TeamScores.score":
		if e.complexity.TeamScores.Score == nil {
			break
		}

		return e.complexity.TeamScores.Score(childComplexity), true

	case "TeamScores.teamId":
		if e.complexity.TeamScores.TeamID == nil {
			break
		}

		return e.complexity.TeamScores.TeamID(childComplexity), true

	case "TeamWinProbability.probability":
		if e.complexity.TeamWinProbability.Probability == nil {
			break
		}

		return e.complexity.TeamWinProbability.Probability(childComplexity), true

	case "TeamWinProbability.teamId":
		if e.complexity.TeamWinProbability.TeamID == nil {
			break
		}

		return e.complexity.TeamWinProbability.TeamID(childComplexity), true

	case "User.accessRole":
		if e.complexity.User.AccessRole == nil {
			break
		}

		return e.complexity.User.AccessRole(childComplexity), true

	case "User.email":
		if e.complexity.User.Email == nil {
			break
		}

		return e.complexity.User.Email(childComplexity), true

	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.token":
		if e.complexity.User.Token == nil {
			break
		}

		return e.complexity.User.Token(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Query(ctx context.Context, op *ast.OperationDefinition) *graphql.Response {
	ec := executionContext{graphql.GetRequestContext(ctx), e}

	buf := ec.RequestMiddleware(ctx, func(ctx context.Context) []byte {
		data := ec._Query(ctx, op.SelectionSet)
		var buf bytes.Buffer
		data.MarshalGQL(&buf)
		return buf.Bytes()
	})

	return &graphql.Response{
		Data:       buf,
		Errors:     ec.Errors,
		Extensions: ec.Extensions,
	}
}

func (e *executableSchema) Mutation(ctx context.Context, op *ast.OperationDefinition) *graphql.Response {
	ec := executionContext{graphql.GetRequestContext(ctx), e}

	buf := ec.RequestMiddleware(ctx, func(ctx context.Context) []byte {
		data := ec._Mutation(ctx, op.SelectionSet)
		var buf bytes.Buffer
		data.MarshalGQL(&buf)
		return buf.Bytes()
	})

	return &graphql.Response{
		Data:       buf,
		Errors:     ec.Errors,
		Extensions: ec.Extensions,
	}
}

func (e *executableSchema) Subscription(ctx context.Context, op *ast.OperationDefinition) func() *graphql.Response {
	return graphql.OneShot(graphql.ErrorResponse(ctx, "subscriptions are not supported"))
}

type executionContext struct {
	*graphql.RequestContext
	*executableSchema
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var parsedSchema = gqlparser.MustLoadSchema(
	&ast.Source{Name: "schema.graphql", Input: `# Time is an RFC3339 timestamp.
scalar Time

# Arbitrary precision decimal
scalar Decimal

# JSON blob for unstructured data
scalar JSON

enum AccessRole {
  SUPER_ADMIN
  ADMIN
  USER
  GUEST_API_ONLY
}

enum ProductType {
  OUTLAST
  BRAWL
  HERO
}

enum EventType {
  TOURNAMENT
}

enum PoolType {
  H2H
  OVER_UNDER
  FANTASY
}

enum PoolStatus {
  NOT_READY
  NEEDS_APPROVAL
  SYNC_ERROR
  APPROVED
  CREATED
  VISIBLE
  TRADING_OPEN
  TRADING_CLOSED
  OFFICIAL
  SETTLED
  ABANDONED
}

enum PoolCurrency {
  STR
}

enum MatchColossusStatus {
  UNKNOWN
  NOT_STARTED
  SYNC_ERROR
  IN_PLAY
  COMPLETED
  OFFICIAL
  ABANDONED
}

enum MatchInternalStatus {
  NOT_READY
  SCHEDULED
  IN_PROGRESS
  FINISHED
  CLOSED
  POSTPONED
  SUSPENDED
  DELAYED
  CANCELLED
  INTERRUPTED
  ABANDONED
  UNKNOWN
}

enum MatchFormat {
  bo2
  bo3
  bo5
  UNKNOWN
}

enum Game {
  COUNTER_STRIKE_GLOBAL_OFFENSIVE
  DOTA_2
  LEAGUE_OF_LEGENDS
  PUBG
  APEX_LEGENDS
  UNDERLORDS
  TEAMFIGHT_TACTICS
  AUTO_CHESS
  STARCRAFT_2
  OVERWATCH
  RAINBOW_SIX_SIEGE
  HEARTHSTONE
  HEROES_OF_THE_STORM
  WARCRAFT_3
  ROCKET_LEAGUE
  CALL_OF_DUTY
  VAIN_GLORY
  HALO
  QUAKE
  KING_OF_GLORY
  WORLD_OF_WARCRAFT
  FIFA
  SMITE
  WORLD_OF_TANKS
  GWENT
  MADDEN
  BATTLEFIELD_5
  NBA2K
  STREET_FIGHTER
  STARCRAFT_BROODWAR
  MAGIC_THE_GATHERING
  UNKNOWN
}

enum EditAction {
  CREATE
  UPDATE
  DELETE
}

type TeamScore {
  teamId: String!
  score: Int!
}
type TeamWinProbability {
  teamId: String!
  probability: Decimal!
}

type Event {
  id: ID!
  name: String!
  externalId: String!
  type: EventType!
  game: Game!
  logo: String!
  startDate: Time
  endDate: Time
  isActive: Boolean!
  isAutogenerated: Boolean!
  matches: [Match!]!
}

type Match {
  id: ID!
  eventId: ID!
  externalId: String!
  name: String!
  description: String!
  startTime: Time
  isActive: Boolean!
  isAutogenerated: Boolean!
  internalStatus: MatchInternalStatus!
  eventStage: String!
  competitors: [Competitor!]!
  statistics: JSON!
  teamScores: [TeamScore!]!
  teamOuScores: [TeamScore!]!
  teamWinProbabilities: [TeamWinProbability!]!
  format: MatchFormat!
  history: [Audit!]
}

type TeamScores {
  teamId: ID!
  score: Int!
}

type TeamProbabilities {
  teamId: ID!
  probability: Float!
}

type Competitor {
  id: ID!
  externalId: String!
  name: String!
  logo: String!
  matches: [Match]
}

type Player {
  id: ID!
  externalId: String!
  name: String!
  nickname: String!
  teamId: ID!
}

type ConsolationPrize {
  guarantee: Decimal!
  carryIn: Decimal!
  allocation: Decimal!
}

type Pool {
  id: ID!
  name: String!
  type: PoolType!
  isActive: Boolean!
  guarantee: Decimal!
  carryIn: Decimal!
  allocation: Decimal!
  note: String!
  unitValue: Decimal!
  minUnitPerLine: Decimal!
  maxUnitPerLine: Decimal!
  minUnitPerTicket: Decimal!
  maxUnitPerTicket: Decimal!
  currency: PoolCurrency!
  isAutogenerated: Boolean!
  lastSyncTime: Time
  syncedColossusStatus: PoolStatus!
  game: Game!
  legs: [Leg!]!
  consolationPrizes: [ConsolationPrize!]
}

type PoolDefault {
  id: ID!
  legCount: Decimal!
  game: Game!
  type: PoolType!
  guarantee: Decimal!
  carryIn: Decimal!
  allocation: Decimal!
  unitValue: Decimal!
  minUnitPerLine: Decimal!
  maxUnitPerLine: Decimal!
  minUnitPerTicket: Decimal!
  maxUnitPerTicket: Decimal!
  currency: PoolCurrency!
  note: String!
}

type Leg {
  id: ID!
  lastSyncTime: Time
  threshold: Decimal!
  matchId: ID!
  poolId: ID!
}

type User {
  id: ID!
  email: String!
  token: String!
  accessRole: AccessRole!
}

type Audit {
  id: ID!
  time: Time!
  targetId: ID!
  targetType: String!
  user: User!
  editAction: EditAction!
  content: String!
}

type Session {
  token: String!
}

type OverUnderDefault {
  id: ID!
  game: Game!
  matchFormat: MatchFormat!
  evenThreshold: Decimal!
  favoredThreshold: Decimal!
  note: String!
}

type ListMetadata {
  count: Int!
}

input EventFilter {
  id: ID
  name: String
  isActive: Boolean
  game: Game
  externalId: String
  ids: [ID!]
}

input UserFilter {
  email: String
  role: AccessRole
  ids: [ID!]
}

input AuditFilter {
  id: ID
  targetId: ID
  targetType: String
  userId: ID
  editAction: EditAction
  ids: [ID!]
}

input LegFilter {
  id: ID
  matchId: ID
  poolId: ID
  ids: [ID!]
}

input PlayerFilter {
  id: ID
  name: String
  nickname: String
  externalId: String
  teamId: ID
  ids: [ID!]
}

input CompetitorFilter {
  id: ID
  name: String
  externalId: String
  match_id: String
  ids: [ID!]
}

input PoolFilter {
  id: ID
  name: String
  isActive: Boolean
  isAutogenerated: Boolean
  poolStatus: PoolStatus
  guarantee: Decimal
  legCount: Decimal
  type: PoolType
  game: Game
  eventId: ID
  lastSyncTimeBefore: Time
  lastSyncTimeAfter: Time
  ids: [ID!]
}

input PoolDefaultFilter {
  type: PoolType
  game: Game
}

input MatchFilter {
  id: ID
  name: String
  externalId: String
  isActive: Boolean
  isAutogenerated: Boolean
  internalStatus: MatchInternalStatus
  format: MatchFormat
  eventStage: String
  eventId: ID
  ids: [ID!]
}

input OverUnderDefaultFilter {
  game: Game
  matchFormat: MatchFormat
  ids: [ID!]
}

input AuthInput {
  email: String!
  password: String!
}

input CreateUserInput {
  email: String!
  password: String!
  role: AccessRole!
}

input UpdateUserInput {
  id: ID!
  email: String
  password: String
  accessRole: AccessRole
}

input CreateEventInput {
  name: String!
  type: EventType!
  game: Game!
  logo: String
  startDate: Time!
  endDate: Time!
  isActive: Boolean
}

input UpdateEventInput {
  id: ID!
  name: String
  type: EventType
  game: Game
  logo: String
  startDate: Time
  endDate: Time
  isActive: Boolean
}

input CreateMatchInput {
  name: String!
  eventId: ID!
  description: String
  startTime: Time!
  isActive: Boolean
  internalStatus: MatchInternalStatus!
  eventStage: String!
  format: MatchFormat!
}

input UpdateTeamScores {
  teamId: String!
  score: Int!
}

input UpdateTeamProbabilities {
  teamId: String!
  probability: Float!
}

input UpdateMatchInput {
  id: ID!
  name: String
  description: String
  startTime: Time
  isActive: Boolean
  internalStatus: MatchInternalStatus
  eventStage: String
  eventId: ID
  teamScores: [UpdateTeamScores!]
  teamOuScores: [UpdateTeamScores!]
  teamWinProbabilities: [UpdateTeamProbabilities!]
  format: MatchFormat
}

input CreateCompetitorInput {
  name: String!
  logo: String
}

input UpdateCompetitorInput {
  id: ID!
  name: String
  logo: String
}

input CreatePlayerInput {
  name: String!
  nickname: String
  teamId: ID!
}

input UpdatePlayerInput {
  id: ID!
  name: String
  nickname: String
  teamId: ID
}

input CreatePoolInput {
  name: String!
  type: PoolType!
  guarantee: Decimal!
  carryIn: Decimal!
  allocation: Decimal!
  game: Game!
  note: String
  unitValue: Decimal!
  currency: PoolCurrency!
  minUnitPerLine: Decimal!
  maxUnitPerLine: Decimal!
  minUnitPerTicket: Decimal!
  maxUnitPerTicket: Decimal!
}

input UpdateConsolationPrize {
  guarantee: Decimal!
  carryIn: Decimal!
  allocation: Decimal!
}

input UpdatePoolInput {
  id: ID!
  name: String
  isActive: Boolean
  guarantee: Decimal!
  carryIn: Decimal!
  allocation: Decimal!
  note: String
  unitValue: Decimal
  minUnitPerLine: Decimal
  maxUnitPerLine: Decimal
  minUnitPerTicket: Decimal
  maxUnitPerTicket: Decimal
  currency: PoolCurrency
  syncedColossusStatus: PoolStatus
  legsIds: [ID!]
  consolationPrizes: [UpdateConsolationPrize!]
}

input CreatePoolDefaultInput {
  legCount: Decimal!
  game: Game!
  type: PoolType!
  guarantee: Decimal!
  carryIn: Decimal!
  allocation: Decimal!
  unitValue: Decimal!
  minUnitPerLine: Decimal!
  maxUnitPerLine: Decimal!
  minUnitPerTicket: Decimal!
  maxUnitPerTicket: Decimal!
  currency: PoolCurrency!
  note: String
}

input UpdatePoolDefaultInput {
  id: ID!
  legCount: Decimal
  game: Game
  type: PoolType
  guarantee: Decimal
  carryIn: Decimal
  allocation: Decimal
  unitValue: Decimal
  minUnitPerLine: Decimal
  maxUnitPerLine: Decimal
  minUnitPerTicket: Decimal
  maxUnitPerTicket: Decimal
  currency: PoolCurrency
  note: String
}

input CreateLegInput {
  matchId: ID!
  poolId: ID!
  threshold: Decimal
}

input UpdateLegInput {
  id: ID!
  threshold: Decimal
  matchId: ID
  poolId: ID
}

input CreateOverUnderDefaultInput {
  game: Game!
  matchFormat: MatchFormat!
  evenThreshold: Decimal!
  favoredThreshold: Decimal!
  note: String
}

input UpdateOverUnderDefaultInput {
  id: ID!
  evenThreshold: Decimal
  favoredThreshold: Decimal
  note: String
}

type Mutation {
  createUser(input: CreateUserInput!): User!
  updateUser(input: UpdateUserInput!): User!

  createSession(input: AuthInput!): Session!

  createEvent(input: CreateEventInput!): Event!
  updateEvent(input: UpdateEventInput!): Event!
  deleteEvent(id: ID!): Event!

  createMatch(input: CreateMatchInput!): Match!
  updateMatch(input: UpdateMatchInput!): Match!
  deleteMatch(id: ID!): Match!

  createCompetitor(input: CreateCompetitorInput!): Competitor!
  updateCompetitor(input: UpdateCompetitorInput!): Competitor!
  deleteCompetitor(id: ID!): Competitor!

  createPlayer(input: CreatePlayerInput!): Player!
  updatePlayer(input: UpdatePlayerInput!): Player!
  deletePlayer(id: ID!): Player!

  createPool(input: CreatePoolInput!): Pool!
  updatePool(input: UpdatePoolInput!): Pool!
  deletePool(id: ID!): Pool!

  createPoolDefault(input: CreatePoolDefaultInput!): PoolDefault!
  updatePoolDefault(input: UpdatePoolDefaultInput!): PoolDefault!
  deletePoolDefault(id: ID!): PoolDefault!

  createLeg(input: CreateLegInput!): Leg!
  updateLeg(input: UpdateLegInput!): Leg!
  deleteLeg(id: ID!): Leg!

  createOverUnderDefault(input: CreateOverUnderDefaultInput!): OverUnderDefault!
  updateOverUnderDefault(input: UpdateOverUnderDefaultInput!): OverUnderDefault!
  deleteOverUnderDefault(id: ID!): OverUnderDefault!
}

type Query {
  Event(id: ID!): Event!
  allEvents(
    filter: EventFilter
    page: Int
    perPage: Int
    sortField: String
    sortOrder: String
  ): [Event!]!
  _allEventsMeta(filter: EventFilter, page: Int, perPage: Int): ListMetadata

  Pool(id: ID!): Pool!
  allPools(
    filter: PoolFilter
    page: Int
    perPage: Int
    sortField: String
    sortOrder: String
  ): [Pool!]!
  _allPoolsMeta(filter: PoolFilter, page: Int, perPage: Int): ListMetadata

  PoolDefault(id: ID!): PoolDefault!
  allPoolDefaults(
    filter: PoolDefaultFilter
    page: Int
    perPage: Int
    sortField: String
    sortOrder: String
  ): [PoolDefault!]!
  _allPoolDefaultsMeta(
    filter: PoolDefaultFilter
    page: Int
    perPage: Int
  ): ListMetadata

  Leg(id: ID!): Leg!
  allLegs(
    filter: LegFilter
    page: Int
    perPage: Int
    sortField: String
    sortOrder: String
  ): [Leg!]!
  _allLegsMeta(filter: LegFilter, page: Int, perPage: Int): ListMetadata

  Match(id: ID!): Match!
  allMatches(
    filter: MatchFilter
    page: Int
    perPage: Int
    sortField: String
    sortOrder: String
  ): [Match!]!
  _allMatchesMeta(filter: MatchFilter, page: Int, perPage: Int): ListMetadata

  Competitor(id: ID!): Competitor!
  allCompetitors(
    filter: CompetitorFilter
    page: Int
    perPage: Int
    sortField: String
    sortOrder: String
  ): [Competitor!]!
  _allCompetitorsMeta(
    filter: CompetitorFilter
    page: Int
    perPage: Int
  ): ListMetadata

  Player(id: ID!): Player!
  allPlayers(
    filter: PlayerFilter
    page: Int
    perPage: Int
    sortField: String
    sortOrder: String
  ): [Player!]!
  _allPlayersMeta(filter: PlayerFilter, page: Int, perPage: Int): ListMetadata

  User(id: ID!): User!
  allUsers(
    filter: UserFilter
    page: Int
    perPage: Int
    sortField: String
    sortOrder: String
  ): [User!]!
  _allUsersMeta(filter: UserFilter, page: Int, perPage: Int): ListMetadata

  Audit(id: ID!): Audit!
  allAudits(
    filter: AuditFilter
    page: Int
    perPage: Int
    sortField: String
    sortOrder: String
  ): [Audit!]!
  _allAuditsMeta(filter: AuditFilter, page: Int, perPage: Int): ListMetadata

  OverUnderDefault(id: ID!): OverUnderDefault!
  allOverUnderDefaults(
    filter: OverUnderDefaultFilter
    page: Int
    perPage: Int
    sortField: String
    sortOrder: String
  ): [OverUnderDefault!]!
  _allOverUnderDefaultsMeta(
    filter: OverUnderDefaultFilter
    page: Int
    perPage: Int
  ): ListMetadata
}
`},
)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) field_Mutation_createCompetitor_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.CreateCompetitorInput
	if tmp, ok := rawArgs["input"]; ok {
		arg0, err = ec.unmarshalNCreateCompetitorInput2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐCreateCompetitorInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createEvent_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.CreateEventInput
	if tmp, ok := rawArgs["input"]; ok {
		arg0, err = ec.unmarshalNCreateEventInput2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐCreateEventInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createLeg_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.CreateLegInput
	if tmp, ok := rawArgs["input"]; ok {
		arg0, err = ec.unmarshalNCreateLegInput2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐCreateLegInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createMatch_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.CreateMatchInput
	if tmp, ok := rawArgs["input"]; ok {
		arg0, err = ec.unmarshalNCreateMatchInput2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐCreateMatchInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createOverUnderDefault_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.CreateOverUnderDefaultInput
	if tmp, ok := rawArgs["input"]; ok {
		arg0, err = ec.unmarshalNCreateOverUnderDefaultInput2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐCreateOverUnderDefaultInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createPlayer_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.CreatePlayerInput
	if tmp, ok := rawArgs["input"]; ok {
		arg0, err = ec.unmarshalNCreatePlayerInput2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐCreatePlayerInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createPoolDefault_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.CreatePoolDefaultInput
	if tmp, ok := rawArgs["input"]; ok {
		arg0, err = ec.unmarshalNCreatePoolDefaultInput2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐCreatePoolDefaultInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createPool_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.CreatePoolInput
	if tmp, ok := rawArgs["input"]; ok {
		arg0, err = ec.unmarshalNCreatePoolInput2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐCreatePoolInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createSession_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.AuthInput
	if tmp, ok := rawArgs["input"]; ok {
		arg0, err = ec.unmarshalNAuthInput2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐAuthInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createUser_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.CreateUserInput
	if tmp, ok := rawArgs["input"]; ok {
		arg0, err = ec.unmarshalNCreateUserInput2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐCreateUserInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteCompetitor_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteEvent_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteLeg_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteMatch_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteOverUnderDefault_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deletePlayer_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deletePoolDefault_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deletePool_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateCompetitor_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.UpdateCompetitorInput
	if tmp, ok := rawArgs["input"]; ok {
		arg0, err = ec.unmarshalNUpdateCompetitorInput2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐUpdateCompetitorInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateEvent_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.UpdateEventInput
	if tmp, ok := rawArgs["input"]; ok {
		arg0, err = ec.unmarshalNUpdateEventInput2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐUpdateEventInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateLeg_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.UpdateLegInput
	if tmp, ok := rawArgs["input"]; ok {
		arg0, err = ec.unmarshalNUpdateLegInput2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐUpdateLegInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateMatch_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.UpdateMatchInput
	if tmp, ok := rawArgs["input"]; ok {
		arg0, err = ec.unmarshalNUpdateMatchInput2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐUpdateMatchInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateOverUnderDefault_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.UpdateOverUnderDefaultInput
	if tmp, ok := rawArgs["input"]; ok {
		arg0, err = ec.unmarshalNUpdateOverUnderDefaultInput2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐUpdateOverUnderDefaultInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updatePlayer_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.UpdatePlayerInput
	if tmp, ok := rawArgs["input"]; ok {
		arg0, err = ec.unmarshalNUpdatePlayerInput2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐUpdatePlayerInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updatePoolDefault_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.UpdatePoolDefaultInput
	if tmp, ok := rawArgs["input"]; ok {
		arg0, err = ec.unmarshalNUpdatePoolDefaultInput2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐUpdatePoolDefaultInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updatePool_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.UpdatePoolInput
	if tmp, ok := rawArgs["input"]; ok {
		arg0, err = ec.unmarshalNUpdatePoolInput2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐUpdatePoolInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateUser_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.UpdateUserInput
	if tmp, ok := rawArgs["input"]; ok {
		arg0, err = ec.unmarshalNUpdateUserInput2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐUpdateUserInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_Audit_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_Competitor_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_Event_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_Leg_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_Match_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_OverUnderDefault_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_Player_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_PoolDefault_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_Pool_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_User_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query__allAuditsMeta_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.AuditFilter
	if tmp, ok := rawArgs["filter"]; ok {
		arg0, err = ec.unmarshalOAuditFilter2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐAuditFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["page"]; ok {
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["page"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["perPage"]; ok {
		arg2, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["perPage"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query__allCompetitorsMeta_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.CompetitorFilter
	if tmp, ok := rawArgs["filter"]; ok {
		arg0, err = ec.unmarshalOCompetitorFilter2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐCompetitorFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["page"]; ok {
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["page"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["perPage"]; ok {
		arg2, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["perPage"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query__allEventsMeta_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.EventFilter
	if tmp, ok := rawArgs["filter"]; ok {
		arg0, err = ec.unmarshalOEventFilter2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐEventFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["page"]; ok {
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["page"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["perPage"]; ok {
		arg2, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["perPage"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query__allLegsMeta_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.LegFilter
	if tmp, ok := rawArgs["filter"]; ok {
		arg0, err = ec.unmarshalOLegFilter2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐLegFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["page"]; ok {
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["page"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["perPage"]; ok {
		arg2, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["perPage"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query__allMatchesMeta_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.MatchFilter
	if tmp, ok := rawArgs["filter"]; ok {
		arg0, err = ec.unmarshalOMatchFilter2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐMatchFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["page"]; ok {
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["page"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["perPage"]; ok {
		arg2, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["perPage"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query__allOverUnderDefaultsMeta_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.OverUnderDefaultFilter
	if tmp, ok := rawArgs["filter"]; ok {
		arg0, err = ec.unmarshalOOverUnderDefaultFilter2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐOverUnderDefaultFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["page"]; ok {
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["page"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["perPage"]; ok {
		arg2, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["perPage"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query__allPlayersMeta_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.PlayerFilter
	if tmp, ok := rawArgs["filter"]; ok {
		arg0, err = ec.unmarshalOPlayerFilter2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐPlayerFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["page"]; ok {
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["page"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["perPage"]; ok {
		arg2, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["perPage"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query__allPoolDefaultsMeta_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.PoolDefaultFilter
	if tmp, ok := rawArgs["filter"]; ok {
		arg0, err = ec.unmarshalOPoolDefaultFilter2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐPoolDefaultFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["page"]; ok {
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["page"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["perPage"]; ok {
		arg2, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["perPage"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query__allPoolsMeta_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.PoolFilter
	if tmp, ok := rawArgs["filter"]; ok {
		arg0, err = ec.unmarshalOPoolFilter2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐPoolFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["page"]; ok {
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["page"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["perPage"]; ok {
		arg2, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["perPage"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query__allUsersMeta_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.UserFilter
	if tmp, ok := rawArgs["filter"]; ok {
		arg0, err = ec.unmarshalOUserFilter2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐUserFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["page"]; ok {
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["page"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["perPage"]; ok {
		arg2, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["perPage"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_allAudits_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.AuditFilter
	if tmp, ok := rawArgs["filter"]; ok {
		arg0, err = ec.unmarshalOAuditFilter2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐAuditFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["page"]; ok {
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["page"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["perPage"]; ok {
		arg2, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["perPage"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["sortField"]; ok {
		arg3, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sortField"] = arg3
	var arg4 *string
	if tmp, ok := rawArgs["sortOrder"]; ok {
		arg4, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sortOrder"] = arg4
	return args, nil
}

func (ec *executionContext) field_Query_allCompetitors_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.CompetitorFilter
	if tmp, ok := rawArgs["filter"]; ok {
		arg0, err = ec.unmarshalOCompetitorFilter2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐCompetitorFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["page"]; ok {
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["page"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["perPage"]; ok {
		arg2, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["perPage"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["sortField"]; ok {
		arg3, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sortField"] = arg3
	var arg4 *string
	if tmp, ok := rawArgs["sortOrder"]; ok {
		arg4, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sortOrder"] = arg4
	return args, nil
}

func (ec *executionContext) field_Query_allEvents_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.EventFilter
	if tmp, ok := rawArgs["filter"]; ok {
		arg0, err = ec.unmarshalOEventFilter2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐEventFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["page"]; ok {
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["page"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["perPage"]; ok {
		arg2, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["perPage"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["sortField"]; ok {
		arg3, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sortField"] = arg3
	var arg4 *string
	if tmp, ok := rawArgs["sortOrder"]; ok {
		arg4, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sortOrder"] = arg4
	return args, nil
}

func (ec *executionContext) field_Query_allLegs_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.LegFilter
	if tmp, ok := rawArgs["filter"]; ok {
		arg0, err = ec.unmarshalOLegFilter2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐLegFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["page"]; ok {
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["page"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["perPage"]; ok {
		arg2, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["perPage"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["sortField"]; ok {
		arg3, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sortField"] = arg3
	var arg4 *string
	if tmp, ok := rawArgs["sortOrder"]; ok {
		arg4, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sortOrder"] = arg4
	return args, nil
}

func (ec *executionContext) field_Query_allMatches_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.MatchFilter
	if tmp, ok := rawArgs["filter"]; ok {
		arg0, err = ec.unmarshalOMatchFilter2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐMatchFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["page"]; ok {
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["page"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["perPage"]; ok {
		arg2, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["perPage"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["sortField"]; ok {
		arg3, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sortField"] = arg3
	var arg4 *string
	if tmp, ok := rawArgs["sortOrder"]; ok {
		arg4, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sortOrder"] = arg4
	return args, nil
}

func (ec *executionContext) field_Query_allOverUnderDefaults_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.OverUnderDefaultFilter
	if tmp, ok := rawArgs["filter"]; ok {
		arg0, err = ec.unmarshalOOverUnderDefaultFilter2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐOverUnderDefaultFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["page"]; ok {
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["page"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["perPage"]; ok {
		arg2, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["perPage"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["sortField"]; ok {
		arg3, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sortField"] = arg3
	var arg4 *string
	if tmp, ok := rawArgs["sortOrder"]; ok {
		arg4, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sortOrder"] = arg4
	return args, nil
}

func (ec *executionContext) field_Query_allPlayers_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.PlayerFilter
	if tmp, ok := rawArgs["filter"]; ok {
		arg0, err = ec.unmarshalOPlayerFilter2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐPlayerFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["page"]; ok {
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["page"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["perPage"]; ok {
		arg2, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["perPage"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["sortField"]; ok {
		arg3, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sortField"] = arg3
	var arg4 *string
	if tmp, ok := rawArgs["sortOrder"]; ok {
		arg4, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sortOrder"] = arg4
	return args, nil
}

func (ec *executionContext) field_Query_allPoolDefaults_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.PoolDefaultFilter
	if tmp, ok := rawArgs["filter"]; ok {
		arg0, err = ec.unmarshalOPoolDefaultFilter2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐPoolDefaultFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["page"]; ok {
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["page"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["perPage"]; ok {
		arg2, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["perPage"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["sortField"]; ok {
		arg3, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sortField"] = arg3
	var arg4 *string
	if tmp, ok := rawArgs["sortOrder"]; ok {
		arg4, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sortOrder"] = arg4
	return args, nil
}

func (ec *executionContext) field_Query_allPools_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.PoolFilter
	if tmp, ok := rawArgs["filter"]; ok {
		arg0, err = ec.unmarshalOPoolFilter2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐPoolFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["page"]; ok {
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["page"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["perPage"]; ok {
		arg2, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["perPage"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["sortField"]; ok {
		arg3, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sortField"] = arg3
	var arg4 *string
	if tmp, ok := rawArgs["sortOrder"]; ok {
		arg4, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sortOrder"] = arg4
	return args, nil
}

func (ec *executionContext) field_Query_allUsers_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.UserFilter
	if tmp, ok := rawArgs["filter"]; ok {
		arg0, err = ec.unmarshalOUserFilter2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐUserFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["page"]; ok {
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["page"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["perPage"]; ok {
		arg2, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["perPage"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["sortField"]; ok {
		arg3, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sortField"] = arg3
	var arg4 *string
	if tmp, ok := rawArgs["sortOrder"]; ok {
		arg4, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sortOrder"] = arg4
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _Audit_id(ctx context.Context, field graphql.CollectedField, obj *models.Audit) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Audit",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Audit().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Audit_time(ctx context.Context, field graphql.CollectedField, obj *models.Audit) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Audit",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Time, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) _Audit_targetId(ctx context.Context, field graphql.CollectedField, obj *models.Audit) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Audit",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Audit().TargetID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Audit_targetType(ctx context.Context, field graphql.CollectedField, obj *models.Audit) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Audit",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TargetType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Audit_user(ctx context.Context, field graphql.CollectedField, obj *models.Audit) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Audit",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Audit().User(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.User)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNUser2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) _Audit_editAction(ctx context.Context, field graphql.CollectedField, obj *models.Audit) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Audit",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EditAction, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.EditAction)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNEditAction2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐEditAction(ctx, field.Selections, res)
}

func (ec *executionContext) _Audit_content(ctx context.Context, field graphql.CollectedField, obj *models.Audit) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Audit",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Content, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Competitor_id(ctx context.Context, field graphql.CollectedField, obj *models.Competitor) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Competitor",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Competitor().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Competitor_externalId(ctx context.Context, field graphql.CollectedField, obj *models.Competitor) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Competitor",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExternalID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Competitor_name(ctx context.Context, field graphql.CollectedField, obj *models.Competitor) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Competitor",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Competitor_logo(ctx context.Context, field graphql.CollectedField, obj *models.Competitor) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Competitor",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Logo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Competitor_matches(ctx context.Context, field graphql.CollectedField, obj *models.Competitor) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Competitor",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Matches, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]models.Match)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOMatch2ᚕgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐMatch(ctx, field.Selections, res)
}

func (ec *executionContext) _ConsolationPrize_guarantee(ctx context.Context, field graphql.CollectedField, obj *models.ConsolationPrize) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ConsolationPrize",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ConsolationPrize().Guarantee(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDecimal2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ConsolationPrize_carryIn(ctx context.Context, field graphql.CollectedField, obj *models.ConsolationPrize) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ConsolationPrize",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ConsolationPrize().CarryIn(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDecimal2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ConsolationPrize_allocation(ctx context.Context, field graphql.CollectedField, obj *models.ConsolationPrize) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ConsolationPrize",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ConsolationPrize().Allocation(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDecimal2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Event_id(ctx context.Context, field graphql.CollectedField, obj *models.Event) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Event",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Event().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Event_name(ctx context.Context, field graphql.CollectedField, obj *models.Event) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Event",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Event_externalId(ctx context.Context, field graphql.CollectedField, obj *models.Event) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Event",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExternalID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Event_type(ctx context.Context, field graphql.CollectedField, obj *models.Event) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Event",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.EventType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNEventType2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐEventType(ctx, field.Selections, res)
}

func (ec *executionContext) _Event_game(ctx context.Context, field graphql.CollectedField, obj *models.Event) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Event",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Game, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.Game)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNGame2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐGame(ctx, field.Selections, res)
}

func (ec *executionContext) _Event_logo(ctx context.Context, field graphql.CollectedField, obj *models.Event) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Event",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Logo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Event_startDate(ctx context.Context, field graphql.CollectedField, obj *models.Event) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Event",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) _Event_endDate(ctx context.Context, field graphql.CollectedField, obj *models.Event) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Event",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) _Event_isActive(ctx context.Context, field graphql.CollectedField, obj *models.Event) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Event",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsActive, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Event_isAutogenerated(ctx context.Context, field graphql.CollectedField, obj *models.Event) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Event",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsAutogenerated, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Event_matches(ctx context.Context, field graphql.CollectedField, obj *models.Event) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Event",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Matches, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]models.Match)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNMatch2ᚕgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐMatch(ctx, field.Selections, res)
}

func (ec *executionContext) _Leg_id(ctx context.Context, field graphql.CollectedField, obj *models.Leg) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Leg",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Leg().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Leg_lastSyncTime(ctx context.Context, field graphql.CollectedField, obj *models.Leg) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Leg",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastSyncTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) _Leg_threshold(ctx context.Context, field graphql.CollectedField, obj *models.Leg) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Leg",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Leg().Threshold(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDecimal2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Leg_matchId(ctx context.Context, field graphql.CollectedField, obj *models.Leg) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Leg",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Leg().MatchID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Leg_poolId(ctx context.Context, field graphql.CollectedField, obj *models.Leg) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Leg",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Leg().PoolID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ListMetadata_count(ctx context.Context, field graphql.CollectedField, obj *models.ListMetadata) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ListMetadata",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _Match_id(ctx context.Context, field graphql.CollectedField, obj *models.Match) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Match",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Match().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Match_eventId(ctx context.Context, field graphql.CollectedField, obj *models.Match) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Match",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Match().EventID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Match_externalId(ctx context.Context, field graphql.CollectedField, obj *models.Match) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Match",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExternalID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Match_name(ctx context.Context, field graphql.CollectedField, obj *models.Match) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Match",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Match_description(ctx context.Context, field graphql.CollectedField, obj *models.Match) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Match",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Match_startTime(ctx context.Context, field graphql.CollectedField, obj *models.Match) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Match",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) _Match_isActive(ctx context.Context, field graphql.CollectedField, obj *models.Match) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Match",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsActive, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Match_isAutogenerated(ctx context.Context, field graphql.CollectedField, obj *models.Match) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Match",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsAutogenerated, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Match_internalStatus(ctx context.Context, field graphql.CollectedField, obj *models.Match) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Match",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InternalStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.MatchInternalStatus)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNMatchInternalStatus2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐMatchInternalStatus(ctx, field.Selections, res)
}

func (ec *executionContext) _Match_eventStage(ctx context.Context, field graphql.CollectedField, obj *models.Match) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Match",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EventStage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Match_competitors(ctx context.Context, field graphql.CollectedField, obj *models.Match) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Match",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Competitors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]models.Competitor)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNCompetitor2ᚕgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐCompetitor(ctx, field.Selections, res)
}

func (ec *executionContext) _Match_statistics(ctx context.Context, field graphql.CollectedField, obj *models.Match) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Match",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Match().Statistics(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNJSON2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Match_teamScores(ctx context.Context, field graphql.CollectedField, obj *models.Match) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Match",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Match().TeamScores(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.TeamScore)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNTeamScore2ᚕᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐTeamScore(ctx, field.Selections, res)
}

func (ec *executionContext) _Match_teamOuScores(ctx context.Context, field graphql.CollectedField, obj *models.Match) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Match",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Match().TeamOuScores(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.TeamScore)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNTeamScore2ᚕᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐTeamScore(ctx, field.Selections, res)
}

func (ec *executionContext) _Match_teamWinProbabilities(ctx context.Context, field graphql.CollectedField, obj *models.Match) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Match",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Match().TeamWinProbabilities(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.TeamWinProbability)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNTeamWinProbability2ᚕᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐTeamWinProbability(ctx, field.Selections, res)
}

func (ec *executionContext) _Match_format(ctx context.Context, field graphql.CollectedField, obj *models.Match) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Match",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Format, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.MatchFormat)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNMatchFormat2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐMatchFormat(ctx, field.Selections, res)
}

func (ec *executionContext) _Match_history(ctx context.Context, field graphql.CollectedField, obj *models.Match) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Match",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Match().History(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.Audit)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOAudit2ᚕᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐAudit(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_createUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_createUser_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateUser(rctx, args["input"].(models.CreateUserInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.User)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNUser2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_updateUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_updateUser_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateUser(rctx, args["input"].(models.UpdateUserInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.User)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNUser2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_createSession(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_createSession_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateSession(rctx, args["input"].(models.AuthInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Session)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNSession2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐSession(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_createEvent(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_createEvent_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateEvent(rctx, args["input"].(models.CreateEventInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Event)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNEvent2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐEvent(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_updateEvent(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_updateEvent_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateEvent(rctx, args["input"].(models.UpdateEventInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Event)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNEvent2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐEvent(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_deleteEvent(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_deleteEvent_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteEvent(rctx, args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Event)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNEvent2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐEvent(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_createMatch(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_createMatch_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateMatch(rctx, args["input"].(models.CreateMatchInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Match)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNMatch2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐMatch(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_updateMatch(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_updateMatch_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateMatch(rctx, args["input"].(models.UpdateMatchInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Match)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNMatch2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐMatch(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_deleteMatch(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_deleteMatch_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteMatch(rctx, args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Match)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNMatch2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐMatch(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_createCompetitor(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_createCompetitor_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateCompetitor(rctx, args["input"].(models.CreateCompetitorInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Competitor)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNCompetitor2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐCompetitor(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_updateCompetitor(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_updateCompetitor_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateCompetitor(rctx, args["input"].(models.UpdateCompetitorInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Competitor)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNCompetitor2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐCompetitor(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_deleteCompetitor(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_deleteCompetitor_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteCompetitor(rctx, args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Competitor)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNCompetitor2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐCompetitor(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_createPlayer(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_createPlayer_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreatePlayer(rctx, args["input"].(models.CreatePlayerInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Player)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNPlayer2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐPlayer(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_updatePlayer(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_updatePlayer_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdatePlayer(rctx, args["input"].(models.UpdatePlayerInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Player)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNPlayer2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐPlayer(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_deletePlayer(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_deletePlayer_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeletePlayer(rctx, args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Player)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNPlayer2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐPlayer(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_createPool(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_createPool_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreatePool(rctx, args["input"].(models.CreatePoolInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Pool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNPool2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐPool(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_updatePool(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_updatePool_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdatePool(rctx, args["input"].(models.UpdatePoolInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Pool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNPool2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐPool(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_deletePool(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_deletePool_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeletePool(rctx, args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Pool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNPool2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐPool(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_createPoolDefault(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_createPoolDefault_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreatePoolDefault(rctx, args["input"].(models.CreatePoolDefaultInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.PoolDefault)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNPoolDefault2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐPoolDefault(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_updatePoolDefault(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_updatePoolDefault_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdatePoolDefault(rctx, args["input"].(models.UpdatePoolDefaultInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.PoolDefault)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNPoolDefault2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐPoolDefault(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_deletePoolDefault(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_deletePoolDefault_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeletePoolDefault(rctx, args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.PoolDefault)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNPoolDefault2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐPoolDefault(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_createLeg(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_createLeg_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateLeg(rctx, args["input"].(models.CreateLegInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Leg)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNLeg2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐLeg(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_updateLeg(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_updateLeg_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateLeg(rctx, args["input"].(models.UpdateLegInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Leg)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNLeg2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐLeg(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_deleteLeg(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_deleteLeg_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteLeg(rctx, args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Leg)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNLeg2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐLeg(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_createOverUnderDefault(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_createOverUnderDefault_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateOverUnderDefault(rctx, args["input"].(models.CreateOverUnderDefaultInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.OverUnderDefault)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNOverUnderDefault2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐOverUnderDefault(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_updateOverUnderDefault(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_updateOverUnderDefault_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateOverUnderDefault(rctx, args["input"].(models.UpdateOverUnderDefaultInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.OverUnderDefault)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNOverUnderDefault2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐOverUnderDefault(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_deleteOverUnderDefault(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_deleteOverUnderDefault_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteOverUnderDefault(rctx, args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.OverUnderDefault)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNOverUnderDefault2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐOverUnderDefault(ctx, field.Selections, res)
}

func (ec *executionContext) _OverUnderDefault_id(ctx context.Context, field graphql.CollectedField, obj *models.OverUnderDefault) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "OverUnderDefault",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.OverUnderDefault().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _OverUnderDefault_game(ctx context.Context, field graphql.CollectedField, obj *models.OverUnderDefault) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "OverUnderDefault",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Game, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.Game)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNGame2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐGame(ctx, field.Selections, res)
}

func (ec *executionContext) _OverUnderDefault_matchFormat(ctx context.Context, field graphql.CollectedField, obj *models.OverUnderDefault) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "OverUnderDefault",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MatchFormat, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.MatchFormat)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNMatchFormat2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐMatchFormat(ctx, field.Selections, res)
}

func (ec *executionContext) _OverUnderDefault_evenThreshold(ctx context.Context, field graphql.CollectedField, obj *models.OverUnderDefault) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "OverUnderDefault",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.OverUnderDefault().EvenThreshold(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDecimal2string(ctx, field.Selections, res)
}

func (ec *executionContext) _OverUnderDefault_favoredThreshold(ctx context.Context, field graphql.CollectedField, obj *models.OverUnderDefault) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "OverUnderDefault",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.OverUnderDefault().FavoredThreshold(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDecimal2string(ctx, field.Selections, res)
}

func (ec *executionContext) _OverUnderDefault_note(ctx context.Context, field graphql.CollectedField, obj *models.OverUnderDefault) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "OverUnderDefault",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Note, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Player_id(ctx context.Context, field graphql.CollectedField, obj *models.Player) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Player",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Player().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Player_externalId(ctx context.Context, field graphql.CollectedField, obj *models.Player) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Player",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExternalID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Player_name(ctx context.Context, field graphql.CollectedField, obj *models.Player) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Player",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Player_nickname(ctx context.Context, field graphql.CollectedField, obj *models.Player) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Player",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nickname, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Player_teamId(ctx context.Context, field graphql.CollectedField, obj *models.Player) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Player",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Player().TeamID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Pool_id(ctx context.Context, field graphql.CollectedField, obj *models.Pool) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Pool",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Pool().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Pool_name(ctx context.Context, field graphql.CollectedField, obj *models.Pool) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Pool",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Pool_type(ctx context.Context, field graphql.CollectedField, obj *models.Pool) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Pool",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.PoolType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNPoolType2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐPoolType(ctx, field.Selections, res)
}

func (ec *executionContext) _Pool_isActive(ctx context.Context, field graphql.CollectedField, obj *models.Pool) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Pool",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsActive, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Pool_guarantee(ctx context.Context, field graphql.CollectedField, obj *models.Pool) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Pool",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Pool().Guarantee(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDecimal2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Pool_carryIn(ctx context.Context, field graphql.CollectedField, obj *models.Pool) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Pool",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Pool().CarryIn(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDecimal2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Pool_allocation(ctx context.Context, field graphql.CollectedField, obj *models.Pool) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Pool",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Pool().Allocation(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDecimal2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Pool_note(ctx context.Context, field graphql.CollectedField, obj *models.Pool) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Pool",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Note, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Pool_unitValue(ctx context.Context, field graphql.CollectedField, obj *models.Pool) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Pool",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Pool().UnitValue(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDecimal2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Pool_minUnitPerLine(ctx context.Context, field graphql.CollectedField, obj *models.Pool) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Pool",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Pool().MinUnitPerLine(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDecimal2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Pool_maxUnitPerLine(ctx context.Context, field graphql.CollectedField, obj *models.Pool) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Pool",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Pool().MaxUnitPerLine(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDecimal2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Pool_minUnitPerTicket(ctx context.Context, field graphql.CollectedField, obj *models.Pool) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Pool",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Pool().MinUnitPerTicket(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDecimal2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Pool_maxUnitPerTicket(ctx context.Context, field graphql.CollectedField, obj *models.Pool) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Pool",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Pool().MaxUnitPerTicket(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDecimal2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Pool_currency(ctx context.Context, field graphql.CollectedField, obj *models.Pool) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Pool",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Currency, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.PoolCurrency)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNPoolCurrency2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐPoolCurrency(ctx, field.Selections, res)
}

func (ec *executionContext) _Pool_isAutogenerated(ctx context.Context, field graphql.CollectedField, obj *models.Pool) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Pool",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsAutogenerated, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Pool_lastSyncTime(ctx context.Context, field graphql.CollectedField, obj *models.Pool) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Pool",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastSyncTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) _Pool_syncedColossusStatus(ctx context.Context, field graphql.CollectedField, obj *models.Pool) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Pool",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SyncedColossusStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.PoolStatus)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNPoolStatus2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐPoolStatus(ctx, field.Selections, res)
}

func (ec *executionContext) _Pool_game(ctx context.Context, field graphql.CollectedField, obj *models.Pool) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Pool",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Game, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.Game)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNGame2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐGame(ctx, field.Selections, res)
}

func (ec *executionContext) _Pool_legs(ctx context.Context, field graphql.CollectedField, obj *models.Pool) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Pool",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Legs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]models.Leg)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNLeg2ᚕgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐLeg(ctx, field.Selections, res)
}

func (ec *executionContext) _Pool_consolationPrizes(ctx context.Context, field graphql.CollectedField, obj *models.Pool) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Pool",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Pool().ConsolationPrizes(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.ConsolationPrize)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOConsolationPrize2ᚕᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐConsolationPrize(ctx, field.Selections, res)
}

func (ec *executionContext) _PoolDefault_id(ctx context.Context, field graphql.CollectedField, obj *models.PoolDefault) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "PoolDefault",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.PoolDefault().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PoolDefault_legCount(ctx context.Context, field graphql.CollectedField, obj *models.PoolDefault) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "PoolDefault",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.PoolDefault().LegCount(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDecimal2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PoolDefault_game(ctx context.Context, field graphql.CollectedField, obj *models.PoolDefault) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "PoolDefault",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Game, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.Game)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNGame2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐGame(ctx, field.Selections, res)
}

func (ec *executionContext) _PoolDefault_type(ctx context.Context, field graphql.CollectedField, obj *models.PoolDefault) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "PoolDefault",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.PoolType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNPoolType2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐPoolType(ctx, field.Selections, res)
}

func (ec *executionContext) _PoolDefault_guarantee(ctx context.Context, field graphql.CollectedField, obj *models.PoolDefault) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "PoolDefault",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.PoolDefault().Guarantee(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDecimal2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PoolDefault_carryIn(ctx context.Context, field graphql.CollectedField, obj *models.PoolDefault) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "PoolDefault",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.PoolDefault().CarryIn(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDecimal2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PoolDefault_allocation(ctx context.Context, field graphql.CollectedField, obj *models.PoolDefault) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "PoolDefault",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.PoolDefault().Allocation(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDecimal2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PoolDefault_unitValue(ctx context.Context, field graphql.CollectedField, obj *models.PoolDefault) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "PoolDefault",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.PoolDefault().UnitValue(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDecimal2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PoolDefault_minUnitPerLine(ctx context.Context, field graphql.CollectedField, obj *models.PoolDefault) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "PoolDefault",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.PoolDefault().MinUnitPerLine(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDecimal2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PoolDefault_maxUnitPerLine(ctx context.Context, field graphql.CollectedField, obj *models.PoolDefault) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "PoolDefault",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.PoolDefault().MaxUnitPerLine(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDecimal2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PoolDefault_minUnitPerTicket(ctx context.Context, field graphql.CollectedField, obj *models.PoolDefault) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "PoolDefault",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.PoolDefault().MinUnitPerTicket(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDecimal2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PoolDefault_maxUnitPerTicket(ctx context.Context, field graphql.CollectedField, obj *models.PoolDefault) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "PoolDefault",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.PoolDefault().MaxUnitPerTicket(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDecimal2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PoolDefault_currency(ctx context.Context, field graphql.CollectedField, obj *models.PoolDefault) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "PoolDefault",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Currency, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.PoolCurrency)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNPoolCurrency2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐPoolCurrency(ctx, field.Selections, res)
}

func (ec *executionContext) _PoolDefault_note(ctx context.Context, field graphql.CollectedField, obj *models.PoolDefault) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "PoolDefault",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Note, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_Event(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_Event_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Event(rctx, args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Event)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNEvent2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐEvent(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_allEvents(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_allEvents_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AllEvents(rctx, args["filter"].(*models.EventFilter), args["page"].(*int), args["perPage"].(*int), args["sortField"].(*string), args["sortOrder"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Event)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNEvent2ᚕᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐEvent(ctx, field.Selections, res)
}

func (ec *executionContext) _Query__allEventsMeta(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query__allEventsMeta_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query()._allEventsMeta(rctx, args["filter"].(*models.EventFilter), args["page"].(*int), args["perPage"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.ListMetadata)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOListMetadata2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐListMetadata(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_Pool(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_Pool_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Pool(rctx, args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Pool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNPool2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐPool(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_allPools(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_allPools_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AllPools(rctx, args["filter"].(*models.PoolFilter), args["page"].(*int), args["perPage"].(*int), args["sortField"].(*string), args["sortOrder"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Pool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNPool2ᚕᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐPool(ctx, field.Selections, res)
}

func (ec *executionContext) _Query__allPoolsMeta(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query__allPoolsMeta_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query()._allPoolsMeta(rctx, args["filter"].(*models.PoolFilter), args["page"].(*int), args["perPage"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.ListMetadata)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOListMetadata2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐListMetadata(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_PoolDefault(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_PoolDefault_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().PoolDefault(rctx, args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.PoolDefault)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNPoolDefault2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐPoolDefault(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_allPoolDefaults(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_allPoolDefaults_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AllPoolDefaults(rctx, args["filter"].(*models.PoolDefaultFilter), args["page"].(*int), args["perPage"].(*int), args["sortField"].(*string), args["sortOrder"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.PoolDefault)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNPoolDefault2ᚕᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐPoolDefault(ctx, field.Selections, res)
}

func (ec *executionContext) _Query__allPoolDefaultsMeta(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query__allPoolDefaultsMeta_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query()._allPoolDefaultsMeta(rctx, args["filter"].(*models.PoolDefaultFilter), args["page"].(*int), args["perPage"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.ListMetadata)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOListMetadata2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐListMetadata(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_Leg(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_Leg_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Leg(rctx, args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Leg)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNLeg2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐLeg(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_allLegs(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_allLegs_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AllLegs(rctx, args["filter"].(*models.LegFilter), args["page"].(*int), args["perPage"].(*int), args["sortField"].(*string), args["sortOrder"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Leg)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNLeg2ᚕᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐLeg(ctx, field.Selections, res)
}

func (ec *executionContext) _Query__allLegsMeta(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query__allLegsMeta_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query()._allLegsMeta(rctx, args["filter"].(*models.LegFilter), args["page"].(*int), args["perPage"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.ListMetadata)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOListMetadata2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐListMetadata(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_Match(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_Match_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Match(rctx, args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Match)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNMatch2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐMatch(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_allMatches(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_allMatches_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AllMatches(rctx, args["filter"].(*models.MatchFilter), args["page"].(*int), args["perPage"].(*int), args["sortField"].(*string), args["sortOrder"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Match)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNMatch2ᚕᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐMatch(ctx, field.Selections, res)
}

func (ec *executionContext) _Query__allMatchesMeta(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query__allMatchesMeta_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query()._allMatchesMeta(rctx, args["filter"].(*models.MatchFilter), args["page"].(*int), args["perPage"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.ListMetadata)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOListMetadata2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐListMetadata(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_Competitor(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_Competitor_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Competitor(rctx, args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Competitor)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNCompetitor2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐCompetitor(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_allCompetitors(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_allCompetitors_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AllCompetitors(rctx, args["filter"].(*models.CompetitorFilter), args["page"].(*int), args["perPage"].(*int), args["sortField"].(*string), args["sortOrder"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Competitor)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNCompetitor2ᚕᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐCompetitor(ctx, field.Selections, res)
}

func (ec *executionContext) _Query__allCompetitorsMeta(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query__allCompetitorsMeta_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query()._allCompetitorsMeta(rctx, args["filter"].(*models.CompetitorFilter), args["page"].(*int), args["perPage"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.ListMetadata)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOListMetadata2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐListMetadata(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_Player(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_Player_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Player(rctx, args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Player)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNPlayer2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐPlayer(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_allPlayers(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_allPlayers_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AllPlayers(rctx, args["filter"].(*models.PlayerFilter), args["page"].(*int), args["perPage"].(*int), args["sortField"].(*string), args["sortOrder"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Player)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNPlayer2ᚕᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐPlayer(ctx, field.Selections, res)
}

func (ec *executionContext) _Query__allPlayersMeta(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query__allPlayersMeta_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query()._allPlayersMeta(rctx, args["filter"].(*models.PlayerFilter), args["page"].(*int), args["perPage"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.ListMetadata)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOListMetadata2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐListMetadata(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_User(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_User_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().User(rctx, args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.User)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNUser2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_allUsers(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_allUsers_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AllUsers(rctx, args["filter"].(*models.UserFilter), args["page"].(*int), args["perPage"].(*int), args["sortField"].(*string), args["sortOrder"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.User)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNUser2ᚕᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) _Query__allUsersMeta(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query__allUsersMeta_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query()._allUsersMeta(rctx, args["filter"].(*models.UserFilter), args["page"].(*int), args["perPage"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.ListMetadata)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOListMetadata2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐListMetadata(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_Audit(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_Audit_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Audit(rctx, args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Audit)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNAudit2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐAudit(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_allAudits(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_allAudits_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AllAudits(rctx, args["filter"].(*models.AuditFilter), args["page"].(*int), args["perPage"].(*int), args["sortField"].(*string), args["sortOrder"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Audit)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNAudit2ᚕᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐAudit(ctx, field.Selections, res)
}

func (ec *executionContext) _Query__allAuditsMeta(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query__allAuditsMeta_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query()._allAuditsMeta(rctx, args["filter"].(*models.AuditFilter), args["page"].(*int), args["perPage"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.ListMetadata)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOListMetadata2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐListMetadata(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_OverUnderDefault(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_OverUnderDefault_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().OverUnderDefault(rctx, args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.OverUnderDefault)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNOverUnderDefault2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐOverUnderDefault(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_allOverUnderDefaults(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_allOverUnderDefaults_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AllOverUnderDefaults(rctx, args["filter"].(*models.OverUnderDefaultFilter), args["page"].(*int), args["perPage"].(*int), args["sortField"].(*string), args["sortOrder"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.OverUnderDefault)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNOverUnderDefault2ᚕᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐOverUnderDefault(ctx, field.Selections, res)
}

func (ec *executionContext) _Query__allOverUnderDefaultsMeta(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query__allOverUnderDefaultsMeta_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query()._allOverUnderDefaultsMeta(rctx, args["filter"].(*models.OverUnderDefaultFilter), args["page"].(*int), args["perPage"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.ListMetadata)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOListMetadata2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐListMetadata(ctx, field.Selections, res)
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query___type_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx, field.Selections, res)
}

func (ec *executionContext) _Session_token(ctx context.Context, field graphql.CollectedField, obj *models.Session) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Session",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Token, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TeamProbabilities_teamId(ctx context.Context, field graphql.CollectedField, obj *models.TeamProbabilities) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "TeamProbabilities",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TeamID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TeamProbabilities_probability(ctx context.Context, field graphql.CollectedField, obj *models.TeamProbabilities) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "TeamProbabilities",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Probability, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _TeamScore_teamId(ctx context.Context, field graphql.CollectedField, obj *models.TeamScore) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "TeamScore",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TeamID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TeamScore_score(ctx context.Context, field graphql.CollectedField, obj *models.TeamScore) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "TeamScore",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Score, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _TeamScores_teamId(ctx context.Context, field graphql.CollectedField, obj *models.TeamScores) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "TeamScores",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TeamID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TeamScores_score(ctx context.Context, field graphql.CollectedField, obj *models.TeamScores) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "TeamScores",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Score, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _TeamWinProbability_teamId(ctx context.Context, field graphql.CollectedField, obj *models.TeamWinProbability) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "TeamWinProbability",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TeamID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TeamWinProbability_probability(ctx context.Context, field graphql.CollectedField, obj *models.TeamWinProbability) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "TeamWinProbability",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Probability, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDecimal2string(ctx, field.Selections, res)
}

func (ec *executionContext) _User_id(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _User_email(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Email, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _User_token(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Token, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _User_accessRole(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AccessRole, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.AccessRole)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNAccessRole2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐAccessRole(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__DirectiveLocation2ᚕstring(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field___Type_fields_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field___Type_enumValues_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputAuditFilter(ctx context.Context, obj interface{}) (models.AuditFilter, error) {
	var it models.AuditFilter
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error
			it.ID, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "targetId":
			var err error
			it.TargetID, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "targetType":
			var err error
			it.TargetType, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "userId":
			var err error
			it.UserID, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "editAction":
			var err error
			it.EditAction, err = ec.unmarshalOEditAction2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐEditAction(ctx, v)
			if err != nil {
				return it, err
			}
		case "ids":
			var err error
			it.Ids, err = ec.unmarshalOID2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAuthInput(ctx context.Context, obj interface{}) (models.AuthInput, error) {
	var it models.AuthInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "email":
			var err error
			it.Email, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "password":
			var err error
			it.Password, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCompetitorFilter(ctx context.Context, obj interface{}) (models.CompetitorFilter, error) {
	var it models.CompetitorFilter
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error
			it.ID, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error
			it.Name, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "externalId":
			var err error
			it.ExternalID, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "match_id":
			var err error
			it.MatchID, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "ids":
			var err error
			it.Ids, err = ec.unmarshalOID2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateCompetitorInput(ctx context.Context, obj interface{}) (models.CreateCompetitorInput, error) {
	var it models.CreateCompetitorInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name":
			var err error
			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "logo":
			var err error
			it.Logo, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateEventInput(ctx context.Context, obj interface{}) (models.CreateEventInput, error) {
	var it models.CreateEventInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name":
			var err error
			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "type":
			var err error
			it.Type, err = ec.unmarshalNEventType2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐEventType(ctx, v)
			if err != nil {
				return it, err
			}
		case "game":
			var err error
			it.Game, err = ec.unmarshalNGame2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐGame(ctx, v)
			if err != nil {
				return it, err
			}
		case "logo":
			var err error
			it.Logo, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "startDate":
			var err error
			it.StartDate, err = ec.unmarshalNTime2timeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "endDate":
			var err error
			it.EndDate, err = ec.unmarshalNTime2timeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "isActive":
			var err error
			it.IsActive, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateLegInput(ctx context.Context, obj interface{}) (models.CreateLegInput, error) {
	var it models.CreateLegInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "matchId":
			var err error
			it.MatchID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "poolId":
			var err error
			it.PoolID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "threshold":
			var err error
			it.Threshold, err = ec.unmarshalODecimal2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateMatchInput(ctx context.Context, obj interface{}) (models.CreateMatchInput, error) {
	var it models.CreateMatchInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name":
			var err error
			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "eventId":
			var err error
			it.EventID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "description":
			var err error
			it.Description, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "startTime":
			var err error
			it.StartTime, err = ec.unmarshalNTime2timeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "isActive":
			var err error
			it.IsActive, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "internalStatus":
			var err error
			it.InternalStatus, err = ec.unmarshalNMatchInternalStatus2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐMatchInternalStatus(ctx, v)
			if err != nil {
				return it, err
			}
		case "eventStage":
			var err error
			it.EventStage, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "format":
			var err error
			it.Format, err = ec.unmarshalNMatchFormat2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐMatchFormat(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateOverUnderDefaultInput(ctx context.Context, obj interface{}) (models.CreateOverUnderDefaultInput, error) {
	var it models.CreateOverUnderDefaultInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "game":
			var err error
			it.Game, err = ec.unmarshalNGame2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐGame(ctx, v)
			if err != nil {
				return it, err
			}
		case "matchFormat":
			var err error
			it.MatchFormat, err = ec.unmarshalNMatchFormat2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐMatchFormat(ctx, v)
			if err != nil {
				return it, err
			}
		case "evenThreshold":
			var err error
			it.EvenThreshold, err = ec.unmarshalNDecimal2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "favoredThreshold":
			var err error
			it.FavoredThreshold, err = ec.unmarshalNDecimal2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "note":
			var err error
			it.Note, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreatePlayerInput(ctx context.Context, obj interface{}) (models.CreatePlayerInput, error) {
	var it models.CreatePlayerInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name":
			var err error
			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nickname":
			var err error
			it.Nickname, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "teamId":
			var err error
			it.TeamID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreatePoolDefaultInput(ctx context.Context, obj interface{}) (models.CreatePoolDefaultInput, error) {
	var it models.CreatePoolDefaultInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "legCount":
			var err error
			it.LegCount, err = ec.unmarshalNDecimal2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "game":
			var err error
			it.Game, err = ec.unmarshalNGame2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐGame(ctx, v)
			if err != nil {
				return it, err
			}
		case "type":
			var err error
			it.Type, err = ec.unmarshalNPoolType2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐPoolType(ctx, v)
			if err != nil {
				return it, err
			}
		case "guarantee":
			var err error
			it.Guarantee, err = ec.unmarshalNDecimal2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "carryIn":
			var err error
			it.CarryIn, err = ec.unmarshalNDecimal2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "allocation":
			var err error
			it.Allocation, err = ec.unmarshalNDecimal2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "unitValue":
			var err error
			it.UnitValue, err = ec.unmarshalNDecimal2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "minUnitPerLine":
			var err error
			it.MinUnitPerLine, err = ec.unmarshalNDecimal2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "maxUnitPerLine":
			var err error
			it.MaxUnitPerLine, err = ec.unmarshalNDecimal2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "minUnitPerTicket":
			var err error
			it.MinUnitPerTicket, err = ec.unmarshalNDecimal2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "maxUnitPerTicket":
			var err error
			it.MaxUnitPerTicket, err = ec.unmarshalNDecimal2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "currency":
			var err error
			it.Currency, err = ec.unmarshalNPoolCurrency2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐPoolCurrency(ctx, v)
			if err != nil {
				return it, err
			}
		case "note":
			var err error
			it.Note, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreatePoolInput(ctx context.Context, obj interface{}) (models.CreatePoolInput, error) {
	var it models.CreatePoolInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name":
			var err error
			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "type":
			var err error
			it.Type, err = ec.unmarshalNPoolType2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐPoolType(ctx, v)
			if err != nil {
				return it, err
			}
		case "guarantee":
			var err error
			it.Guarantee, err = ec.unmarshalNDecimal2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "carryIn":
			var err error
			it.CarryIn, err = ec.unmarshalNDecimal2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "allocation":
			var err error
			it.Allocation, err = ec.unmarshalNDecimal2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "game":
			var err error
			it.Game, err = ec.unmarshalNGame2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐGame(ctx, v)
			if err != nil {
				return it, err
			}
		case "note":
			var err error
			it.Note, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "unitValue":
			var err error
			it.UnitValue, err = ec.unmarshalNDecimal2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "currency":
			var err error
			it.Currency, err = ec.unmarshalNPoolCurrency2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐPoolCurrency(ctx, v)
			if err != nil {
				return it, err
			}
		case "minUnitPerLine":
			var err error
			it.MinUnitPerLine, err = ec.unmarshalNDecimal2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "maxUnitPerLine":
			var err error
			it.MaxUnitPerLine, err = ec.unmarshalNDecimal2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "minUnitPerTicket":
			var err error
			it.MinUnitPerTicket, err = ec.unmarshalNDecimal2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "maxUnitPerTicket":
			var err error
			it.MaxUnitPerTicket, err = ec.unmarshalNDecimal2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateUserInput(ctx context.Context, obj interface{}) (models.CreateUserInput, error) {
	var it models.CreateUserInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "email":
			var err error
			it.Email, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "password":
			var err error
			it.Password, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "role":
			var err error
			it.Role, err = ec.unmarshalNAccessRole2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐAccessRole(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputEventFilter(ctx context.Context, obj interface{}) (models.EventFilter, error) {
	var it models.EventFilter
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error
			it.ID, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error
			it.Name, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "isActive":
			var err error
			it.IsActive, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "game":
			var err error
			it.Game, err = ec.unmarshalOGame2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐGame(ctx, v)
			if err != nil {
				return it, err
			}
		case "externalId":
			var err error
			it.ExternalID, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "ids":
			var err error
			it.Ids, err = ec.unmarshalOID2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputLegFilter(ctx context.Context, obj interface{}) (models.LegFilter, error) {
	var it models.LegFilter
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error
			it.ID, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "matchId":
			var err error
			it.MatchID, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "poolId":
			var err error
			it.PoolID, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "ids":
			var err error
			it.Ids, err = ec.unmarshalOID2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMatchFilter(ctx context.Context, obj interface{}) (models.MatchFilter, error) {
	var it models.MatchFilter
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error
			it.ID, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error
			it.Name, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "externalId":
			var err error
			it.ExternalID, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "isActive":
			var err error
			it.IsActive, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "isAutogenerated":
			var err error
			it.IsAutogenerated, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "internalStatus":
			var err error
			it.InternalStatus, err = ec.unmarshalOMatchInternalStatus2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐMatchInternalStatus(ctx, v)
			if err != nil {
				return it, err
			}
		case "format":
			var err error
			it.Format, err = ec.unmarshalOMatchFormat2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐMatchFormat(ctx, v)
			if err != nil {
				return it, err
			}
		case "eventStage":
			var err error
			it.EventStage, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "eventId":
			var err error
			it.EventID, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "ids":
			var err error
			it.Ids, err = ec.unmarshalOID2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputOverUnderDefaultFilter(ctx context.Context, obj interface{}) (models.OverUnderDefaultFilter, error) {
	var it models.OverUnderDefaultFilter
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "game":
			var err error
			it.Game, err = ec.unmarshalOGame2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐGame(ctx, v)
			if err != nil {
				return it, err
			}
		case "matchFormat":
			var err error
			it.MatchFormat, err = ec.unmarshalOMatchFormat2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐMatchFormat(ctx, v)
			if err != nil {
				return it, err
			}
		case "ids":
			var err error
			it.Ids, err = ec.unmarshalOID2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPlayerFilter(ctx context.Context, obj interface{}) (models.PlayerFilter, error) {
	var it models.PlayerFilter
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error
			it.ID, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error
			it.Name, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nickname":
			var err error
			it.Nickname, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "externalId":
			var err error
			it.ExternalID, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "teamId":
			var err error
			it.TeamID, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "ids":
			var err error
			it.Ids, err = ec.unmarshalOID2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPoolDefaultFilter(ctx context.Context, obj interface{}) (models.PoolDefaultFilter, error) {
	var it models.PoolDefaultFilter
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "type":
			var err error
			it.Type, err = ec.unmarshalOPoolType2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐPoolType(ctx, v)
			if err != nil {
				return it, err
			}
		case "game":
			var err error
			it.Game, err = ec.unmarshalOGame2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐGame(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPoolFilter(ctx context.Context, obj interface{}) (models.PoolFilter, error) {
	var it models.PoolFilter
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error
			it.ID, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error
			it.Name, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "isActive":
			var err error
			it.IsActive, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "isAutogenerated":
			var err error
			it.IsAutogenerated, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "poolStatus":
			var err error
			it.PoolStatus, err = ec.unmarshalOPoolStatus2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐPoolStatus(ctx, v)
			if err != nil {
				return it, err
			}
		case "guarantee":
			var err error
			it.Guarantee, err = ec.unmarshalODecimal2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "legCount":
			var err error
			it.LegCount, err = ec.unmarshalODecimal2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "type":
			var err error
			it.Type, err = ec.unmarshalOPoolType2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐPoolType(ctx, v)
			if err != nil {
				return it, err
			}
		case "game":
			var err error
			it.Game, err = ec.unmarshalOGame2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐGame(ctx, v)
			if err != nil {
				return it, err
			}
		case "eventId":
			var err error
			it.EventID, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSyncTimeBefore":
			var err error
			it.LastSyncTimeBefore, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSyncTimeAfter":
			var err error
			it.LastSyncTimeAfter, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "ids":
			var err error
			it.Ids, err = ec.unmarshalOID2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateCompetitorInput(ctx context.Context, obj interface{}) (models.UpdateCompetitorInput, error) {
	var it models.UpdateCompetitorInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error
			it.ID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error
			it.Name, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "logo":
			var err error
			it.Logo, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateConsolationPrize(ctx context.Context, obj interface{}) (models.UpdateConsolationPrize, error) {
	var it models.UpdateConsolationPrize
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "guarantee":
			var err error
			it.Guarantee, err = ec.unmarshalNDecimal2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "carryIn":
			var err error
			it.CarryIn, err = ec.unmarshalNDecimal2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "allocation":
			var err error
			it.Allocation, err = ec.unmarshalNDecimal2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateEventInput(ctx context.Context, obj interface{}) (models.UpdateEventInput, error) {
	var it models.UpdateEventInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error
			it.ID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error
			it.Name, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "type":
			var err error
			it.Type, err = ec.unmarshalOEventType2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐEventType(ctx, v)
			if err != nil {
				return it, err
			}
		case "game":
			var err error
			it.Game, err = ec.unmarshalOGame2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐGame(ctx, v)
			if err != nil {
				return it, err
			}
		case "logo":
			var err error
			it.Logo, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "startDate":
			var err error
			it.StartDate, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "endDate":
			var err error
			it.EndDate, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "isActive":
			var err error
			it.IsActive, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateLegInput(ctx context.Context, obj interface{}) (models.UpdateLegInput, error) {
	var it models.UpdateLegInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error
			it.ID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "threshold":
			var err error
			it.Threshold, err = ec.unmarshalODecimal2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "matchId":
			var err error
			it.MatchID, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "poolId":
			var err error
			it.PoolID, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateMatchInput(ctx context.Context, obj interface{}) (models.UpdateMatchInput, error) {
	var it models.UpdateMatchInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error
			it.ID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error
			it.Name, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "description":
			var err error
			it.Description, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "startTime":
			var err error
			it.StartTime, err = ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "isActive":
			var err error
			it.IsActive, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "internalStatus":
			var err error
			it.InternalStatus, err = ec.unmarshalOMatchInternalStatus2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐMatchInternalStatus(ctx, v)
			if err != nil {
				return it, err
			}
		case "eventStage":
			var err error
			it.EventStage, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "eventId":
			var err error
			it.EventID, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "teamScores":
			var err error
			it.TeamScores, err = ec.unmarshalOUpdateTeamScores2ᚕᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐUpdateTeamScores(ctx, v)
			if err != nil {
				return it, err
			}
		case "teamOuScores":
			var err error
			it.TeamOuScores, err = ec.unmarshalOUpdateTeamScores2ᚕᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐUpdateTeamScores(ctx, v)
			if err != nil {
				return it, err
			}
		case "teamWinProbabilities":
			var err error
			it.TeamWinProbabilities, err = ec.unmarshalOUpdateTeamProbabilities2ᚕᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐUpdateTeamProbabilities(ctx, v)
			if err != nil {
				return it, err
			}
		case "format":
			var err error
			it.Format, err = ec.unmarshalOMatchFormat2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐMatchFormat(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateOverUnderDefaultInput(ctx context.Context, obj interface{}) (models.UpdateOverUnderDefaultInput, error) {
	var it models.UpdateOverUnderDefaultInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error
			it.ID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "evenThreshold":
			var err error
			it.EvenThreshold, err = ec.unmarshalODecimal2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "favoredThreshold":
			var err error
			it.FavoredThreshold, err = ec.unmarshalODecimal2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "note":
			var err error
			it.Note, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdatePlayerInput(ctx context.Context, obj interface{}) (models.UpdatePlayerInput, error) {
	var it models.UpdatePlayerInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error
			it.ID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error
			it.Name, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nickname":
			var err error
			it.Nickname, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "teamId":
			var err error
			it.TeamID, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdatePoolDefaultInput(ctx context.Context, obj interface{}) (models.UpdatePoolDefaultInput, error) {
	var it models.UpdatePoolDefaultInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error
			it.ID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "legCount":
			var err error
			it.LegCount, err = ec.unmarshalODecimal2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "game":
			var err error
			it.Game, err = ec.unmarshalOGame2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐGame(ctx, v)
			if err != nil {
				return it, err
			}
		case "type":
			var err error
			it.Type, err = ec.unmarshalOPoolType2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐPoolType(ctx, v)
			if err != nil {
				return it, err
			}
		case "guarantee":
			var err error
			it.Guarantee, err = ec.unmarshalODecimal2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "carryIn":
			var err error
			it.CarryIn, err = ec.unmarshalODecimal2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "allocation":
			var err error
			it.Allocation, err = ec.unmarshalODecimal2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "unitValue":
			var err error
			it.UnitValue, err = ec.unmarshalODecimal2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "minUnitPerLine":
			var err error
			it.MinUnitPerLine, err = ec.unmarshalODecimal2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "maxUnitPerLine":
			var err error
			it.MaxUnitPerLine, err = ec.unmarshalODecimal2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "minUnitPerTicket":
			var err error
			it.MinUnitPerTicket, err = ec.unmarshalODecimal2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "maxUnitPerTicket":
			var err error
			it.MaxUnitPerTicket, err = ec.unmarshalODecimal2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "currency":
			var err error
			it.Currency, err = ec.unmarshalOPoolCurrency2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐPoolCurrency(ctx, v)
			if err != nil {
				return it, err
			}
		case "note":
			var err error
			it.Note, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdatePoolInput(ctx context.Context, obj interface{}) (models.UpdatePoolInput, error) {
	var it models.UpdatePoolInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error
			it.ID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error
			it.Name, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "isActive":
			var err error
			it.IsActive, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "guarantee":
			var err error
			it.Guarantee, err = ec.unmarshalNDecimal2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "carryIn":
			var err error
			it.CarryIn, err = ec.unmarshalNDecimal2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "allocation":
			var err error
			it.Allocation, err = ec.unmarshalNDecimal2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "note":
			var err error
			it.Note, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "unitValue":
			var err error
			it.UnitValue, err = ec.unmarshalODecimal2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "minUnitPerLine":
			var err error
			it.MinUnitPerLine, err = ec.unmarshalODecimal2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "maxUnitPerLine":
			var err error
			it.MaxUnitPerLine, err = ec.unmarshalODecimal2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "minUnitPerTicket":
			var err error
			it.MinUnitPerTicket, err = ec.unmarshalODecimal2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "maxUnitPerTicket":
			var err error
			it.MaxUnitPerTicket, err = ec.unmarshalODecimal2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "currency":
			var err error
			it.Currency, err = ec.unmarshalOPoolCurrency2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐPoolCurrency(ctx, v)
			if err != nil {
				return it, err
			}
		case "syncedColossusStatus":
			var err error
			it.SyncedColossusStatus, err = ec.unmarshalOPoolStatus2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐPoolStatus(ctx, v)
			if err != nil {
				return it, err
			}
		case "legsIds":
			var err error
			it.LegsIds, err = ec.unmarshalOID2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "consolationPrizes":
			var err error
			it.ConsolationPrizes, err = ec.unmarshalOUpdateConsolationPrize2ᚕᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐUpdateConsolationPrize(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateTeamProbabilities(ctx context.Context, obj interface{}) (models.UpdateTeamProbabilities, error) {
	var it models.UpdateTeamProbabilities
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "teamId":
			var err error
			it.TeamID, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "probability":
			var err error
			it.Probability, err = ec.unmarshalNFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateTeamScores(ctx context.Context, obj interface{}) (models.UpdateTeamScores, error) {
	var it models.UpdateTeamScores
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "teamId":
			var err error
			it.TeamID, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "score":
			var err error
			it.Score, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateUserInput(ctx context.Context, obj interface{}) (models.UpdateUserInput, error) {
	var it models.UpdateUserInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error
			it.ID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "email":
			var err error
			it.Email, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "password":
			var err error
			it.Password, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "accessRole":
			var err error
			it.AccessRole, err = ec.unmarshalOAccessRole2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐAccessRole(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUserFilter(ctx context.Context, obj interface{}) (models.UserFilter, error) {
	var it models.UserFilter
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "email":
			var err error
			it.Email, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "role":
			var err error
			it.Role, err = ec.unmarshalOAccessRole2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐAccessRole(ctx, v)
			if err != nil {
				return it, err
			}
		case "ids":
			var err error
			it.Ids, err = ec.unmarshalOID2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var auditImplementors = []string{"Audit"}

func (ec *executionContext) _Audit(ctx context.Context, sel ast.SelectionSet, obj *models.Audit) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, auditImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Audit")
		case "id":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Audit_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "time":
			out.Values[i] = ec._Audit_time(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "targetId":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Audit_targetId(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "targetType":
			out.Values[i] = ec._Audit_targetType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "user":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Audit_user(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "editAction":
			out.Values[i] = ec._Audit_editAction(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "content":
			out.Values[i] = ec._Audit_content(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var competitorImplementors = []string{"Competitor"}

func (ec *executionContext) _Competitor(ctx context.Context, sel ast.SelectionSet, obj *models.Competitor) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, competitorImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Competitor")
		case "id":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Competitor_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "externalId":
			out.Values[i] = ec._Competitor_externalId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "name":
			out.Values[i] = ec._Competitor_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "logo":
			out.Values[i] = ec._Competitor_logo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "matches":
			out.Values[i] = ec._Competitor_matches(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var consolationPrizeImplementors = []string{"ConsolationPrize"}

func (ec *executionContext) _ConsolationPrize(ctx context.Context, sel ast.SelectionSet, obj *models.ConsolationPrize) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, consolationPrizeImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ConsolationPrize")
		case "guarantee":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ConsolationPrize_guarantee(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "carryIn":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ConsolationPrize_carryIn(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "allocation":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ConsolationPrize_allocation(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var eventImplementors = []string{"Event"}

func (ec *executionContext) _Event(ctx context.Context, sel ast.SelectionSet, obj *models.Event) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, eventImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Event")
		case "id":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Event_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "name":
			out.Values[i] = ec._Event_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "externalId":
			out.Values[i] = ec._Event_externalId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "type":
			out.Values[i] = ec._Event_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "game":
			out.Values[i] = ec._Event_game(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "logo":
			out.Values[i] = ec._Event_logo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "startDate":
			out.Values[i] = ec._Event_startDate(ctx, field, obj)
		case "endDate":
			out.Values[i] = ec._Event_endDate(ctx, field, obj)
		case "isActive":
			out.Values[i] = ec._Event_isActive(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "isAutogenerated":
			out.Values[i] = ec._Event_isAutogenerated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "matches":
			out.Values[i] = ec._Event_matches(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var legImplementors = []string{"Leg"}

func (ec *executionContext) _Leg(ctx context.Context, sel ast.SelectionSet, obj *models.Leg) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, legImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Leg")
		case "id":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Leg_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "lastSyncTime":
			out.Values[i] = ec._Leg_lastSyncTime(ctx, field, obj)
		case "threshold":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Leg_threshold(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "matchId":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Leg_matchId(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "poolId":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Leg_poolId(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var listMetadataImplementors = []string{"ListMetadata"}

func (ec *executionContext) _ListMetadata(ctx context.Context, sel ast.SelectionSet, obj *models.ListMetadata) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, listMetadataImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ListMetadata")
		case "count":
			out.Values[i] = ec._ListMetadata_count(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var matchImplementors = []string{"Match"}

func (ec *executionContext) _Match(ctx context.Context, sel ast.SelectionSet, obj *models.Match) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, matchImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Match")
		case "id":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Match_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "eventId":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Match_eventId(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "externalId":
			out.Values[i] = ec._Match_externalId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "name":
			out.Values[i] = ec._Match_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "description":
			out.Values[i] = ec._Match_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "startTime":
			out.Values[i] = ec._Match_startTime(ctx, field, obj)
		case "isActive":
			out.Values[i] = ec._Match_isActive(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "isAutogenerated":
			out.Values[i] = ec._Match_isAutogenerated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "internalStatus":
			out.Values[i] = ec._Match_internalStatus(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "eventStage":
			out.Values[i] = ec._Match_eventStage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "competitors":
			out.Values[i] = ec._Match_competitors(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "statistics":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Match_statistics(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "teamScores":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Match_teamScores(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "teamOuScores":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Match_teamOuScores(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "teamWinProbabilities":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Match_teamWinProbabilities(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "format":
			out.Values[i] = ec._Match_format(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "history":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Match_history(ctx, field, obj)
				return res
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, mutationImplementors)

	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "createUser":
			out.Values[i] = ec._Mutation_createUser(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updateUser":
			out.Values[i] = ec._Mutation_updateUser(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createSession":
			out.Values[i] = ec._Mutation_createSession(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createEvent":
			out.Values[i] = ec._Mutation_createEvent(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updateEvent":
			out.Values[i] = ec._Mutation_updateEvent(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deleteEvent":
			out.Values[i] = ec._Mutation_deleteEvent(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createMatch":
			out.Values[i] = ec._Mutation_createMatch(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updateMatch":
			out.Values[i] = ec._Mutation_updateMatch(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deleteMatch":
			out.Values[i] = ec._Mutation_deleteMatch(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createCompetitor":
			out.Values[i] = ec._Mutation_createCompetitor(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updateCompetitor":
			out.Values[i] = ec._Mutation_updateCompetitor(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deleteCompetitor":
			out.Values[i] = ec._Mutation_deleteCompetitor(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createPlayer":
			out.Values[i] = ec._Mutation_createPlayer(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updatePlayer":
			out.Values[i] = ec._Mutation_updatePlayer(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deletePlayer":
			out.Values[i] = ec._Mutation_deletePlayer(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createPool":
			out.Values[i] = ec._Mutation_createPool(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updatePool":
			out.Values[i] = ec._Mutation_updatePool(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deletePool":
			out.Values[i] = ec._Mutation_deletePool(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createPoolDefault":
			out.Values[i] = ec._Mutation_createPoolDefault(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updatePoolDefault":
			out.Values[i] = ec._Mutation_updatePoolDefault(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deletePoolDefault":
			out.Values[i] = ec._Mutation_deletePoolDefault(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createLeg":
			out.Values[i] = ec._Mutation_createLeg(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updateLeg":
			out.Values[i] = ec._Mutation_updateLeg(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deleteLeg":
			out.Values[i] = ec._Mutation_deleteLeg(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createOverUnderDefault":
			out.Values[i] = ec._Mutation_createOverUnderDefault(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updateOverUnderDefault":
			out.Values[i] = ec._Mutation_updateOverUnderDefault(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deleteOverUnderDefault":
			out.Values[i] = ec._Mutation_deleteOverUnderDefault(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var overUnderDefaultImplementors = []string{"OverUnderDefault"}

func (ec *executionContext) _OverUnderDefault(ctx context.Context, sel ast.SelectionSet, obj *models.OverUnderDefault) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, overUnderDefaultImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OverUnderDefault")
		case "id":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._OverUnderDefault_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "game":
			out.Values[i] = ec._OverUnderDefault_game(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "matchFormat":
			out.Values[i] = ec._OverUnderDefault_matchFormat(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "evenThreshold":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._OverUnderDefault_evenThreshold(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "favoredThreshold":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._OverUnderDefault_favoredThreshold(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "note":
			out.Values[i] = ec._OverUnderDefault_note(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var playerImplementors = []string{"Player"}

func (ec *executionContext) _Player(ctx context.Context, sel ast.SelectionSet, obj *models.Player) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, playerImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Player")
		case "id":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Player_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "externalId":
			out.Values[i] = ec._Player_externalId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "name":
			out.Values[i] = ec._Player_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "nickname":
			out.Values[i] = ec._Player_nickname(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "teamId":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Player_teamId(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var poolImplementors = []string{"Pool"}

func (ec *executionContext) _Pool(ctx context.Context, sel ast.SelectionSet, obj *models.Pool) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, poolImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Pool")
		case "id":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Pool_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "name":
			out.Values[i] = ec._Pool_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "type":
			out.Values[i] = ec._Pool_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "isActive":
			out.Values[i] = ec._Pool_isActive(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "guarantee":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Pool_guarantee(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "carryIn":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Pool_carryIn(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "allocation":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Pool_allocation(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "note":
			out.Values[i] = ec._Pool_note(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "unitValue":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Pool_unitValue(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "minUnitPerLine":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Pool_minUnitPerLine(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "maxUnitPerLine":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Pool_maxUnitPerLine(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "minUnitPerTicket":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Pool_minUnitPerTicket(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "maxUnitPerTicket":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Pool_maxUnitPerTicket(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "currency":
			out.Values[i] = ec._Pool_currency(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "isAutogenerated":
			out.Values[i] = ec._Pool_isAutogenerated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "lastSyncTime":
			out.Values[i] = ec._Pool_lastSyncTime(ctx, field, obj)
		case "syncedColossusStatus":
			out.Values[i] = ec._Pool_syncedColossusStatus(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "game":
			out.Values[i] = ec._Pool_game(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "legs":
			out.Values[i] = ec._Pool_legs(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "consolationPrizes":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Pool_consolationPrizes(ctx, field, obj)
				return res
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var poolDefaultImplementors = []string{"PoolDefault"}

func (ec *executionContext) _PoolDefault(ctx context.Context, sel ast.SelectionSet, obj *models.PoolDefault) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, poolDefaultImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PoolDefault")
		case "id":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._PoolDefault_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "legCount":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._PoolDefault_legCount(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "game":
			out.Values[i] = ec._PoolDefault_game(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "type":
			out.Values[i] = ec._PoolDefault_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "guarantee":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._PoolDefault_guarantee(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "carryIn":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._PoolDefault_carryIn(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "allocation":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._PoolDefault_allocation(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "unitValue":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._PoolDefault_unitValue(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "minUnitPerLine":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._PoolDefault_minUnitPerLine(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "maxUnitPerLine":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._PoolDefault_maxUnitPerLine(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "minUnitPerTicket":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._PoolDefault_minUnitPerTicket(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "maxUnitPerTicket":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._PoolDefault_maxUnitPerTicket(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "currency":
			out.Values[i] = ec._PoolDefault_currency(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "note":
			out.Values[i] = ec._PoolDefault_note(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, queryImplementors)

	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "Event":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_Event(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "allEvents":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_allEvents(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "_allEventsMeta":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query__allEventsMeta(ctx, field)
				return res
			})
		case "Pool":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_Pool(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "allPools":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_allPools(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "_allPoolsMeta":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query__allPoolsMeta(ctx, field)
				return res
			})
		case "PoolDefault":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_PoolDefault(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "allPoolDefaults":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_allPoolDefaults(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "_allPoolDefaultsMeta":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query__allPoolDefaultsMeta(ctx, field)
				return res
			})
		case "Leg":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_Leg(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "allLegs":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_allLegs(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "_allLegsMeta":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query__allLegsMeta(ctx, field)
				return res
			})
		case "Match":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_Match(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "allMatches":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_allMatches(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "_allMatchesMeta":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query__allMatchesMeta(ctx, field)
				return res
			})
		case "Competitor":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_Competitor(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "allCompetitors":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_allCompetitors(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "_allCompetitorsMeta":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query__allCompetitorsMeta(ctx, field)
				return res
			})
		case "Player":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_Player(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "allPlayers":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_allPlayers(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "_allPlayersMeta":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query__allPlayersMeta(ctx, field)
				return res
			})
		case "User":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_User(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "allUsers":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_allUsers(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "_allUsersMeta":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query__allUsersMeta(ctx, field)
				return res
			})
		case "Audit":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_Audit(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "allAudits":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_allAudits(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "_allAuditsMeta":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query__allAuditsMeta(ctx, field)
				return res
			})
		case "OverUnderDefault":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_OverUnderDefault(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "allOverUnderDefaults":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_allOverUnderDefaults(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "_allOverUnderDefaultsMeta":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query__allOverUnderDefaultsMeta(ctx, field)
				return res
			})
		case "__type":
			out.Values[i] = ec._Query___type(ctx, field)
		case "__schema":
			out.Values[i] = ec._Query___schema(ctx, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var sessionImplementors = []string{"Session"}

func (ec *executionContext) _Session(ctx context.Context, sel ast.SelectionSet, obj *models.Session) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, sessionImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Session")
		case "token":
			out.Values[i] = ec._Session_token(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var teamProbabilitiesImplementors = []string{"TeamProbabilities"}

func (ec *executionContext) _TeamProbabilities(ctx context.Context, sel ast.SelectionSet, obj *models.TeamProbabilities) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, teamProbabilitiesImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamProbabilities")
		case "teamId":
			out.Values[i] = ec._TeamProbabilities_teamId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "probability":
			out.Values[i] = ec._TeamProbabilities_probability(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var teamScoreImplementors = []string{"TeamScore"}

func (ec *executionContext) _TeamScore(ctx context.Context, sel ast.SelectionSet, obj *models.TeamScore) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, teamScoreImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamScore")
		case "teamId":
			out.Values[i] = ec._TeamScore_teamId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "score":
			out.Values[i] = ec._TeamScore_score(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var teamScoresImplementors = []string{"TeamScores"}

func (ec *executionContext) _TeamScores(ctx context.Context, sel ast.SelectionSet, obj *models.TeamScores) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, teamScoresImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamScores")
		case "teamId":
			out.Values[i] = ec._TeamScores_teamId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "score":
			out.Values[i] = ec._TeamScores_score(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var teamWinProbabilityImplementors = []string{"TeamWinProbability"}

func (ec *executionContext) _TeamWinProbability(ctx context.Context, sel ast.SelectionSet, obj *models.TeamWinProbability) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, teamWinProbabilityImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamWinProbability")
		case "teamId":
			out.Values[i] = ec._TeamWinProbability_teamId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "probability":
			out.Values[i] = ec._TeamWinProbability_probability(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var userImplementors = []string{"User"}

func (ec *executionContext) _User(ctx context.Context, sel ast.SelectionSet, obj *models.User) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, userImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("User")
		case "id":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "email":
			out.Values[i] = ec._User_email(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "token":
			out.Values[i] = ec._User_token(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "accessRole":
			out.Values[i] = ec._User_accessRole(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) unmarshalNAccessRole2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐAccessRole(ctx context.Context, v interface{}) (models.AccessRole, error) {
	var res models.AccessRole
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNAccessRole2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐAccessRole(ctx context.Context, sel ast.SelectionSet, v models.AccessRole) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNAudit2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐAudit(ctx context.Context, sel ast.SelectionSet, v models.Audit) graphql.Marshaler {
	return ec._Audit(ctx, sel, &v)
}

func (ec *executionContext) marshalNAudit2ᚕᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐAudit(ctx context.Context, sel ast.SelectionSet, v []*models.Audit) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAudit2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐAudit(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNAudit2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐAudit(ctx context.Context, sel ast.SelectionSet, v *models.Audit) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Audit(ctx, sel, v)
}

func (ec *executionContext) unmarshalNAuthInput2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐAuthInput(ctx context.Context, v interface{}) (models.AuthInput, error) {
	return ec.unmarshalInputAuthInput(ctx, v)
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	return graphql.UnmarshalBoolean(v)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) marshalNCompetitor2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐCompetitor(ctx context.Context, sel ast.SelectionSet, v models.Competitor) graphql.Marshaler {
	return ec._Competitor(ctx, sel, &v)
}

func (ec *executionContext) marshalNCompetitor2ᚕgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐCompetitor(ctx context.Context, sel ast.SelectionSet, v []models.Competitor) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCompetitor2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐCompetitor(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNCompetitor2ᚕᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐCompetitor(ctx context.Context, sel ast.SelectionSet, v []*models.Competitor) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCompetitor2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐCompetitor(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNCompetitor2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐCompetitor(ctx context.Context, sel ast.SelectionSet, v *models.Competitor) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Competitor(ctx, sel, v)
}

func (ec *executionContext) marshalNConsolationPrize2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐConsolationPrize(ctx context.Context, sel ast.SelectionSet, v models.ConsolationPrize) graphql.Marshaler {
	return ec._ConsolationPrize(ctx, sel, &v)
}

func (ec *executionContext) marshalNConsolationPrize2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐConsolationPrize(ctx context.Context, sel ast.SelectionSet, v *models.ConsolationPrize) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ConsolationPrize(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCreateCompetitorInput2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐCreateCompetitorInput(ctx context.Context, v interface{}) (models.CreateCompetitorInput, error) {
	return ec.unmarshalInputCreateCompetitorInput(ctx, v)
}

func (ec *executionContext) unmarshalNCreateEventInput2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐCreateEventInput(ctx context.Context, v interface{}) (models.CreateEventInput, error) {
	return ec.unmarshalInputCreateEventInput(ctx, v)
}

func (ec *executionContext) unmarshalNCreateLegInput2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐCreateLegInput(ctx context.Context, v interface{}) (models.CreateLegInput, error) {
	return ec.unmarshalInputCreateLegInput(ctx, v)
}

func (ec *executionContext) unmarshalNCreateMatchInput2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐCreateMatchInput(ctx context.Context, v interface{}) (models.CreateMatchInput, error) {
	return ec.unmarshalInputCreateMatchInput(ctx, v)
}

func (ec *executionContext) unmarshalNCreateOverUnderDefaultInput2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐCreateOverUnderDefaultInput(ctx context.Context, v interface{}) (models.CreateOverUnderDefaultInput, error) {
	return ec.unmarshalInputCreateOverUnderDefaultInput(ctx, v)
}

func (ec *executionContext) unmarshalNCreatePlayerInput2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐCreatePlayerInput(ctx context.Context, v interface{}) (models.CreatePlayerInput, error) {
	return ec.unmarshalInputCreatePlayerInput(ctx, v)
}

func (ec *executionContext) unmarshalNCreatePoolDefaultInput2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐCreatePoolDefaultInput(ctx context.Context, v interface{}) (models.CreatePoolDefaultInput, error) {
	return ec.unmarshalInputCreatePoolDefaultInput(ctx, v)
}

func (ec *executionContext) unmarshalNCreatePoolInput2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐCreatePoolInput(ctx context.Context, v interface{}) (models.CreatePoolInput, error) {
	return ec.unmarshalInputCreatePoolInput(ctx, v)
}

func (ec *executionContext) unmarshalNCreateUserInput2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐCreateUserInput(ctx context.Context, v interface{}) (models.CreateUserInput, error) {
	return ec.unmarshalInputCreateUserInput(ctx, v)
}

func (ec *executionContext) unmarshalNDecimal2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalNDecimal2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNEditAction2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐEditAction(ctx context.Context, v interface{}) (models.EditAction, error) {
	var res models.EditAction
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNEditAction2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐEditAction(ctx context.Context, sel ast.SelectionSet, v models.EditAction) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNEvent2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐEvent(ctx context.Context, sel ast.SelectionSet, v models.Event) graphql.Marshaler {
	return ec._Event(ctx, sel, &v)
}

func (ec *executionContext) marshalNEvent2ᚕᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐEvent(ctx context.Context, sel ast.SelectionSet, v []*models.Event) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNEvent2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐEvent(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNEvent2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐEvent(ctx context.Context, sel ast.SelectionSet, v *models.Event) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Event(ctx, sel, v)
}

func (ec *executionContext) unmarshalNEventType2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐEventType(ctx context.Context, v interface{}) (models.EventType, error) {
	var res models.EventType
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNEventType2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐEventType(ctx context.Context, sel ast.SelectionSet, v models.EventType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNFloat2float64(ctx context.Context, v interface{}) (float64, error) {
	return graphql.UnmarshalFloat(v)
}

func (ec *executionContext) marshalNFloat2float64(ctx context.Context, sel ast.SelectionSet, v float64) graphql.Marshaler {
	res := graphql.MarshalFloat(v)
	if res == graphql.Null {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNGame2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐGame(ctx context.Context, v interface{}) (models.Game, error) {
	var res models.Game
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNGame2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐGame(ctx context.Context, sel ast.SelectionSet, v models.Game) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNID2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalID(v)
}

func (ec *executionContext) marshalNID2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalID(v)
	if res == graphql.Null {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v interface{}) (int, error) {
	return graphql.UnmarshalInt(v)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNJSON2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalNJSON2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) marshalNLeg2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐLeg(ctx context.Context, sel ast.SelectionSet, v models.Leg) graphql.Marshaler {
	return ec._Leg(ctx, sel, &v)
}

func (ec *executionContext) marshalNLeg2ᚕgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐLeg(ctx context.Context, sel ast.SelectionSet, v []models.Leg) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNLeg2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐLeg(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNLeg2ᚕᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐLeg(ctx context.Context, sel ast.SelectionSet, v []*models.Leg) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNLeg2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐLeg(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNLeg2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐLeg(ctx context.Context, sel ast.SelectionSet, v *models.Leg) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Leg(ctx, sel, v)
}

func (ec *executionContext) marshalNMatch2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐMatch(ctx context.Context, sel ast.SelectionSet, v models.Match) graphql.Marshaler {
	return ec._Match(ctx, sel, &v)
}

func (ec *executionContext) marshalNMatch2ᚕgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐMatch(ctx context.Context, sel ast.SelectionSet, v []models.Match) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMatch2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐMatch(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNMatch2ᚕᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐMatch(ctx context.Context, sel ast.SelectionSet, v []*models.Match) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMatch2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐMatch(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNMatch2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐMatch(ctx context.Context, sel ast.SelectionSet, v *models.Match) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Match(ctx, sel, v)
}

func (ec *executionContext) unmarshalNMatchFormat2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐMatchFormat(ctx context.Context, v interface{}) (models.MatchFormat, error) {
	var res models.MatchFormat
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNMatchFormat2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐMatchFormat(ctx context.Context, sel ast.SelectionSet, v models.MatchFormat) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNMatchInternalStatus2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐMatchInternalStatus(ctx context.Context, v interface{}) (models.MatchInternalStatus, error) {
	var res models.MatchInternalStatus
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNMatchInternalStatus2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐMatchInternalStatus(ctx context.Context, sel ast.SelectionSet, v models.MatchInternalStatus) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNOverUnderDefault2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐOverUnderDefault(ctx context.Context, sel ast.SelectionSet, v models.OverUnderDefault) graphql.Marshaler {
	return ec._OverUnderDefault(ctx, sel, &v)
}

func (ec *executionContext) marshalNOverUnderDefault2ᚕᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐOverUnderDefault(ctx context.Context, sel ast.SelectionSet, v []*models.OverUnderDefault) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNOverUnderDefault2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐOverUnderDefault(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNOverUnderDefault2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐOverUnderDefault(ctx context.Context, sel ast.SelectionSet, v *models.OverUnderDefault) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._OverUnderDefault(ctx, sel, v)
}

func (ec *executionContext) marshalNPlayer2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐPlayer(ctx context.Context, sel ast.SelectionSet, v models.Player) graphql.Marshaler {
	return ec._Player(ctx, sel, &v)
}

func (ec *executionContext) marshalNPlayer2ᚕᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐPlayer(ctx context.Context, sel ast.SelectionSet, v []*models.Player) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPlayer2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐPlayer(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNPlayer2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐPlayer(ctx context.Context, sel ast.SelectionSet, v *models.Player) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Player(ctx, sel, v)
}

func (ec *executionContext) marshalNPool2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐPool(ctx context.Context, sel ast.SelectionSet, v models.Pool) graphql.Marshaler {
	return ec._Pool(ctx, sel, &v)
}

func (ec *executionContext) marshalNPool2ᚕᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐPool(ctx context.Context, sel ast.SelectionSet, v []*models.Pool) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPool2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐPool(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNPool2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐPool(ctx context.Context, sel ast.SelectionSet, v *models.Pool) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Pool(ctx, sel, v)
}

func (ec *executionContext) unmarshalNPoolCurrency2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐPoolCurrency(ctx context.Context, v interface{}) (models.PoolCurrency, error) {
	var res models.PoolCurrency
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNPoolCurrency2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐPoolCurrency(ctx context.Context, sel ast.SelectionSet, v models.PoolCurrency) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNPoolDefault2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐPoolDefault(ctx context.Context, sel ast.SelectionSet, v models.PoolDefault) graphql.Marshaler {
	return ec._PoolDefault(ctx, sel, &v)
}

func (ec *executionContext) marshalNPoolDefault2ᚕᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐPoolDefault(ctx context.Context, sel ast.SelectionSet, v []*models.PoolDefault) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPoolDefault2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐPoolDefault(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNPoolDefault2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐPoolDefault(ctx context.Context, sel ast.SelectionSet, v *models.PoolDefault) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._PoolDefault(ctx, sel, v)
}

func (ec *executionContext) unmarshalNPoolStatus2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐPoolStatus(ctx context.Context, v interface{}) (models.PoolStatus, error) {
	var res models.PoolStatus
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNPoolStatus2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐPoolStatus(ctx context.Context, sel ast.SelectionSet, v models.PoolStatus) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNPoolType2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐPoolType(ctx context.Context, v interface{}) (models.PoolType, error) {
	var res models.PoolType
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNPoolType2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐPoolType(ctx context.Context, sel ast.SelectionSet, v models.PoolType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNSession2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐSession(ctx context.Context, sel ast.SelectionSet, v models.Session) graphql.Marshaler {
	return ec._Session(ctx, sel, &v)
}

func (ec *executionContext) marshalNSession2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐSession(ctx context.Context, sel ast.SelectionSet, v *models.Session) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Session(ctx, sel, v)
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) marshalNTeamScore2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐTeamScore(ctx context.Context, sel ast.SelectionSet, v models.TeamScore) graphql.Marshaler {
	return ec._TeamScore(ctx, sel, &v)
}

func (ec *executionContext) marshalNTeamScore2ᚕᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐTeamScore(ctx context.Context, sel ast.SelectionSet, v []*models.TeamScore) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTeamScore2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐTeamScore(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNTeamScore2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐTeamScore(ctx context.Context, sel ast.SelectionSet, v *models.TeamScore) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._TeamScore(ctx, sel, v)
}

func (ec *executionContext) marshalNTeamWinProbability2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐTeamWinProbability(ctx context.Context, sel ast.SelectionSet, v models.TeamWinProbability) graphql.Marshaler {
	return ec._TeamWinProbability(ctx, sel, &v)
}

func (ec *executionContext) marshalNTeamWinProbability2ᚕᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐTeamWinProbability(ctx context.Context, sel ast.SelectionSet, v []*models.TeamWinProbability) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTeamWinProbability2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐTeamWinProbability(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNTeamWinProbability2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐTeamWinProbability(ctx context.Context, sel ast.SelectionSet, v *models.TeamWinProbability) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._TeamWinProbability(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTime2timeᚐTime(ctx context.Context, v interface{}) (time.Time, error) {
	return graphql.UnmarshalTime(v)
}

func (ec *executionContext) marshalNTime2timeᚐTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	res := graphql.MarshalTime(v)
	if res == graphql.Null {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNUpdateCompetitorInput2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐUpdateCompetitorInput(ctx context.Context, v interface{}) (models.UpdateCompetitorInput, error) {
	return ec.unmarshalInputUpdateCompetitorInput(ctx, v)
}

func (ec *executionContext) unmarshalNUpdateConsolationPrize2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐUpdateConsolationPrize(ctx context.Context, v interface{}) (models.UpdateConsolationPrize, error) {
	return ec.unmarshalInputUpdateConsolationPrize(ctx, v)
}

func (ec *executionContext) unmarshalNUpdateConsolationPrize2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐUpdateConsolationPrize(ctx context.Context, v interface{}) (*models.UpdateConsolationPrize, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalNUpdateConsolationPrize2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐUpdateConsolationPrize(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalNUpdateEventInput2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐUpdateEventInput(ctx context.Context, v interface{}) (models.UpdateEventInput, error) {
	return ec.unmarshalInputUpdateEventInput(ctx, v)
}

func (ec *executionContext) unmarshalNUpdateLegInput2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐUpdateLegInput(ctx context.Context, v interface{}) (models.UpdateLegInput, error) {
	return ec.unmarshalInputUpdateLegInput(ctx, v)
}

func (ec *executionContext) unmarshalNUpdateMatchInput2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐUpdateMatchInput(ctx context.Context, v interface{}) (models.UpdateMatchInput, error) {
	return ec.unmarshalInputUpdateMatchInput(ctx, v)
}

func (ec *executionContext) unmarshalNUpdateOverUnderDefaultInput2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐUpdateOverUnderDefaultInput(ctx context.Context, v interface{}) (models.UpdateOverUnderDefaultInput, error) {
	return ec.unmarshalInputUpdateOverUnderDefaultInput(ctx, v)
}

func (ec *executionContext) unmarshalNUpdatePlayerInput2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐUpdatePlayerInput(ctx context.Context, v interface{}) (models.UpdatePlayerInput, error) {
	return ec.unmarshalInputUpdatePlayerInput(ctx, v)
}

func (ec *executionContext) unmarshalNUpdatePoolDefaultInput2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐUpdatePoolDefaultInput(ctx context.Context, v interface{}) (models.UpdatePoolDefaultInput, error) {
	return ec.unmarshalInputUpdatePoolDefaultInput(ctx, v)
}

func (ec *executionContext) unmarshalNUpdatePoolInput2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐUpdatePoolInput(ctx context.Context, v interface{}) (models.UpdatePoolInput, error) {
	return ec.unmarshalInputUpdatePoolInput(ctx, v)
}

func (ec *executionContext) unmarshalNUpdateTeamProbabilities2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐUpdateTeamProbabilities(ctx context.Context, v interface{}) (models.UpdateTeamProbabilities, error) {
	return ec.unmarshalInputUpdateTeamProbabilities(ctx, v)
}

func (ec *executionContext) unmarshalNUpdateTeamProbabilities2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐUpdateTeamProbabilities(ctx context.Context, v interface{}) (*models.UpdateTeamProbabilities, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalNUpdateTeamProbabilities2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐUpdateTeamProbabilities(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalNUpdateTeamScores2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐUpdateTeamScores(ctx context.Context, v interface{}) (models.UpdateTeamScores, error) {
	return ec.unmarshalInputUpdateTeamScores(ctx, v)
}

func (ec *executionContext) unmarshalNUpdateTeamScores2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐUpdateTeamScores(ctx context.Context, v interface{}) (*models.UpdateTeamScores, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalNUpdateTeamScores2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐUpdateTeamScores(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalNUpdateUserInput2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐUpdateUserInput(ctx context.Context, v interface{}) (models.UpdateUserInput, error) {
	return ec.unmarshalInputUpdateUserInput(ctx, v)
}

func (ec *executionContext) marshalNUser2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐUser(ctx context.Context, sel ast.SelectionSet, v models.User) graphql.Marshaler {
	return ec._User(ctx, sel, &v)
}

func (ec *executionContext) marshalNUser2ᚕᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐUser(ctx context.Context, sel ast.SelectionSet, v []*models.User) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUser2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNUser2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐUser(ctx context.Context, sel ast.SelectionSet, v *models.User) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._User(ctx, sel, v)
}

func (ec *executionContext) marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2ᚕstring(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2ᚕstring(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalOAccessRole2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐAccessRole(ctx context.Context, v interface{}) (models.AccessRole, error) {
	var res models.AccessRole
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalOAccessRole2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐAccessRole(ctx context.Context, sel ast.SelectionSet, v models.AccessRole) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOAccessRole2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐAccessRole(ctx context.Context, v interface{}) (*models.AccessRole, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOAccessRole2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐAccessRole(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOAccessRole2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐAccessRole(ctx context.Context, sel ast.SelectionSet, v *models.AccessRole) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOAudit2ᚕᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐAudit(ctx context.Context, sel ast.SelectionSet, v []*models.Audit) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAudit2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐAudit(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOAuditFilter2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐAuditFilter(ctx context.Context, v interface{}) (models.AuditFilter, error) {
	return ec.unmarshalInputAuditFilter(ctx, v)
}

func (ec *executionContext) unmarshalOAuditFilter2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐAuditFilter(ctx context.Context, v interface{}) (*models.AuditFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOAuditFilter2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐAuditFilter(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	return graphql.UnmarshalBoolean(v)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	return graphql.MarshalBoolean(v)
}

func (ec *executionContext) unmarshalOBoolean2ᚖbool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOBoolean2bool(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOBoolean2ᚖbool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOBoolean2bool(ctx, sel, *v)
}

func (ec *executionContext) unmarshalOCompetitorFilter2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐCompetitorFilter(ctx context.Context, v interface{}) (models.CompetitorFilter, error) {
	return ec.unmarshalInputCompetitorFilter(ctx, v)
}

func (ec *executionContext) unmarshalOCompetitorFilter2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐCompetitorFilter(ctx context.Context, v interface{}) (*models.CompetitorFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOCompetitorFilter2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐCompetitorFilter(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOConsolationPrize2ᚕᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐConsolationPrize(ctx context.Context, sel ast.SelectionSet, v []*models.ConsolationPrize) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNConsolationPrize2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐConsolationPrize(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalODecimal2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalODecimal2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return graphql.MarshalString(v)
}

func (ec *executionContext) unmarshalODecimal2ᚖstring(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalODecimal2string(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalODecimal2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalODecimal2string(ctx, sel, *v)
}

func (ec *executionContext) unmarshalOEditAction2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐEditAction(ctx context.Context, v interface{}) (models.EditAction, error) {
	var res models.EditAction
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalOEditAction2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐEditAction(ctx context.Context, sel ast.SelectionSet, v models.EditAction) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOEditAction2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐEditAction(ctx context.Context, v interface{}) (*models.EditAction, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOEditAction2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐEditAction(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOEditAction2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐEditAction(ctx context.Context, sel ast.SelectionSet, v *models.EditAction) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOEventFilter2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐEventFilter(ctx context.Context, v interface{}) (models.EventFilter, error) {
	return ec.unmarshalInputEventFilter(ctx, v)
}

func (ec *executionContext) unmarshalOEventFilter2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐEventFilter(ctx context.Context, v interface{}) (*models.EventFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOEventFilter2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐEventFilter(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOEventType2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐEventType(ctx context.Context, v interface{}) (models.EventType, error) {
	var res models.EventType
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalOEventType2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐEventType(ctx context.Context, sel ast.SelectionSet, v models.EventType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOEventType2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐEventType(ctx context.Context, v interface{}) (*models.EventType, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOEventType2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐEventType(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOEventType2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐEventType(ctx context.Context, sel ast.SelectionSet, v *models.EventType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOGame2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐGame(ctx context.Context, v interface{}) (models.Game, error) {
	var res models.Game
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalOGame2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐGame(ctx context.Context, sel ast.SelectionSet, v models.Game) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOGame2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐGame(ctx context.Context, v interface{}) (*models.Game, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOGame2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐGame(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOGame2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐGame(ctx context.Context, sel ast.SelectionSet, v *models.Game) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOID2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalID(v)
}

func (ec *executionContext) marshalOID2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return graphql.MarshalID(v)
}

func (ec *executionContext) unmarshalOID2ᚕstring(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNID2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOID2ᚕstring(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNID2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOID2ᚖstring(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOID2string(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOID2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOID2string(ctx, sel, *v)
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v interface{}) (int, error) {
	return graphql.UnmarshalInt(v)
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	return graphql.MarshalInt(v)
}

func (ec *executionContext) unmarshalOInt2ᚖint(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOInt2int(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOInt2ᚖint(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOInt2int(ctx, sel, *v)
}

func (ec *executionContext) unmarshalOLegFilter2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐLegFilter(ctx context.Context, v interface{}) (models.LegFilter, error) {
	return ec.unmarshalInputLegFilter(ctx, v)
}

func (ec *executionContext) unmarshalOLegFilter2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐLegFilter(ctx context.Context, v interface{}) (*models.LegFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOLegFilter2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐLegFilter(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOListMetadata2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐListMetadata(ctx context.Context, sel ast.SelectionSet, v models.ListMetadata) graphql.Marshaler {
	return ec._ListMetadata(ctx, sel, &v)
}

func (ec *executionContext) marshalOListMetadata2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐListMetadata(ctx context.Context, sel ast.SelectionSet, v *models.ListMetadata) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ListMetadata(ctx, sel, v)
}

func (ec *executionContext) marshalOMatch2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐMatch(ctx context.Context, sel ast.SelectionSet, v models.Match) graphql.Marshaler {
	return ec._Match(ctx, sel, &v)
}

func (ec *executionContext) marshalOMatch2ᚕgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐMatch(ctx context.Context, sel ast.SelectionSet, v []models.Match) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOMatch2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐMatch(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOMatchFilter2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐMatchFilter(ctx context.Context, v interface{}) (models.MatchFilter, error) {
	return ec.unmarshalInputMatchFilter(ctx, v)
}

func (ec *executionContext) unmarshalOMatchFilter2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐMatchFilter(ctx context.Context, v interface{}) (*models.MatchFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOMatchFilter2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐMatchFilter(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOMatchFormat2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐMatchFormat(ctx context.Context, v interface{}) (models.MatchFormat, error) {
	var res models.MatchFormat
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalOMatchFormat2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐMatchFormat(ctx context.Context, sel ast.SelectionSet, v models.MatchFormat) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOMatchFormat2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐMatchFormat(ctx context.Context, v interface{}) (*models.MatchFormat, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOMatchFormat2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐMatchFormat(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOMatchFormat2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐMatchFormat(ctx context.Context, sel ast.SelectionSet, v *models.MatchFormat) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOMatchInternalStatus2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐMatchInternalStatus(ctx context.Context, v interface{}) (models.MatchInternalStatus, error) {
	var res models.MatchInternalStatus
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalOMatchInternalStatus2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐMatchInternalStatus(ctx context.Context, sel ast.SelectionSet, v models.MatchInternalStatus) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOMatchInternalStatus2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐMatchInternalStatus(ctx context.Context, v interface{}) (*models.MatchInternalStatus, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOMatchInternalStatus2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐMatchInternalStatus(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOMatchInternalStatus2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐMatchInternalStatus(ctx context.Context, sel ast.SelectionSet, v *models.MatchInternalStatus) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOOverUnderDefaultFilter2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐOverUnderDefaultFilter(ctx context.Context, v interface{}) (models.OverUnderDefaultFilter, error) {
	return ec.unmarshalInputOverUnderDefaultFilter(ctx, v)
}

func (ec *executionContext) unmarshalOOverUnderDefaultFilter2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐOverUnderDefaultFilter(ctx context.Context, v interface{}) (*models.OverUnderDefaultFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOOverUnderDefaultFilter2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐOverUnderDefaultFilter(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOPlayerFilter2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐPlayerFilter(ctx context.Context, v interface{}) (models.PlayerFilter, error) {
	return ec.unmarshalInputPlayerFilter(ctx, v)
}

func (ec *executionContext) unmarshalOPlayerFilter2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐPlayerFilter(ctx context.Context, v interface{}) (*models.PlayerFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOPlayerFilter2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐPlayerFilter(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOPoolCurrency2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐPoolCurrency(ctx context.Context, v interface{}) (models.PoolCurrency, error) {
	var res models.PoolCurrency
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalOPoolCurrency2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐPoolCurrency(ctx context.Context, sel ast.SelectionSet, v models.PoolCurrency) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOPoolCurrency2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐPoolCurrency(ctx context.Context, v interface{}) (*models.PoolCurrency, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOPoolCurrency2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐPoolCurrency(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOPoolCurrency2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐPoolCurrency(ctx context.Context, sel ast.SelectionSet, v *models.PoolCurrency) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOPoolDefaultFilter2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐPoolDefaultFilter(ctx context.Context, v interface{}) (models.PoolDefaultFilter, error) {
	return ec.unmarshalInputPoolDefaultFilter(ctx, v)
}

func (ec *executionContext) unmarshalOPoolDefaultFilter2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐPoolDefaultFilter(ctx context.Context, v interface{}) (*models.PoolDefaultFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOPoolDefaultFilter2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐPoolDefaultFilter(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOPoolFilter2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐPoolFilter(ctx context.Context, v interface{}) (models.PoolFilter, error) {
	return ec.unmarshalInputPoolFilter(ctx, v)
}

func (ec *executionContext) unmarshalOPoolFilter2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐPoolFilter(ctx context.Context, v interface{}) (*models.PoolFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOPoolFilter2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐPoolFilter(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOPoolStatus2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐPoolStatus(ctx context.Context, v interface{}) (models.PoolStatus, error) {
	var res models.PoolStatus
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalOPoolStatus2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐPoolStatus(ctx context.Context, sel ast.SelectionSet, v models.PoolStatus) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOPoolStatus2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐPoolStatus(ctx context.Context, v interface{}) (*models.PoolStatus, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOPoolStatus2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐPoolStatus(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOPoolStatus2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐPoolStatus(ctx context.Context, sel ast.SelectionSet, v *models.PoolStatus) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOPoolType2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐPoolType(ctx context.Context, v interface{}) (models.PoolType, error) {
	var res models.PoolType
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalOPoolType2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐPoolType(ctx context.Context, sel ast.SelectionSet, v models.PoolType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOPoolType2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐPoolType(ctx context.Context, v interface{}) (*models.PoolType, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOPoolType2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐPoolType(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOPoolType2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐPoolType(ctx context.Context, sel ast.SelectionSet, v *models.PoolType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return graphql.MarshalString(v)
}

func (ec *executionContext) unmarshalOString2ᚖstring(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOString2string(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOString2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOString2string(ctx, sel, *v)
}

func (ec *executionContext) unmarshalOTime2timeᚐTime(ctx context.Context, v interface{}) (time.Time, error) {
	return graphql.UnmarshalTime(v)
}

func (ec *executionContext) marshalOTime2timeᚐTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	return graphql.MarshalTime(v)
}

func (ec *executionContext) unmarshalOTime2ᚖtimeᚐTime(ctx context.Context, v interface{}) (*time.Time, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOTime2timeᚐTime(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOTime2ᚖtimeᚐTime(ctx context.Context, sel ast.SelectionSet, v *time.Time) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOTime2timeᚐTime(ctx, sel, *v)
}

func (ec *executionContext) unmarshalOUpdateConsolationPrize2ᚕᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐUpdateConsolationPrize(ctx context.Context, v interface{}) ([]*models.UpdateConsolationPrize, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*models.UpdateConsolationPrize, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNUpdateConsolationPrize2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐUpdateConsolationPrize(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOUpdateTeamProbabilities2ᚕᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐUpdateTeamProbabilities(ctx context.Context, v interface{}) ([]*models.UpdateTeamProbabilities, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*models.UpdateTeamProbabilities, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNUpdateTeamProbabilities2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐUpdateTeamProbabilities(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOUpdateTeamScores2ᚕᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐUpdateTeamScores(ctx context.Context, v interface{}) ([]*models.UpdateTeamScores, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*models.UpdateTeamScores, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNUpdateTeamScores2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐUpdateTeamScores(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOUserFilter2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐUserFilter(ctx context.Context, v interface{}) (models.UserFilter, error) {
	return ec.unmarshalInputUserFilter(ctx, v)
}

func (ec *executionContext) unmarshalOUserFilter2ᚖgitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐUserFilter(ctx context.Context, v interface{}) (*models.UserFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOUserFilter2gitlabᚗcomᚋsiimplᚋespᚑbettingᚋbettingᚑfeedᚋpkgᚋmodelsᚐUserFilter(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Schema2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx context.Context, sel ast.SelectionSet, v introspection.Schema) graphql.Marshaler {
	return ec.___Schema(ctx, sel, &v)
}

func (ec *executionContext) marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************

// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graphql

import (
	"bytes"
	"context"
	"errors"
	"strconv"
	"sync"
	"sync/atomic"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/vektah/gqlparser"
	"github.com/vektah/gqlparser/ast"
	"gitlab.com/siimpl/esp-betting/betting-feed/pkg/models"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Audit() AuditResolver
	Competitor() CompetitorResolver
	ConsolationPrize() ConsolationPrizeResolver
	Event() EventResolver
	Leg() LegResolver
	Match() MatchResolver
	Mutation() MutationResolver
	OverUnderDefault() OverUnderDefaultResolver
	Player() PlayerResolver
	Pool() PoolResolver
	PoolDefault() PoolDefaultResolver
	Query() QueryResolver
	User() UserResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	Audit struct {
		Content    func(childComplexity int) int
		EditAction func(childComplexity int) int
		ID         func(childComplexity int) int
		TargetID   func(childComplexity int) int
		TargetType func(childComplexity int) int
		Time       func(childComplexity int) int
		User       func(childComplexity int) int
	}

	Competitor struct {
		ExternalID func(childComplexity int) int
		ID         func(childComplexity int) int
		Logo       func(childComplexity int) int
		Matches    func(childComplexity int) int
		Name       func(childComplexity int) int
	}

	ConsolationPrize struct {
		Allocation func(childComplexity int) int
		CarryIn    func(childComplexity int) int
		Guarantee  func(childComplexity int) int
	}

	Event struct {
		EndDate         func(childComplexity int) int
		ExternalID      func(childComplexity int) int
		Game            func(childComplexity int) int
		ID              func(childComplexity int) int
		IsActive        func(childComplexity int) int
		IsAutogenerated func(childComplexity int) int
		Logo            func(childComplexity int) int
		Matches         func(childComplexity int) int
		Name            func(childComplexity int) int
		StartDate       func(childComplexity int) int
		Type            func(childComplexity int) int
	}

	Leg struct {
		ID           func(childComplexity int) int
		LastSyncTime func(childComplexity int) int
		MatchID      func(childComplexity int) int
		PoolID       func(childComplexity int) int
		Threshold    func(childComplexity int) int
	}

	ListMetadata struct {
		Count func(childComplexity int) int
	}

	Match struct {
		Competitors          func(childComplexity int) int
		Description          func(childComplexity int) int
		EventID              func(childComplexity int) int
		EventStage           func(childComplexity int) int
		ExternalID           func(childComplexity int) int
		Format               func(childComplexity int) int
		History              func(childComplexity int) int
		ID                   func(childComplexity int) int
		InternalStatus       func(childComplexity int) int
		IsActive             func(childComplexity int) int
		IsAutogenerated      func(childComplexity int) int
		Name                 func(childComplexity int) int
		StartTime            func(childComplexity int) int
		Statistics           func(childComplexity int) int
		TeamOuScores         func(childComplexity int) int
		TeamScores           func(childComplexity int) int
		TeamWinProbabilities func(childComplexity int) int
	}

	Mutation struct {
		CreateCompetitor       func(childComplexity int, input models.CreateCompetitorInput) int
		CreateEvent            func(childComplexity int, input models.CreateEventInput) int
		CreateLeg              func(childComplexity int, input models.CreateLegInput) int
		CreateMatch            func(childComplexity int, input models.CreateMatchInput) int
		CreateOverUnderDefault func(childComplexity int, input models.CreateOverUnderDefaultInput) int
		CreatePlayer           func(childComplexity int, input models.CreatePlayerInput) int
		CreatePool             func(childComplexity int, input models.CreatePoolInput) int
		CreatePoolDefault      func(childComplexity int, input models.CreatePoolDefaultInput) int
		CreateSession          func(childComplexity int, input models.AuthInput) int
		CreateUser             func(childComplexity int, input models.CreateUserInput) int
		DeleteCompetitor       func(childComplexity int, id string) int
		DeleteEvent            func(childComplexity int, id string) int
		DeleteLeg              func(childComplexity int, id string) int
		DeleteMatch            func(childComplexity int, id string) int
		DeleteOverUnderDefault func(childComplexity int, id string) int
		DeletePlayer           func(childComplexity int, id string) int
		DeletePool             func(childComplexity int, id string) int
		DeletePoolDefault      func(childComplexity int, id string) int
		UpdateCompetitor       func(childComplexity int, input models.UpdateCompetitorInput) int
		UpdateEvent            func(childComplexity int, input models.UpdateEventInput) int
		UpdateLeg              func(childComplexity int, input models.UpdateLegInput) int
		UpdateMatch            func(childComplexity int, input models.UpdateMatchInput) int
		UpdateOverUnderDefault func(childComplexity int, input models.UpdateOverUnderDefaultInput) int
		UpdatePlayer           func(childComplexity int, input models.UpdatePlayerInput) int
		UpdatePool             func(childComplexity int, input models.UpdatePoolInput) int
		UpdatePoolDefault      func(childComplexity int, input models.UpdatePoolDefaultInput) int
		UpdateUser             func(childComplexity int, input models.UpdateUserInput) int
	}

	OverUnderDefault struct {
		EvenThreshold    func(childComplexity int) int
		FavoredThreshold func(childComplexity int) int
		Game             func(childComplexity int) int
		ID               func(childComplexity int) int
		MatchFormat      func(childComplexity int) int
		Note             func(childComplexity int) int
	}

	Player struct {
		ExternalID func(childComplexity int) int
		ID         func(childComplexity int) int
		Name       func(childComplexity int) int
		Nickname   func(childComplexity int) int
		TeamID     func(childComplexity int) int
	}

	Pool struct {
		Allocation           func(childComplexity int) int
		CarryIn              func(childComplexity int) int
		ConsolationPrizes    func(childComplexity int) int
		Currency             func(childComplexity int) int
		Game                 func(childComplexity int) int
		Guarantee            func(childComplexity int) int
		ID                   func(childComplexity int) int
		IsActive             func(childComplexity int) int
		IsAutogenerated      func(childComplexity int) int
		LastSyncTime         func(childComplexity int) int
		Legs                 func(childComplexity int) int
		MaxUnitPerLine       func(childComplexity int) int
		MaxUnitPerTicket     func(childComplexity int) int
		MinUnitPerLine       func(childComplexity int) int
		MinUnitPerTicket     func(childComplexity int) int
		Name                 func(childComplexity int) int
		Note                 func(childComplexity int) int
		SyncedColossusStatus func(childComplexity int) int
		Type                 func(childComplexity int) int
		UnitValue            func(childComplexity int) int
	}

	PoolDefault struct {
		Allocation       func(childComplexity int) int
		CarryIn          func(childComplexity int) int
		Currency         func(childComplexity int) int
		Game             func(childComplexity int) int
		Guarantee        func(childComplexity int) int
		ID               func(childComplexity int) int
		LegCount         func(childComplexity int) int
		MaxUnitPerLine   func(childComplexity int) int
		MaxUnitPerTicket func(childComplexity int) int
		MinUnitPerLine   func(childComplexity int) int
		MinUnitPerTicket func(childComplexity int) int
		Note             func(childComplexity int) int
		Type             func(childComplexity int) int
		UnitValue        func(childComplexity int) int
	}

	Query struct {
		AllAudits                 func(childComplexity int, filter *models.AuditFilter, page *int, perPage *int, sortField *string, sortOrder *string) int
		AllCompetitors            func(childComplexity int, filter *models.CompetitorFilter, page *int, perPage *int, sortField *string, sortOrder *string) int
		AllEvents                 func(childComplexity int, filter *models.EventFilter, page *int, perPage *int, sortField *string, sortOrder *string) int
		AllLegs                   func(childComplexity int, filter *models.LegFilter, page *int, perPage *int, sortField *string, sortOrder *string) int
		AllMatches                func(childComplexity int, filter *models.MatchFilter, page *int, perPage *int, sortField *string, sortOrder *string) int
		AllOverUnderDefaults      func(childComplexity int, filter *models.OverUnderDefaultFilter, page *int, perPage *int, sortField *string, sortOrder *string) int
		AllPlayers                func(childComplexity int, filter *models.PlayerFilter, page *int, perPage *int, sortField *string, sortOrder *string) int
		AllPoolDefaults           func(childComplexity int, filter *models.PoolDefaultFilter, page *int, perPage *int, sortField *string, sortOrder *string) int
		AllPools                  func(childComplexity int, filter *models.PoolFilter, page *int, perPage *int, sortField *string, sortOrder *string) int
		AllUsers                  func(childComplexity int, filter *models.UserFilter, page *int, perPage *int, sortField *string, sortOrder *string) int
		Audit                     func(childComplexity int, id string) int
		Competitor                func(childComplexity int, id string) int
		Event                     func(childComplexity int, id string) int
		Leg                       func(childComplexity int, id string) int
		Match                     func(childComplexity int, id string) int
		OverUnderDefault          func(childComplexity int, id string) int
		Player                    func(childComplexity int, id string) int
		Pool                      func(childComplexity int, id string) int
		PoolDefault               func(childComplexity int, id string) int
		User                      func(childComplexity int, id string) int
		_allAuditsMeta            func(childComplexity int, filter *models.AuditFilter, page *int, perPage *int) int
		_allCompetitorsMeta       func(childComplexity int, filter *models.CompetitorFilter, page *int, perPage *int) int
		_allEventsMeta            func(childComplexity int, filter *models.EventFilter, page *int, perPage *int) int
		_allLegsMeta              func(childComplexity int, filter *models.LegFilter, page *int, perPage *int) int
		_allMatchesMeta           func(childComplexity int, filter *models.MatchFilter, page *int, perPage *int) int
		_allOverUnderDefaultsMeta func(childComplexity int, filter *models.OverUnderDefaultFilter, page *int, perPage *int) int
		_allPlayersMeta           func(childComplexity int, filter *models.PlayerFilter, page *int, perPage *int) int
		_allPoolDefaultsMeta      func(childComplexity int, filter *models.PoolDefaultFilter, page *int, perPage *int) int
		_allPoolsMeta             func(childComplexity int, filter *models.PoolFilter, page *int, perPage *int) int
		_allUsersMeta             func(childComplexity int, filter *models.UserFilter, page *int, perPage *int) int
	}

	Session struct {
		Token func(childComplexity int) int
	}

	TeamProbabilities struct {
		Probability func(childComplexity int) int
		TeamID      func(childComplexity int) int
	}

	TeamScore struct {
		Score  func(childComplexity int) int
		TeamID func(childComplexity int) int
	}

	TeamScores struct {
		Score  func(childComplexity int) int
		TeamID func(childComplexity int) int
	}

	TeamWinProbability struct {
		Probability func(childComplexity int) int
		TeamID      func(childComplexity int) int
	}

	User struct {
		AccessRole func(childComplexity int) int
		Email      func(childComplexity int) int
		ID         func(childComplexity int) int
		Token      func(childComplexity int) int
	}
}

type AuditResolver interface {
	ID(ctx context.Context, obj *models.Audit) (string, error)

	TargetID(ctx context.Context, obj *models.Audit) (string, error)

	User(ctx context.Context, obj *models.Audit) (*models.User, error)
}
type CompetitorResolver interface {
	ID(ctx context.Context, obj *models.Competitor) (string, error)
}
type ConsolationPrizeResolver interface {
	Guarantee(ctx context.Context, obj *models.ConsolationPrize) (string, error)
	CarryIn(ctx context.Context, obj *models.ConsolationPrize) (string, error)
	Allocation(ctx context.Context, obj *models.ConsolationPrize) (string, error)
}
type EventResolver interface {
	ID(ctx context.Context, obj *models.Event) (string, error)
}
type LegResolver interface {
	ID(ctx context.Context, obj *models.Leg) (string, error)

	Threshold(ctx context.Context, obj *models.Leg) (string, error)
	MatchID(ctx context.Context, obj *models.Leg) (string, error)
	PoolID(ctx context.Context, obj *models.Leg) (string, error)
}
type MatchResolver interface {
	ID(ctx context.Context, obj *models.Match) (string, error)
	EventID(ctx context.Context, obj *models.Match) (string, error)

	Statistics(ctx context.Context, obj *models.Match) (string, error)
	TeamScores(ctx context.Context, obj *models.Match) ([]*models.TeamScore, error)
	TeamOuScores(ctx context.Context, obj *models.Match) ([]*models.TeamScore, error)
	TeamWinProbabilities(ctx context.Context, obj *models.Match) ([]*models.TeamWinProbability, error)

	History(ctx context.Context, obj *models.Match) ([]*models.Audit, error)
}
type MutationResolver interface {
	CreateUser(ctx context.Context, input models.CreateUserInput) (*models.User, error)
	UpdateUser(ctx context.Context, input models.UpdateUserInput) (*models.User, error)
	CreateSession(ctx context.Context, input models.AuthInput) (*models.Session, error)
	CreateEvent(ctx context.Context, input models.CreateEventInput) (*models.Event, error)
	UpdateEvent(ctx context.Context, input models.UpdateEventInput) (*models.Event, error)
	DeleteEvent(ctx context.Context, id string) (*models.Event, error)
	CreateMatch(ctx context.Context, input models.CreateMatchInput) (*models.Match, error)
	UpdateMatch(ctx context.Context, input models.UpdateMatchInput) (*models.Match, error)
	DeleteMatch(ctx context.Context, id string) (*models.Match, error)
	CreateCompetitor(ctx context.Context, input models.CreateCompetitorInput) (*models.Competitor, error)
	UpdateCompetitor(ctx context.Context, input models.UpdateCompetitorInput) (*models.Competitor, error)
	DeleteCompetitor(ctx context.Context, id string) (*models.Competitor, error)
	CreatePlayer(ctx context.Context, input models.CreatePlayerInput) (*models.Player, error)
	UpdatePlayer(ctx context.Context, input models.UpdatePlayerInput) (*models.Player, error)
	DeletePlayer(ctx context.Context, id string) (*models.Player, error)
	CreatePool(ctx context.Context, input models.CreatePoolInput) (*models.Pool, error)
	UpdatePool(ctx context.Context, input models.UpdatePoolInput) (*models.Pool, error)
	DeletePool(ctx context.Context, id string) (*models.Pool, error)
	CreatePoolDefault(ctx context.Context, input models.CreatePoolDefaultInput) (*models.PoolDefault, error)
	UpdatePoolDefault(ctx context.Context, input models.UpdatePoolDefaultInput) (*models.PoolDefault, error)
	DeletePoolDefault(ctx context.Context, id string) (*models.PoolDefault, error)
	CreateLeg(ctx context.Context, input models.CreateLegInput) (*models.Leg, error)
	UpdateLeg(ctx context.Context, input models.UpdateLegInput) (*models.Leg, error)
	DeleteLeg(ctx context.Context, id string) (*models.Leg, error)
	CreateOverUnderDefault(ctx context.Context, input models.CreateOverUnderDefaultInput) (*models.OverUnderDefault, error)
	UpdateOverUnderDefault(ctx context.Context, input models.UpdateOverUnderDefaultInput) (*models.OverUnderDefault, error)
	DeleteOverUnderDefault(ctx context.Context, id string) (*models.OverUnderDefault, error)
}
type OverUnderDefaultResolver interface {
	ID(ctx context.Context, obj *models.OverUnderDefault) (string, error)

	EvenThreshold(ctx context.Context, obj *models.OverUnderDefault) (string, error)
	FavoredThreshold(ctx context.Context, obj *models.OverUnderDefault) (string, error)
}
type PlayerResolver interface {
	ID(ctx context.Context, obj *models.Player) (string, error)

	TeamID(ctx context.Context, obj *models.Player) (string, error)
}
type PoolResolver interface {
	ID(ctx context.Context, obj *models.Pool) (string, error)

	Guarantee(ctx context.Context, obj *models.Pool) (string, error)
	CarryIn(ctx context.Context, obj *models.Pool) (string, error)
	Allocation(ctx context.Context, obj *models.Pool) (string, error)

	UnitValue(ctx context.Context, obj *models.Pool) (string, error)
	MinUnitPerLine(ctx context.Context, obj *models.Pool) (string, error)
	MaxUnitPerLine(ctx context.Context, obj *models.Pool) (string, error)
	MinUnitPerTicket(ctx context.Context, obj *models.Pool) (string, error)
	MaxUnitPerTicket(ctx context.Context, obj *models.Pool) (string, error)

	ConsolationPrizes(ctx context.Context, obj *models.Pool) ([]*models.ConsolationPrize, error)
}
type PoolDefaultResolver interface {
	ID(ctx context.Context, obj *models.PoolDefault) (string, error)
	LegCount(ctx context.Context, obj *models.PoolDefault) (string, error)

	Guarantee(ctx context.Context, obj *models.PoolDefault) (string, error)
	CarryIn(ctx context.Context, obj *models.PoolDefault) (string, error)
	Allocation(ctx context.Context, obj *models.PoolDefault) (string, error)
	UnitValue(ctx context.Context, obj *models.PoolDefault) (string, error)
	MinUnitPerLine(ctx context.Context, obj *models.PoolDefault) (string, error)
	MaxUnitPerLine(ctx context.Context, obj *models.PoolDefault) (string, error)
	MinUnitPerTicket(ctx context.Context, obj *models.PoolDefault) (string, error)
	MaxUnitPerTicket(ctx context.Context, obj *models.PoolDefault) (string, error)
}
type QueryResolver interface {
	Event(ctx context.Context, id string) (*models.Event, error)
	AllEvents(ctx context.Context, filter *models.EventFilter, page *int, perPage *int, sortField *string, sortOrder *string) ([]*models.Event, error)
	_allEventsMeta(ctx context.Context, filter *models.EventFilter, page *int, perPage *int) (*models.ListMetadata, error)
	Pool(ctx context.Context, id string) (*models.Pool, error)
	AllPools(ctx context.Context, filter *models.PoolFilter, page *int, perPage *int, sortField *string, sortOrder *string) ([]*models.Pool, error)
	_allPoolsMeta(ctx context.Context, filter *models.PoolFilter, page *int, perPage *int) (*models.ListMetadata, error)
	PoolDefault(ctx context.Context, id string) (*models.PoolDefault, error)
	AllPoolDefaults(ctx context.Context, filter *models.PoolDefaultFilter, page *int, perPage *int, sortField *string, sortOrder *string) ([]*models.PoolDefault, error)
	_allPoolDefaultsMeta(ctx context.Context, filter *models.PoolDefaultFilter, page *int, perPage *int) (*models.ListMetadata, error)
	Leg(ctx context.Context, id string) (*models.Leg, error)
	AllLegs(ctx context.Context, filter *models.LegFilter, page *int, perPage *int, sortField *string, sortOrder *string) ([]*models.Leg, error)
	_allLegsMeta(ctx context.Context, filter *models.LegFilter, page *int, perPage *int) (*models.ListMetadata, error)
	Match(ctx context.Context, id string) (*models.Match, error)
	AllMatches(ctx context.Context, filter *models.MatchFilter, page *int, perPage *int, sortField *string, sortOrder *string) ([]*models.Match, error)
	_allMatchesMeta(ctx context.Context, filter *models.MatchFilter, page *int, perPage *int) (*models.ListMetadata, error)
	Competitor(ctx context.Context, id string) (*models.Competitor, error)
	AllCompetitors(ctx context.Context, filter *models.CompetitorFilter, page *int, perPage *int, sortField *string, sortOrder *string) ([]*models.Competitor, error)
	_allCompetitorsMeta(ctx context.Context, filter *models.CompetitorFilter, page *int, perPage *int) (*models.ListMetadata, error)
	Player(ctx context.Context, id string) (*models.Player, error)
	AllPlayers(ctx context.Context, filter *models.PlayerFilter, page *int, perPage *int, sortField *string, sortOrder *string) ([]*models.Player, error)
	_allPlayersMeta(ctx context.Context, filter *models.PlayerFilter, page *int, perPage *int) (*models.ListMetadata, error)
	User(ctx context.Context, id string) (*models.User, error)
	AllUsers(ctx context.Context, filter *models.UserFilter, page *int, perPage *int, sortField *string, sortOrder *string) ([]*models.User, error)
	_allUsersMeta(ctx context.Context, filter *models.UserFilter, page *int, perPage *int) (*models.ListMetadata, error)
	Audit(ctx context.Context, id string) (*models.Audit, error)
	AllAudits(ctx context.Context, filter *models.AuditFilter, page *int, perPage *int, sortField *string, sortOrder *string) ([]*models.Audit, error)
	_allAuditsMeta(ctx context.Context, filter *models.AuditFilter, page *int, perPage *int) (*models.ListMetadata, error)
	OverUnderDefault(ctx context.Context, id string) (*models.OverUnderDefault, error)
	AllOverUnderDefaults(ctx context.Context, filter *models.OverUnderDefaultFilter, page *int, perPage *int, sortField *string, sortOrder *string) ([]*models.OverUnderDefault, error)
	_allOverUnderDefaultsMeta(ctx context.Context, filter *models.OverUnderDefaultFilter, page *int, perPage *int) (*models.ListMetadata, error)
}
type UserResolver interface {
	ID(ctx context.Context, obj *models.User) (string, error)
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec
	switch typeName + "." + field {

	case "Audit.content":
		if e.complexity.Audit.Content == nil {
			break
		}

		return e.complexity.Audit.Content(childComplexity), true

	case "Audit.editAction":
		if e.complexity.Audit.EditAction == nil {
			break
		}

		return e.complexity.Audit.EditAction(childComplexity), true

	case "Audit.id":
		if e.complexity.Audit.ID == nil {
			break
		}

		return e.complexity.Audit.ID(childComplexity), true

	case "Audit.targetId":
		if e.complexity.Audit.TargetID == nil {
			break
		}

		return e.complexity.Audit.TargetID(childComplexity), true

	case "Audit.targetType":
		if e.complexity.Audit.TargetType == nil {
			break
		}

		return e.complexity.Audit.TargetType(childComplexity), true

	case "Audit.time":
		if e.complexity.Audit.Time == nil {
			break
		}

		return e.complexity.Audit.Time(childComplexity), true

	case "Audit.user":
		if e.complexity.Audit.User == nil {
			break
		}

		return e.complexity.Audit.User(childComplexity), true

	case "Competitor.externalId":
		if e.complexity.Competitor.ExternalID == nil {
			break
		}

		return e.complexity.Competitor.ExternalID(childComplexity), true

	case "Competitor.id":
		if e.complexity.Competitor.ID == nil {
			break
		}

		return e.complexity.Competitor.ID(childComplexity), true

	case "Competitor.logo":
		if e.complexity.Competitor.Logo == nil {
			break
		}

		return e.complexity.Competitor.Logo(childComplexity), true

	case "Competitor.matches":
		if e.complexity.Competitor.Matches == nil {
			break
		}

		return e.complexity.Competitor.Matches(childComplexity), true

	case "Competitor.name":
		if e.complexity.Competitor.Name == nil {
			break
		}

		return e.complexity.Competitor.Name(childComplexity), true

	case "ConsolationPrize.allocation":
		if e.complexity.ConsolationPrize.Allocation == nil {
			break
		}

		return e.complexity.ConsolationPrize.Allocation(childComplexity), true

	case "ConsolationPrize.carryIn":
		if e.complexity.ConsolationPrize.CarryIn == nil {
			break
		}

		return e.complexity.ConsolationPrize.CarryIn(childComplexity), true

	case "ConsolationPrize.guarantee":
		if e.complexity.ConsolationPrize.Guarantee == nil {
			break
		}

		return e.complexity.ConsolationPrize.Guarantee(childComplexity), true

	case "Event.endDate":
		if e.complexity.Event.EndDate == nil {
			break
		}

		return e.complexity.Event.EndDate(childComplexity), true

	case "Event.externalId":
		if e.complexity.Event.ExternalID == nil {
			break
		}

		return e.complexity.Event.ExternalID(childComplexity), true

	case "Event.game":
		if e.complexity.Event.Game == nil {
			break
		}

		return e.complexity.Event.Game(childComplexity), true

	case "Event.id":
		if e.complexity.Event.ID == nil {
			break
		}

		return e.complexity.Event.ID(childComplexity), true

	case "Event.isActive":
		if e.complexity.Event.IsActive == nil {
			break
		}

		return e.complexity.Event.IsActive(childComplexity), true

	case "Event.isAutogenerated":
		if e.complexity.Event.IsAutogenerated == nil {
			break
		}

		return e.complexity.Event.IsAutogenerated(childComplexity), true

	case "Event.logo":
		if e.complexity.Event.Logo == nil {
			break
		}

		return e.complexity.Event.Logo(childComplexity), true

	case "Event.matches":
		if e.complexity.Event.Matches == nil {
			break
		}

		return e.complexity.Event.Matches(childComplexity), true

	case "Event.name":
		if e.complexity.Event.Name == nil {
			break
		}

		return e.complexity.Event.Name(childComplexity), true

	case "Event.startDate":
		if e.complexity.Event.StartDate == nil {
			break
		}

		return e.complexity.Event.StartDate(childComplexity), true

	case "Event.type":
		if e.complexity.Event.Type == nil {
			break
		}

		return e.complexity.Event.Type(childComplexity), true

	case "Leg.id":
		if e.complexity.Leg.ID == nil {
			break
		}

		return e.complexity.Leg.ID(childComplexity), true

	case "Leg.lastSyncTime":
		if e.complexity.Leg.LastSyncTime == nil {
			break
		}

		return e.complexity.Leg.LastSyncTime(childComplexity), true

	case "Leg.matchId":
		if e.complexity.Leg.MatchID == nil {
			break
		}

		return e.complexity.Leg.MatchID(childComplexity), true

	case "Leg.poolId":
		if e.complexity.Leg.PoolID == nil {
			break
		}

		return e.complexity.Leg.PoolID(childComplexity), true

	case "Leg.threshold":
		if e.complexity.Leg.Threshold == nil {
			break
		}

		return e.complexity.Leg.Threshold(childComplexity), true

	case "ListMetadata.count":
		if e.complexity.ListMetadata.Count == nil {
			break
		}

		return e.complexity.ListMetadata.Count(childComplexity), true

	case "Match.competitors":
		if e.complexity.Match.Competitors == nil {
			break
		}

		return e.complexity.Match.Competitors(childComplexity), true

	case "Match.description":
		if e.complexity.Match.Description == nil {
			break
		}

		return e.complexity.Match.Description(childComplexity), true

	case "Match.eventId":
		if e.complexity.Match.EventID == nil {
			break
		}

		return e.complexity.Match.EventID(childComplexity), true

	case "Match.eventStage":
		if e.complexity.Match.EventStage == nil {
			break
		}

		return e.complexity.Match.EventStage(childComplexity), true

	case "Match.externalId":
		if e.complexity.Match.ExternalID == nil {
			break
		}

		return e.complexity.Match.ExternalID(childComplexity), true

	case "Match.format":
		if e.complexity.Match.Format == nil {
			break
		}

		return e.complexity.Match.Format(childComplexity), true

	case "Match.history":
		if e.complexity.Match.History == nil {
			break
		}

		return e.complexity.Match.History(childComplexity), true

	case "Match.id":
		if e.complexity.Match.ID == nil {
			break
		}

		return e.complexity.Match.ID(childComplexity), true

	case "Match.internalStatus":
		if e.complexity.Match.InternalStatus == nil {
			break
		}

		return e.complexity.Match.InternalStatus(childComplexity), true

	case "Match.isActive":
		if e.complexity.Match.IsActive == nil {
			break
		}

		return e.complexity.Match.IsActive(childComplexity), true

	case "Match.isAutogenerated":
		if e.complexity.Match.IsAutogenerated == nil {
			break
		}

		return e.complexity.Match.IsAutogenerated(childComplexity), true

	case "Match.name":
		if e.complexity.Match.Name == nil {
			break
		}

		return e.complexity.Match.Name(childComplexity), true

	case "Match.startTime":
		if e.complexity.Match.StartTime == nil {
			break
		}

		return e.complexity.Match.StartTime(childComplexity), true

	case "Match.statistics":
		if e.complexity.Match.Statistics == nil {
			break
		}

		return e.complexity.Match.Statistics(childComplexity), true

	case "Match.teamOuScores":
		if e.complexity.Match.TeamOuScores == nil {
			break
		}

		return e.complexity.Match.TeamOuScores(childComplexity), true

	case "Match.teamScores":
		if e.complexity.Match.TeamScores == nil {
			break
		}

		return e.complexity.Match.TeamScores(childComplexity), true

	case "Match.teamWinProbabilities":
		if e.complexity.Match.TeamWinProbabilities == nil {
			break
		}

		return e.complexity.Match.TeamWinProbabilities(childComplexity), true

	case "Mutation.createCompetitor":
		if e.complexity.Mutation.CreateCompetitor == nil {
			break
		}

		args, err := ec.field_Mutation_createCompetitor_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateCompetitor(childComplexity, args["input"].(models.CreateCompetitorInput)), true

	case "Mutation.createEvent":
		if e.complexity.Mutation.CreateEvent == nil {
			break
		}

		args, err := ec.field_Mutation_createEvent_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateEvent(childComplexity, args["input"].(models.CreateEventInput)), true

	case "Mutation.createLeg":
		if e.complexity.Mutation.CreateLeg == nil {
			break
		}

		args, err := ec.field_Mutation_createLeg_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateLeg(childComplexity, args["input"].(models.CreateLegInput)), true

	case "Mutation.createMatch":
		if e.complexity.Mutation.CreateMatch == nil {
			break
		}

		args, err := ec.field_Mutation_createMatch_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateMatch(childComplexity, args["input"].(models.CreateMatchInput)), true

	case "Mutation.createOverUnderDefault":
		if e.complexity.Mutation.CreateOverUnderDefault == nil {
			break
		}

		args, err := ec.field_Mutation_createOverUnderDefault_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateOverUnderDefault(childComplexity, args["input"].(models.CreateOverUnderDefaultInput)), true

	case "Mutation.createPlayer":
		if e.complexity.Mutation.CreatePlayer == nil {
			break
		}

		args, err := ec.field_Mutation_createPlayer_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreatePlayer(childComplexity, args["input"].(models.CreatePlayerInput)), true

	case "Mutation.createPool":
		if e.complexity.Mutation.CreatePool == nil {
			break
		}

		args, err := ec.field_Mutation_createPool_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreatePool(childComplexity, args["input"].(models.CreatePoolInput)), true

	case "Mutation.createPoolDefault":
		if e.complexity.Mutation.CreatePoolDefault == nil {
			break
		}

		args, err := ec.field_Mutation_createPoolDefault_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreatePoolDefault(childComplexity, args["input"].(models.CreatePoolDefaultInput)), true

	case "Mutation.createSession":
		if e.complexity.Mutation.CreateSession == nil {
			break
		}

		args, err := ec.field_Mutation_createSession_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateSession(childComplexity, args["input"].(models.AuthInput)), true

	case "Mutation.createUser":
		if e.complexity.Mutation.CreateUser == nil {
			break
		}

		args, err := ec.field_Mutation_createUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateUser(childComplexity, args["input"].(models.CreateUserInput)), true

	case "Mutation.deleteCompetitor":
		if e.complexity.Mutation.DeleteCompetitor == nil {
			break
		}

		args, err := ec.field_Mutation_deleteCompetitor_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteCompetitor(childComplexity, args["id"].(string)), true

	case "Mutation.deleteEvent":
		if e.complexity.Mutation.DeleteEvent == nil {
			break
		}

		args, err := ec.field_Mutation_deleteEvent_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteEvent(childComplexity, args["id"].(string)), true

	case "Mutation.deleteLeg":
		if e.complexity.Mutation.DeleteLeg == nil {
			break
		}

		args, err := ec.field_Mutation_deleteLeg_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteLeg(childComplexity, args["id"].(string)), true

	case "Mutation.deleteMatch":
		if e.complexity.Mutation.DeleteMatch == nil {
			break
		}

		args, err := ec.field_Mutation_deleteMatch_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteMatch(childComplexity, args["id"].(string)), true

	case "Mutation.deleteOverUnderDefault":
		if e.complexity.Mutation.DeleteOverUnderDefault == nil {
			break
		}

		args, err := ec.field_Mutation_deleteOverUnderDefault_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteOverUnderDefault(childComplexity, args["id"].(string)), true

	case "Mutation.deletePlayer":
		if e.complexity.Mutation.DeletePlayer == nil {
			break
		}

		args, err := ec.field_Mutation_deletePlayer_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeletePlayer(childComplexity, args["id"].(string)), true

	case "Mutation.deletePool":
		if e.complexity.Mutation.DeletePool == nil {
			break
		}

		args, err := ec.field_Mutation_deletePool_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeletePool(childComplexity, args["id"].(string)), true

	case "Mutation.deletePoolDefault":
		if e.complexity.Mutation.DeletePoolDefault == nil {
			break
		}

		args, err := ec.field_Mutation_deletePoolDefault_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeletePoolDefault(childComplexity, args["id"].(string)), true

	case "Mutation.updateCompetitor":
		if e.complexity.Mutation.UpdateCompetitor == nil {
			break
		}

		args, err := ec.field_Mutation_updateCompetitor_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateCompetitor(childComplexity, args["input"].(models.UpdateCompetitorInput)), true

	case "Mutation.updateEvent":
		if e.complexity.Mutation.UpdateEvent == nil {
			break
		}

		args, err := ec.field_Mutation_updateEvent_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateEvent(childComplexity, args["input"].(models.UpdateEventInput)), true

	case "Mutation.updateLeg":
		if e.complexity.Mutation.UpdateLeg == nil {
			break
		}

		args, err := ec.field_Mutation_updateLeg_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateLeg(childComplexity, args["input"].(models.UpdateLegInput)), true

	case "Mutation.updateMatch":
		if e.complexity.Mutation.UpdateMatch == nil {
			break
		}

		args, err := ec.field_Mutation_updateMatch_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateMatch(childComplexity, args["input"].(models.UpdateMatchInput)), true

	case "Mutation.updateOverUnderDefault":
		if e.complexity.Mutation.UpdateOverUnderDefault == nil {
			break
		}

		args, err := ec.field_Mutation_updateOverUnderDefault_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateOverUnderDefault(childComplexity, args["input"].(models.UpdateOverUnderDefaultInput)), true

	case "Mutation.updatePlayer":
		if e.complexity.Mutation.UpdatePlayer == nil {
			break
		}

		args, err := ec.field_Mutation_updatePlayer_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdatePlayer(childComplexity, args["input"].(models.UpdatePlayerInput)), true

	case "Mutation.updatePool":
		if e.complexity.Mutation.UpdatePool == nil {
			break
		}

		args, err := ec.field_Mutation_updatePool_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdatePool(childComplexity, args["input"].(models.UpdatePoolInput)), true

	case "Mutation.updatePoolDefault":
		if e.complexity.Mutation.UpdatePoolDefault == nil {
			break
		}

		args, err := ec.field_Mutation_updatePoolDefault_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdatePoolDefault(childComplexity, args["input"].(models.UpdatePoolDefaultInput)), true

	case "Mutation.updateUser":
		if e.complexity.Mutation.UpdateUser == nil {
			break
		}

		args, err := ec.field_Mutation_updateUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateUser(childComplexity, args["input"].(models.UpdateUserInput)), true

	case "OverUnderDefault.evenThreshold":
		if e.complexity.OverUnderDefault.EvenThreshold == nil {
			break
		}

		return e.complexity.OverUnderDefault.EvenThreshold(childComplexity), true

	case "OverUnderDefault.favoredThreshold":
		if e.complexity.OverUnderDefault.FavoredThreshold == nil {
			break
		}

		return e.complexity.OverUnderDefault.FavoredThreshold(childComplexity), true

	case "OverUnderDefault.game":
		if e.complexity.OverUnderDefault.Game == nil {
			break
		}

		return e.complexity.OverUnderDefault.Game(childComplexity), true

	case "OverUnderDefault.id":
		if e.complexity.OverUnderDefault.ID == nil {
			break
		}

		return e.complexity.OverUnderDefault.ID(childComplexity), true

	case "OverUnderDefault.matchFormat":
		if e.complexity.OverUnderDefault.MatchFormat == nil {
			break
		}

		return e.complexity.OverUnderDefault.MatchFormat(childComplexity), true

	case "OverUnderDefault.note":
		if e.complexity.OverUnderDefault.Note == nil {
			break
		}

		return e.complexity.OverUnderDefault.Note(childComplexity), true

	case "Player.externalId":
		if e.complexity.Player.ExternalID == nil {
			break
		}

		return e.complexity.Player.ExternalID(childComplexity), true

	case "Player.id":
		if e.complexity.Player.ID == nil {
			break
		}

		return e.complexity.Player.ID(childComplexity), true

	case "Player.name":
		if e.complexity.Player.Name == nil {
			break
		}

		return e.complexity.Player.Name(childComplexity), true

	case "Player.nickname":
		if e.complexity.Player.Nickname == nil {
			break
		}

		return e.complexity.Player.Nickname(childComplexity), true

	case "Player.teamId":
		if e.complexity.Player.TeamID == nil {
			break
		}

		return e.complexity.Player.TeamID(childComplexity), true

	case "Pool.allocation":
		if e.complexity.Pool.Allocation == nil {
			break
		}

		return e.complexity.Pool.Allocation(childComplexity), true

	case "Pool.carryIn":
		if e.complexity.Pool.CarryIn == nil {
			break
		}

		return e.complexity.Pool.CarryIn(childComplexity), true

	case "Pool.consolationPrizes":
		if e.complexity.Pool.ConsolationPrizes == nil {
			break
		}

		return e.complexity.Pool.ConsolationPrizes(childComplexity), true

	case "Pool.currency":
		if e.complexity.Pool.Currency == nil {
			break
		}

		return e.complexity.Pool.Currency(childComplexity), true

	case "Pool.game":
		if e.complexity.Pool.Game == nil {
			break
		}

		return e.complexity.Pool.Game(childComplexity), true

	case "Pool.guarantee":
		if e.complexity.Pool.Guarantee == nil {
			break
		}

		return e.complexity.Pool.Guarantee(childComplexity), true

	case "Pool.id":
		if e.complexity.Pool.ID == nil {
			break
		}

		return e.complexity.Pool.ID(childComplexity), true

	case "Pool.isActive":
		if e.complexity.Pool.IsActive == nil {
			break
		}

		return e.complexity.Pool.IsActive(childComplexity), true

	case "Pool.isAutogenerated":
		if e.complexity.Pool.IsAutogenerated == nil {
			break
		}

		return e.complexity.Pool.IsAutogenerated(childComplexity), true

	case "Pool.lastSyncTime":
		if e.complexity.Pool.LastSyncTime == nil {
			break
		}

		return e.complexity.Pool.LastSyncTime(childComplexity), true

	case "Pool.legs":
		if e.complexity.Pool.Legs == nil {
			break
		}

		return e.complexity.Pool.Legs(childComplexity), true

	case "Pool.maxUnitPerLine":
		if e.complexity.Pool.MaxUnitPerLine == nil {
			break
		}

		return e.complexity.Pool.MaxUnitPerLine(childComplexity), true

	case "Pool.maxUnitPerTicket":
		if e.complexity.Pool.MaxUnitPerTicket == nil {
			break
		}

		return e.complexity.Pool.MaxUnitPerTicket(childComplexity), true

	case "Pool.minUnitPerLine":
		if e.complexity.Pool.MinUnitPerLine == nil {
			break
		}

		return e.complexity.Pool.MinUnitPerLine(childComplexity), true

	case "Pool.minUnitPerTicket":
		if e.complexity.Pool.MinUnitPerTicket == nil {
			break
		}

		return e.complexity.Pool.MinUnitPerTicket(childComplexity), true

	case "Pool.name":
		if e.complexity.Pool.Name == nil {
			break
		}

		return e.complexity.Pool.Name(childComplexity), true

	case "Pool.note":
		if e.complexity.Pool.Note == nil {
			break
		}

		return e.complexity.Pool.Note(childComplexity), true

	case "Pool.syncedColossusStatus":
		if e.complexity.Pool.SyncedColossusStatus == nil {
			break
		}

		return e.complexity.Pool.SyncedColossusStatus(childComplexity), true

	case "Pool.type":
		if e.complexity.Pool.Type == nil {
			break
		}

		return e.complexity.Pool.Type(childComplexity), true

	case "Pool.unitValue":
		if e.complexity.Pool.UnitValue == nil {
			break
		}

		return e.complexity.Pool.UnitValue(childComplexity), true

	case "PoolDefault.allocation":
		if e.complexity.PoolDefault.Allocation == nil {
			break
		}

		return e.complexity.PoolDefault.Allocation(childComplexity), true

	case "PoolDefault.carryIn":
		if e.complexity.PoolDefault.CarryIn == nil {
			break
		}

		return e.complexity.PoolDefault.CarryIn(childComplexity), true

	case "PoolDefault.currency":
		if e.complexity.PoolDefault.Currency == nil {
			break
		}

		return e.complexity.PoolDefault.Currency(childComplexity), true

	case "PoolDefault.game":
		if e.complexity.PoolDefault.Game == nil {
			break
		}

		return e.complexity.PoolDefault.Game(childComplexity), true

	case "PoolDefault.guarantee":
		if e.complexity.PoolDefault.Guarantee == nil {
			break
		}

		return e.complexity.PoolDefault.Guarantee(childComplexity), true

	case "PoolDefault.id":
		if e.complexity.PoolDefault.ID == nil {
			break
		}

		return e.complexity.PoolDefault.ID(childComplexity), true

	case "PoolDefault.legCount":
		if e.complexity.PoolDefault.LegCount == nil {
			break
		}

		return e.complexity.PoolDefault.LegCount(childComplexity), true

	case "PoolDefault.maxUnitPerLine":
		if e.complexity.PoolDefault.MaxUnitPerLine == nil {
			break
		}

		return e.complexity.PoolDefault.MaxUnitPerLine(childComplexity), true

	case "PoolDefault.maxUnitPerTicket":
		if e.complexity.PoolDefault.MaxUnitPerTicket == nil {
			break
		}

		return e.complexity.PoolDefault.MaxUnitPerTicket(childComplexity), true

	case "PoolDefault.minUnitPerLine":
		if e.complexity.PoolDefault.MinUnitPerLine == nil {
			break
		}

		return e.complexity.PoolDefault.MinUnitPerLine(childComplexity), true

	case "PoolDefault.minUnitPerTicket":
		if e.complexity.PoolDefault.MinUnitPerTicket == nil {
			break
		}

		return e.complexity.PoolDefault.MinUnitPerTicket(childComplexity), true

	case "PoolDefault.note":
		if e.complexity.PoolDefault.Note == nil {
			break
		}

		return e.complexity.PoolDefault.Note(childComplexity), true

	case "PoolDefault.type":
		if e.complexity.PoolDefault.Type == nil {
			break
		}

		return e.complexity.PoolDefault.Type(childComplexity), true

	case "PoolDefault.unitValue":
		if e.complexity.PoolDefault.UnitValue == nil {
			break
		}

		return e.complexity.PoolDefault.UnitValue(childComplexity), true

	case "Query.allAudits":
		if e.complexity.Query.AllAudits == nil {
			break
		}

		args, err := ec.field_Query_allAudits_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AllAudits(childComplexity, args["filter"].(*models.AuditFilter), args["page"].(*int), args["perPage"].(*int), args["sortField"].(*string), args["sortOrder"].(*string)), true

	case "Query.allCompetitors":
		if e.complexity.Query.AllCompetitors == nil {
			break
		}

		args, err := ec.field_Query_allCompetitors_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AllCompetitors(childComplexity, args["filter"].(*models.CompetitorFilter), args["page"].(*int), args["perPage"].(*int), args["sortField"].(*string), args["sortOrder"].(*string)), true

	case "Query.allEvents":
		if e.complexity.Query.AllEvents == nil {
			break
		}

		args, err := ec.field_Query_allEvents_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AllEvents(childComplexity, args["filter"].(*models.EventFilter), args["page"].(*int), args["perPage"].(*int), args["sortField"].(*string), args["sortOrder"].(*string)), true

	case "Query.allLegs":
		if e.complexity.Query.AllLegs == nil {
			break
		}

		args, err := ec.field_Query_allLegs_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AllLegs(childComplexity, args["filter"].(*models.LegFilter), args["page"].(*int), args["perPage"].(*int), args["sortField"].(*string), args["sortOrder"].(*string)), true

	case "Query.allMatches":
		if e.complexity.Query.AllMatches == nil {
			break
		}

		args, err := ec.field_Query_allMatches_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AllMatches(childComplexity, args["filter"].(*models.MatchFilter), args["page"].(*int), args["perPage"].(*int), args["sortField"].(*string), args["sortOrder"].(*string)), true

	case "Query.allOverUnderDefaults":
		if e.complexity.Query.AllOverUnderDefaults == nil {
			break
		}

		args, err := ec.field_Query_allOverUnderDefaults_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AllOverUnderDefaults(childComplexity, args["filter"].(*models.OverUnderDefaultFilter), args["page"].(*int), args["perPage"].(*int), args["sortField"].(*string), args["sortOrder"].(*string)), true

	case "Query.allPlayers":
		if e.complexity.Query.AllPlayers == nil {
			break
		}

		args, err := ec.field_Query_allPlayers_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AllPlayers(childComplexity, args["filter"].(*models.PlayerFilter), args["page"].(*int), args["perPage"].(*int), args["sortField"].(*string), args["sortOrder"].(*string)), true

	case "Query.allPoolDefaults":
		if e.complexity.Query.AllPoolDefaults == nil {
			break
		}

		args, err := ec.field_Query_allPoolDefaults_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AllPoolDefaults(childComplexity, args["filter"].(*models.PoolDefaultFilter), args["page"].(*int), args["perPage"].(*int), args["sortField"].(*string), args["sortOrder"].(*string)), true

	case "Query.allPools":
		if e.complexity.Query.AllPools == nil {
			break
		}

		args, err := ec.field_Query_allPools_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AllPools(childComplexity, args["filter"].(*models.PoolFilter), args["page"].(*int), args["perPage"].(*int), args["sortField"].(*string), args["sortOrder"].(*string)), true

	case "Query.allUsers":
		if e.complexity.Query.AllUsers == nil {
			break
		}

		args, err := ec.field_Query_allUsers_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AllUsers(childComplexity, args["filter"].(*models.UserFilter), args["page"].(*int), args["perPage"].(*int), args["sortField"].(*string), args["sortOrder"].(*string)), true

	case "Query.Audit":
		if e.complexity.Query.Audit == nil {
			break
		}

		args, err := ec.field_Query_Audit_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Audit(childComplexity, args["id"].(string)), true

	case "Query.Competitor":
		if e.complexity.Query.Competitor == nil {
			break
		}

		args, err := ec.field_Query_Competitor_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Competitor(childComplexity, args["id"].(string)), true

	case "Query.Event":
		if e.complexity.Query.Event == nil {
			break
		}

		args, err := ec.field_Query_Event_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Event(childComplexity, args["id"].(string)), true

	case "Query.Leg":
		if e.complexity.Query.Leg == nil {
			break
		}

		args, err := ec.field_Query_Leg_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Leg(childComplexity, args["id"].(string)), true

	case "Query.Match":
		if e.complexity.Query.Match == nil {
			break
		}

		args, err := ec.field_Query_Match_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Match(childComplexity, args["id"].(string)), true

	case "Query.OverUnderDefault":
		if e.complexity.Query.OverUnderDefault == nil {
			break
		}

		args, err := ec.field_Query_OverUnderDefault_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.OverUnderDefault(childComplexity, args["id"].(string)), true

	case "Query.Player":
		if e.complexity.Query.Player == nil {
			break
		}

		args, err := ec.field_Query_Player_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Player(childComplexity, args["id"].(string)), true

	case "Query.Pool":
		if e.complexity.Query.Pool == nil {
			break
		}

		args, err := ec.field_Query_Pool_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Pool(childComplexity, args["id"].(string)), true

	case "Query.PoolDefault":
		if e.complexity.Query.PoolDefault == nil {
			break
		}

		args, err := ec.field_Query_PoolDefault_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.PoolDefault(childComplexity, args["id"].(string)), true

	case "Query.User":
		if e.complexity.Query.User == nil {
			break
		}

		args, err := ec.field_Query_User_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.User(childComplexity, args["id"].(string)), true

	case "Query._allAuditsMeta":
		if e.complexity.Query._allAuditsMeta == nil {
			break
		}

		args, err := ec.field_Query__allAuditsMeta_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query._allAuditsMeta(childComplexity, args["filter"].(*models.AuditFilter), args["page"].(*int), args["perPage"].(*int)), true

	case "Query._allCompetitorsMeta":
		if e.complexity.Query._allCompetitorsMeta == nil {
			break
		}

		args, err := ec.field_Query__allCompetitorsMeta_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query._allCompetitorsMeta(childComplexity, args["filter"].(*models.CompetitorFilter), args["page"].(*int), args["perPage"].(*int)), true

	case "Query._allEventsMeta":
		if e.complexity.Query._allEventsMeta == nil {
			break
		}

		args, err := ec.field_Query__allEventsMeta_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query._allEventsMeta(childComplexity, args["filter"].(*models.EventFilter), args["page"].(*int), args["perPage"].(*int)), true

	case "Query._allLegsMeta":
		if e.complexity.Query._allLegsMeta == nil {
			break
		}

		args, err := ec.field_Query__allLegsMeta_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query._allLegsMeta(childComplexity, args["filter"].(*models.LegFilter), args["page"].(*int), args["perPage"].(*int)), true

	case "Query._allMatchesMeta":
		if e.complexity.Query._allMatchesMeta == nil {
			break
		}

		args, err := ec.field_Query__allMatchesMeta_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query._allMatchesMeta(childComplexity, args["filter"].(*models.MatchFilter), args["page"].(*int), args["perPage"].(*int)), true

	case "Query._allOverUnderDefaultsMeta":
		if e.complexity.Query._allOverUnderDefaultsMeta == nil {
			break
		}

		args, err := ec.field_Query__allOverUnderDefaultsMeta_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query._allOverUnderDefaultsMeta(childComplexity, args["filter"].(*models.OverUnderDefaultFilter), args["page"].(*int), args["perPage"].(*int)), true

	case "Query._allPlayersMeta":
		if e.complexity.Query._allPlayersMeta == nil {
			break
		}

		args, err := ec.field_Query__allPlayersMeta_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query._allPlayersMeta(childComplexity, args["filter"].(*models.PlayerFilter), args["page"].(*int), args["perPage"].(*int)), true

	case "Query._allPoolDefaultsMeta":
		if e.complexity.Query._allPoolDefaultsMeta == nil {
			break
		}

		args, err := ec.field_Query__allPoolDefaultsMeta_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query._allPoolDefaultsMeta(childComplexity, args["filter"].(*models.PoolDefaultFilter), args["page"].(*int), args["perPage"].(*int)), true

	case "Query._allPoolsMeta":
		if e.complexity.Query._allPoolsMeta == nil {
			break
		}

		args, err := ec.field_Query__allPoolsMeta_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query._allPoolsMeta(childComplexity, args["filter"].(*models.PoolFilter), args["page"].(*int), args["perPage"].(*int)), true

	case "Query._allUsersMeta":
		if e.complexity.Query._allUsersMeta == nil {
			break
		}

		args, err := ec.field_Query__allUsersMeta_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query._allUsersMeta(childComplexity, args["filter"].(*models.UserFilter), args["page"].(*int), args["perPage"].(*int)), true

	case "Session.token":
		if e.complexity.Session.Token == nil {
			break
		}

		return e.complexity.Session.Token(childComplexity), true

	case "TeamProbabilities.probability":
		if e.complexity.TeamProbabilities.Probability == nil {
			break
		}

		return e.complexity.TeamProbabilities.Probability(childComplexity), true

	case "TeamProbabilities.teamId":
		if e.complexity.TeamProbabilities.TeamID == nil {
			break
		}

		return e.complexity.TeamProbabilities.TeamID(childComplexity), true

	case "TeamScore.score":
		if e.complexity.TeamScore.Score == nil {
			break
		}

		return e.complexity.TeamScore.Score(childComplexity), true

	case "TeamScore.teamId":
		if e.complexity.TeamScore.TeamID == nil {
			break
		}

		return e.complexity.TeamScore.TeamID(childComplexity), true

	case "TeamScores.score":
		if e.complexity.TeamScores.Score == nil {
			break
		}

		return e.complexity.TeamScores.Score(childComplexity), true

	case "TeamScores.teamId":
		if e.complexity.TeamScores.TeamID == nil {
			break
		}

		return e.complexity.TeamScores.TeamID(childComplexity), true

	case "TeamWinProbability.probability":
		if e.complexity.TeamWinProbability.Probability == nil {
			break
		}

		return e.complexity.TeamWinProbability.Probability(childComplexity), true

	case "TeamWinProbability.teamId":
		if e.complexity.TeamWinProbability.TeamID == nil {
			break
		}

		return e.complexity.TeamWinProbability.TeamID(childComplexity), true

	case "User.accessRole":
		if e.complexity.User.AccessRole == nil {
			break
		}

		return e.complexity.User.AccessRole(childComplexity), true

	case "User.email":
		if e.complexity.User.Email == nil {
			break
		}

		return e.complexity.User.Email(childComplexity), true

	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.token":
		if e.complexity.User.Token == nil {
			break
		}

		return e.complexity.User.Token(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Query(ctx context.Context, op *ast.OperationDefinition) *graphql.Response {
	ec := executionContext{graphql.GetRequestContext(ctx), e}

	buf := ec.RequestMiddleware(ctx, func(ctx context.Context) []byte {
		data := ec._Query(ctx, op.SelectionSet)
		var buf bytes.Buffer
		data.MarshalGQL(&buf)
		return buf.Bytes()
	})

	return &graphql.Response{
		Data:       buf,
		Errors:     ec.Errors,
		Extensions: ec.Extensions,
	}
}

func (e *executableSchema) Mutation(ctx context.Context, op *ast.OperationDefinition) *graphql.Response {
	ec := executionContext{graphql.GetRequestContext(ctx), e}

	buf := ec.RequestMiddleware(ctx, func(ctx context.Context) []byte {
		data := ec._Mutation(ctx, op.SelectionSet)
		var buf bytes.Buffer
		data.MarshalGQL(&buf)
		return buf.Bytes()
	})

	return &graphql.Response{
		Data:       buf,
		Errors:     ec.Errors,
		Extensions: ec.Extensions,
	}
}

func (e *executableSchema) Subscription(ctx context.Context, op *ast.OperationDefinition) func() *graphql.Response {
	return graphql.OneShot(graphql.ErrorResponse(ctx, "subscriptions are not supported"))
}

type executionContext struct {
	*graphql.RequestContext
	*executableSchema
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var parsedSchema = gqlparser.MustLoadSchema(
	&ast.Source{Name: "schema.graphql", Input: `# Time is an RFC3339 timestamp.
scalar Time

# Arbitrary precision decimal
scalar Decimal

# JSON blob for unstructured data
scalar JSON

enum AccessRole {
  SUPER_ADMIN
  ADMIN
  USER
  GUEST_API_ONLY
}

enum ProductType {
  OUTLAST
  BRAWL
  HERO
}

enum EventType {
  TOURNAMENT
}

enum PoolType {
  H2H
  OVER_UNDER
  FANTASY
}

enum PoolStatus {
  NOT_READY
  NEEDS_APPROVAL
  SYNC_ERROR
  APPROVED
  CREATED
  VISIBLE
  TRADING_OPEN
  TRADING_CLOSED
  OFFICIAL
  SETTLED
  ABANDONED
}

enum PoolCurrency {
  STR
}

enum MatchColossusStatus {
  UNKNOWN
  NOT_STARTED
  SYNC_ERROR
  IN_PLAY
  COMPLETED
  OFFICIAL
  ABANDONED
}

enum MatchInternalStatus {
  NOT_READY
  SCHEDULED
  IN_PROGRESS
  FINISHED
  CLOSED
  POSTPONED
  SUSPENDED
  DELAYED
  CANCELLED
  INTERRUPTED
  ABANDONED
  UNKNOWN
}

enum MatchFormat {
  bo2
  bo3
  bo5
  UNKNOWN
}

enum Game {
  COUNTER_STRIKE_GLOBAL_OFFENSIVE
  DOTA_2
  LEAGUE_OF_LEGENDS
  PUBG
  APEX_LEGENDS
  UNDERLORDS
  TEAMFIGHT_TACTICS
  AUTO_CHESS
  STARCRAFT_2
  OVERWATCH
  RAINBOW_SIX_SIEGE
  HEARTHSTONE
  HEROES_OF_THE_STORM
  WARCRAFT_3
  ROCKET_LEAGUE
  CALL_OF_DUTY
  VAIN_GLORY
  HALO
  QUAKE
  KING_OF_GLORY
  WORLD_OF_WARCRAFT
  FIFA
  SMITE
  WORLD_OF_TANKS
  GWENT
  MADDEN
  BATTLEFIELD_5
  NBA2K
  STREET_FIGHTER
  STARCRAFT_BROODWAR
  MAGIC_THE_GATHERING
  UNKNOWN
}

enum EditAction {
  CREATE
  UPDATE
  DELETE
}

type TeamScore {
  teamId: String!
  score: Int!
}
type TeamWinProbability {
  teamId: String!
  probability: Decimal!
}

type Event {
  id: ID!
  name: String!
  externalId: String!
  type: EventType!
  game: Game!
  logo: String!
  startDate: Time
  endDate: Time
  isActive: Boolean!
  isAutogenerated: Boolean!
  matches: [Match!]!
}

type Match {
  id: ID!
  eventId: ID!
  externalId: String!
  name: String!
  description: String!
  startTime: Time
  isActive: Boolean!
  isAutogenerated: Boolean!
  internalStatus: MatchInternalStatus!
  eventStage: String!
  competitors: [Competitor!]!
  statistics: JSON!
  teamScores: [TeamScore!]!
  teamOuScores: [TeamScore!]!
  teamWinProbabilities: [TeamWinProbability!]!
  format: MatchFormat!
  history: [Audit!]
}

type TeamScores {
  teamId: ID!
  score: Int!
}

type TeamProbabilities {
  teamId: ID!
  probability: Float!
}

type Competitor {
  id: ID!
  externalId: String!
  name: String!
  logo: String!
  matches: [Match]
}

type Player {
  id: ID!
  externalId: String!
  name: String!
  nickname: String!
  teamId: ID!
}

type ConsolationPrize {
  guarantee: Decimal!
  carryIn: Decimal!
  allocation: Decimal!
}

type Pool {
  id: ID!
  name: String!
  type: PoolType!
  isActive: Boolean!
  guarantee: Decimal!
  carryIn: Decimal!
  allocation: Decimal!
  note: String!
  unitValue: Decimal!
  minUnitPerLine: Decimal!
  maxUnitPerLine: Decimal!
  minUnitPerTicket: Decimal!
  maxUnitPerTicket: Decimal!
  currency: PoolCurrency!
  isAutogenerated: Boolean!
  lastSyncTime: Time
  syncedColossusStatus: PoolStatus!
  game: Game!
  legs: [Leg!]!
  consolationPrizes: [ConsolationPrize!]
}

type PoolDefault {
  id: ID!
  legCount: Decimal!
  game: Game!
  type: PoolType!
  guarantee: Decimal!
  carryIn: Decimal!
  allocation: Decimal!
  unitValue: Decimal!
  minUnitPerLine: Decimal!
  maxUnitPerLine: Decimal!
  minUnitPerTicket: Decimal!
  maxUnitPerTicket: Decimal!
  currency: PoolCurrency!
  note: String!
}

type Leg {
  id: ID!
  lastSyncTime: Time
  threshold: Decimal!
  matchId: ID!
  poolId: ID!
}

type User {
  id: ID!
  email: String!
  token: String!
  accessRole: AccessRole!
}

type Audit {
  id: ID!
  time: Time!
  targetId: ID!
  targetType: String!
  user: User!
  editAction: EditAction!
  content: String!
}

type Session {
  token: String!
}

type OverUnderDefault {
  id: ID!
  game: Game!
  matchFormat: MatchFormat!
  evenThreshold: Decimal!
  favoredThreshold: Decimal!
  note: String!
}

type ListMetadata {
  count: Int!
}

input EventFilter {
  id: ID
  name: String
  isActive: Boolean
  game: Game
  externalId: String
  ids: [ID!]
}

input UserFilter {
  email: String
  role: AccessRole
  ids: [ID!]
}

input AuditFilter {
  id: ID
  targetId: ID
  targetType: String
  userId: ID
  editAction: EditAction
  ids: [ID!]
}

input LegFilter {
  id: ID
  matchId: ID
  poolId: ID
  ids: [ID!]
}

input PlayerFilter {
  id: ID
  name: String
  nickname: String
  externalId: String
  teamId: ID
  ids: [ID!]
}

input CompetitorFilter {
  id: ID
  name: String
  externalId: String
  match_id: String
  ids: [ID!]
}

input PoolFilter {
  id: ID
  name: String
  isActive: Boolean
  isAutogenerated: Boolean
  poolStatus: PoolStatus
  guarantee: Decimal
  legCount: Decimal
  type: PoolType
  game: Game
  eventId: ID
  lastSyncTimeBefore: Time
  lastSyncTimeAfter: Time
  ids: [ID!]
}

input PoolDefaultFilter {
  type: PoolType
  game: Game
}

input MatchFilter {
  id: ID
  name: String
  externalId: String
  isActive: Boolean
  isAutogenerated: Boolean
  internalStatus: MatchInternalStatus
  format: MatchFormat
  eventStage: String
  eventId: ID
  ids: [ID!]
}

input OverUnderDefaultFilter {
  game: Game
  matchFormat: MatchFormat
  ids: [ID!]
}

input AuthInput {
  email: String!
  password: String!
}

input CreateUserInput {
  email: String!
  password: String!
  role: AccessRole!
}

input UpdateUserInput {
  id: ID!
  email: String
  password: String
  accessRole: AccessRole
}

input CreateEventInput {
  name: String!
  type: EventType!
  game: Game!
  logo: String
  startDate: Time!
  endDate: Time!
  isActive: Boolean
}

input UpdateEventInput {
  id: ID!
  name: String
  type: EventType
  game: Game
  logo: String
  startDate: Time
  endDate: Time
  isActive: Boolean
}

input CreateMatchInput {
  name: String!
  eventId: ID!
  description: String
  startTime: Time!
  isActive: Boolean
  internalStatus: MatchInternalStatus!
  eventStage: String!
  format: MatchFormat!
}

input UpdateTeamScores {
  teamId: String!
  score: Int!
}

input UpdateTeamProbabilities {
  teamId: String!
  probability: Float!
}

input UpdateMatchInput {
  id: ID!
  name: String
  description: String
  startTime: Time
  isActive: Boolean
  internalStatus: MatchInternalStatus
  eventStage: String
  eventId: ID
  teamScores: [UpdateTeamScores!]
  teamOuScores: [UpdateTeamScores!]
  teamWinProbabilities: [UpdateTeamProbabilities!]
  format: MatchFormat
}

input CreateCompetitorInput {
  name: String!
  logo: String
}

input UpdateCompetitorInput {
  id: ID!
  name: String
  logo: String
}

input CreatePlayerInput {
  name: String!
  nickname: String
  teamId: ID!
}

input UpdatePlayerInput {
  id: ID!
  name: String
  nickname: String
  teamId: ID
}

input CreatePoolInput {
  name: String!
  type: PoolType!
  guarantee: Decimal!
  carryIn: Decimal!
  allocation: Decimal!
  game: Game!
  note: String
  unitValue: Decimal!
  currency: PoolCurrency!
  minUnitPerLine: Decimal!
  maxUnitPerLine: Decimal!
  minUnitPerTicket: Decimal!
  maxUnitPerTicket: Decimal!
}

input UpdateConsolationPrize {
  guarantee: Decimal!
  carryIn: Decimal!
  allocation: Decimal!
}

input UpdatePoolInput {
  id: ID!
  name: String
  isActive: Boolean
  guarantee: Decimal!
  carryIn: Decimal!
  allocation: Decimal!
  note: String
  unitValue: Decimal
  minUnitPerLine: Decimal
  maxUnitPerLine: Decimal
  minUnitPerTicket: Decimal
  maxUnitPerTicket: Decimal
  currency: PoolCurrency
  syncedColossusStatus: PoolStatus
  legsIds: [ID!]
  consolationPrizes: [UpdateConsolationPrize!]
}

input CreatePoolDefaultInput {
  legCount: Decimal!
  game: Game!
  type: PoolType!
  guarantee: Decimal!
  carryIn: Decimal!
  allocation: Decimal!
  unitValue: Decimal!
  minUnitPerLine: Decimal!
  maxUnitPerLine: Decimal!
  minUnitPerTicket: Decimal!
  maxUnitPerTicket: Decimal!
  currency: PoolCurrency!
  note: String
}

input UpdatePoolDefaultInput {
  id: ID!
  legCount: Decimal
  game: Game
  type: PoolType
  guarantee: Decimal
  carryIn: Decimal
  allocation: Decimal
  unitValue: Decimal
  minUnitPerLine: Decimal
  maxUnitPerLine: Decimal
  minUnitPerTicket: Decimal
  maxUnitPerTicket: Decimal
  currency: PoolCurrency
  note: String
}

input CreateLegInput {
  matchId: ID!
  poolId: ID!
  threshold: Decimal
}

input UpdateLegInput {
  id: ID!
  threshold: Decimal
  matchId: ID
  poolId: ID
}

input CreateOverUnderDefaultInput {
  game: Game!
  matchFormat: MatchFormat!
  evenThreshold: Decimal!
  favoredThreshold: Decimal!
  note: String
}

input UpdateOverUnderDefaultInput {
  id: ID!
  evenThreshold: Decimal
  favoredThreshold: Decimal
  note: String
}

type Mutation {
  createUser(input: CreateUserInput!): User!
  updateUser(input: UpdateUserInput!): User!

  createSession(input: AuthInput!): Session!

  createEvent(input: CreateEventInput!): Event!
  updateEvent(input: UpdateEventInput!): Event!
  deleteEvent(id: ID!): Event!

  createMatch(input: CreateMatchInput!): Match!
  updateMatch(input: UpdateMatchInput!): Match!
  deleteMatch(id: ID!): Match!

  createCompetitor(input: CreateCompetitorInput!): Competitor!
  updateCompetitor(input: UpdateCompetitorInput!): Competitor!
  deleteCompetitor(id: ID!): Competitor!

  createPlayer(input: CreatePlayerInput!): Player!
  updatePlayer(input: UpdatePlayerInput!): Player!
  deletePlayer(id: ID!): Player!

  createPool(input: CreatePoolInput!): Pool!
  updatePool(input: UpdatePoolInput!): Pool!
  deletePool(id: ID!): Pool!

  createPoolDefault(input: CreatePoolDefaultInput!): PoolDefault!
  updatePoolDefault(input: UpdatePoolDefaultInput!): PoolDefault!
  deletePoolDefault(id: ID!): PoolDefault!

  createLeg(input: CreateLegInput!): Leg!
  updateLeg(input: UpdateLegInput!): Leg!
  deleteLeg(id: ID!): Leg!

  createOverUnderDefault(input: CreateOverUnderDefaultInput!): OverUnderDefault!
  updateOverUnderDefault(input: UpdateOverUnderDefaultInput!): OverUnderDefault!
  deleteOverUnderDefault(id: ID!): OverUnderDefault!
}

type Query {
  Event(id: ID!): Event!
  allEvents(
    filter: EventFilter
    page: Int
    perPage: Int
    sortField: String
    sortOrder: String
  ): [Event!]!
  _allEventsMeta(filter: EventFilter, page: Int, perPage: Int): ListMetadata

  Pool(id: ID!): Pool!
  allPools(
    filter: PoolFilter
    page: Int
    perPage: Int
    sortField: String
    sortOrder: String
  ): [Pool!]!
  _allPoolsMeta(filter: PoolFilter, page: Int, perPage: Int): ListMetadata

  PoolDefault(id: ID!): PoolDefault!
  allPoolDefaults(
    filter: PoolDefaultFilter
    page: Int
    perPage: Int
    sortField: String
    sortOrder: String
  ): [PoolDefault!]!
  _allPoolDefaultsMeta(
    filter: PoolDefaultFilter
    page: Int
    perPage: Int
  ): ListMetadata

  Leg(id: ID!): Leg!
  allLegs(
    filter: LegFilter
    page: Int
    perPage: Int
    sortField: String
    sortOrder: String
  ): [Leg!]!
  _allLegsMeta(filter: LegFilter, page: Int, perPage: Int): ListMetadata

  Match(id: ID!): Match!
  allMatches(
    filter: MatchFilter
    page: Int
    perPage: Int
    sortField: String
    sortOrder: String
  ): [Match!]!
  _allMatchesMeta(filter: MatchFilter, page: Int, perPage: Int): ListMetadata

  Competitor(id: ID!): Competitor!
  allCompetitors(
    filter: CompetitorFilter
    page: Int
    perPage: Int
    sortField: String
    sortOrder: String
  ): [Competitor!]!
  _allCompetitorsMeta(
    filter: CompetitorFilter
    page: Int
    perPage: Int
  ): ListMetadata

  Player(id: ID!): Player!
  allPlayers(
    filter: PlayerFilter
    page: Int
    perPage: Int
    sortField: String
    sortOrder: String
  ): [Player!]!
  _allPlayersMeta(filter: PlayerFilter, page: Int, perPage: Int): ListMetadata

  User(id: ID!): User!
  allUsers(
    filter: UserFilter
    page: Int
    perPage: Int
    sortField: String
    sortOrder: String
  ): [User!]!
  _allUsersMeta(filter: UserFilter, page: Int, perPage: Int): ListMetadata

  Audit(id: ID!): Audit!
  allAudits(
    filter: AuditFilter
    page: Int
    perPage: Int
    sortField: String
    sortOrder: String
  ): [Audit!]!
  _allAuditsMeta(filter: AuditFilter, page: Int, perPage: Int): ListMetadata

  OverUnderDefault(id: ID!): OverUnderDefault!
  allOverUnderDefaults(
    filter: OverUnderDefaultFilter
    page: Int
    perPage: Int
    sortField: String
    sortOrder: String
  ): [OverUnderDefault!]!
  _allOverUnderDefaultsMeta(
    filter: OverUnderDefaultFilter
    page: Int
    perPage: Int
  ): ListMetadata
}
`},
)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) field_Mutation_createCompetitor_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.CreateCompetitorInput
	if tmp, ok := rawArgs["input"]; ok {
		arg0, err = ec.unmarshalNCreateCompetitorInput2gitlabcomsiimplespbettingbettingfeedpkgmodelsCreateCompetitorInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createEvent_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.CreateEventInput
	if tmp, ok := rawArgs["input"]; ok {
		arg0, err = ec.unmarshalNCreateEventInput2gitlabcomsiimplespbettingbettingfeedpkgmodelsCreateEventInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createLeg_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.CreateLegInput
	if tmp, ok := rawArgs["input"]; ok {
		arg0, err = ec.unmarshalNCreateLegInput2gitlabcomsiimplespbettingbettingfeedpkgmodelsCreateLegInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createMatch_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.CreateMatchInput
	if tmp, ok := rawArgs["input"]; ok {
		arg0, err = ec.unmarshalNCreateMatchInput2gitlabcomsiimplespbettingbettingfeedpkgmodelsCreateMatchInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createOverUnderDefault_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.CreateOverUnderDefaultInput
	if tmp, ok := rawArgs["input"]; ok {
		arg0, err = ec.unmarshalNCreateOverUnderDefaultInput2gitlabcomsiimplespbettingbettingfeedpkgmodelsCreateOverUnderDefaultInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createPlayer_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.CreatePlayerInput
	if tmp, ok := rawArgs["input"]; ok {
		arg0, err = ec.unmarshalNCreatePlayerInput2gitlabcomsiimplespbettingbettingfeedpkgmodelsCreatePlayerInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createPoolDefault_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.CreatePoolDefaultInput
	if tmp, ok := rawArgs["input"]; ok {
		arg0, err = ec.unmarshalNCreatePoolDefaultInput2gitlabcomsiimplespbettingbettingfeedpkgmodelsCreatePoolDefaultInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createPool_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.CreatePoolInput
	if tmp, ok := rawArgs["input"]; ok {
		arg0, err = ec.unmarshalNCreatePoolInput2gitlabcomsiimplespbettingbettingfeedpkgmodelsCreatePoolInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createSession_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.AuthInput
	if tmp, ok := rawArgs["input"]; ok {
		arg0, err = ec.unmarshalNAuthInput2gitlabcomsiimplespbettingbettingfeedpkgmodelsAuthInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createUser_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.CreateUserInput
	if tmp, ok := rawArgs["input"]; ok {
		arg0, err = ec.unmarshalNCreateUserInput2gitlabcomsiimplespbettingbettingfeedpkgmodelsCreateUserInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteCompetitor_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteEvent_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteLeg_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteMatch_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteOverUnderDefault_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deletePlayer_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deletePoolDefault_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deletePool_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateCompetitor_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.UpdateCompetitorInput
	if tmp, ok := rawArgs["input"]; ok {
		arg0, err = ec.unmarshalNUpdateCompetitorInput2gitlabcomsiimplespbettingbettingfeedpkgmodelsUpdateCompetitorInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateEvent_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.UpdateEventInput
	if tmp, ok := rawArgs["input"]; ok {
		arg0, err = ec.unmarshalNUpdateEventInput2gitlabcomsiimplespbettingbettingfeedpkgmodelsUpdateEventInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateLeg_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.UpdateLegInput
	if tmp, ok := rawArgs["input"]; ok {
		arg0, err = ec.unmarshalNUpdateLegInput2gitlabcomsiimplespbettingbettingfeedpkgmodelsUpdateLegInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateMatch_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.UpdateMatchInput
	if tmp, ok := rawArgs["input"]; ok {
		arg0, err = ec.unmarshalNUpdateMatchInput2gitlabcomsiimplespbettingbettingfeedpkgmodelsUpdateMatchInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateOverUnderDefault_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.UpdateOverUnderDefaultInput
	if tmp, ok := rawArgs["input"]; ok {
		arg0, err = ec.unmarshalNUpdateOverUnderDefaultInput2gitlabcomsiimplespbettingbettingfeedpkgmodelsUpdateOverUnderDefaultInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updatePlayer_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.UpdatePlayerInput
	if tmp, ok := rawArgs["input"]; ok {
		arg0, err = ec.unmarshalNUpdatePlayerInput2gitlabcomsiimplespbettingbettingfeedpkgmodelsUpdatePlayerInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updatePoolDefault_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.UpdatePoolDefaultInput
	if tmp, ok := rawArgs["input"]; ok {
		arg0, err = ec.unmarshalNUpdatePoolDefaultInput2gitlabcomsiimplespbettingbettingfeedpkgmodelsUpdatePoolDefaultInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updatePool_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.UpdatePoolInput
	if tmp, ok := rawArgs["input"]; ok {
		arg0, err = ec.unmarshalNUpdatePoolInput2gitlabcomsiimplespbettingbettingfeedpkgmodelsUpdatePoolInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateUser_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 models.UpdateUserInput
	if tmp, ok := rawArgs["input"]; ok {
		arg0, err = ec.unmarshalNUpdateUserInput2gitlabcomsiimplespbettingbettingfeedpkgmodelsUpdateUserInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_Audit_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_Competitor_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_Event_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_Leg_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_Match_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_OverUnderDefault_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_Player_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_PoolDefault_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_Pool_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_User_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query__allAuditsMeta_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.AuditFilter
	if tmp, ok := rawArgs["filter"]; ok {
		arg0, err = ec.unmarshalOAuditFilter2gitlabcomsiimplespbettingbettingfeedpkgmodelsAuditFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["page"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["page"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["perPage"]; ok {
		arg2, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["perPage"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query__allCompetitorsMeta_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.CompetitorFilter
	if tmp, ok := rawArgs["filter"]; ok {
		arg0, err = ec.unmarshalOCompetitorFilter2gitlabcomsiimplespbettingbettingfeedpkgmodelsCompetitorFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["page"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["page"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["perPage"]; ok {
		arg2, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["perPage"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query__allEventsMeta_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.EventFilter
	if tmp, ok := rawArgs["filter"]; ok {
		arg0, err = ec.unmarshalOEventFilter2gitlabcomsiimplespbettingbettingfeedpkgmodelsEventFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["page"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["page"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["perPage"]; ok {
		arg2, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["perPage"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query__allLegsMeta_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.LegFilter
	if tmp, ok := rawArgs["filter"]; ok {
		arg0, err = ec.unmarshalOLegFilter2gitlabcomsiimplespbettingbettingfeedpkgmodelsLegFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["page"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["page"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["perPage"]; ok {
		arg2, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["perPage"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query__allMatchesMeta_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.MatchFilter
	if tmp, ok := rawArgs["filter"]; ok {
		arg0, err = ec.unmarshalOMatchFilter2gitlabcomsiimplespbettingbettingfeedpkgmodelsMatchFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["page"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["page"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["perPage"]; ok {
		arg2, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["perPage"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query__allOverUnderDefaultsMeta_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.OverUnderDefaultFilter
	if tmp, ok := rawArgs["filter"]; ok {
		arg0, err = ec.unmarshalOOverUnderDefaultFilter2gitlabcomsiimplespbettingbettingfeedpkgmodelsOverUnderDefaultFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["page"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["page"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["perPage"]; ok {
		arg2, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["perPage"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query__allPlayersMeta_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.PlayerFilter
	if tmp, ok := rawArgs["filter"]; ok {
		arg0, err = ec.unmarshalOPlayerFilter2gitlabcomsiimplespbettingbettingfeedpkgmodelsPlayerFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["page"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["page"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["perPage"]; ok {
		arg2, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["perPage"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query__allPoolDefaultsMeta_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.PoolDefaultFilter
	if tmp, ok := rawArgs["filter"]; ok {
		arg0, err = ec.unmarshalOPoolDefaultFilter2gitlabcomsiimplespbettingbettingfeedpkgmodelsPoolDefaultFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["page"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["page"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["perPage"]; ok {
		arg2, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["perPage"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query__allPoolsMeta_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.PoolFilter
	if tmp, ok := rawArgs["filter"]; ok {
		arg0, err = ec.unmarshalOPoolFilter2gitlabcomsiimplespbettingbettingfeedpkgmodelsPoolFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["page"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["page"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["perPage"]; ok {
		arg2, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["perPage"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query__allUsersMeta_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.UserFilter
	if tmp, ok := rawArgs["filter"]; ok {
		arg0, err = ec.unmarshalOUserFilter2gitlabcomsiimplespbettingbettingfeedpkgmodelsUserFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["page"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["page"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["perPage"]; ok {
		arg2, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["perPage"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_allAudits_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.AuditFilter
	if tmp, ok := rawArgs["filter"]; ok {
		arg0, err = ec.unmarshalOAuditFilter2gitlabcomsiimplespbettingbettingfeedpkgmodelsAuditFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["page"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["page"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["perPage"]; ok {
		arg2, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["perPage"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["sortField"]; ok {
		arg3, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sortField"] = arg3
	var arg4 *string
	if tmp, ok := rawArgs["sortOrder"]; ok {
		arg4, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sortOrder"] = arg4
	return args, nil
}

func (ec *executionContext) field_Query_allCompetitors_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.CompetitorFilter
	if tmp, ok := rawArgs["filter"]; ok {
		arg0, err = ec.unmarshalOCompetitorFilter2gitlabcomsiimplespbettingbettingfeedpkgmodelsCompetitorFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["page"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["page"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["perPage"]; ok {
		arg2, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["perPage"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["sortField"]; ok {
		arg3, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sortField"] = arg3
	var arg4 *string
	if tmp, ok := rawArgs["sortOrder"]; ok {
		arg4, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sortOrder"] = arg4
	return args, nil
}

func (ec *executionContext) field_Query_allEvents_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.EventFilter
	if tmp, ok := rawArgs["filter"]; ok {
		arg0, err = ec.unmarshalOEventFilter2gitlabcomsiimplespbettingbettingfeedpkgmodelsEventFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["page"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["page"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["perPage"]; ok {
		arg2, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["perPage"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["sortField"]; ok {
		arg3, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sortField"] = arg3
	var arg4 *string
	if tmp, ok := rawArgs["sortOrder"]; ok {
		arg4, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sortOrder"] = arg4
	return args, nil
}

func (ec *executionContext) field_Query_allLegs_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.LegFilter
	if tmp, ok := rawArgs["filter"]; ok {
		arg0, err = ec.unmarshalOLegFilter2gitlabcomsiimplespbettingbettingfeedpkgmodelsLegFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["page"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["page"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["perPage"]; ok {
		arg2, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["perPage"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["sortField"]; ok {
		arg3, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sortField"] = arg3
	var arg4 *string
	if tmp, ok := rawArgs["sortOrder"]; ok {
		arg4, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sortOrder"] = arg4
	return args, nil
}

func (ec *executionContext) field_Query_allMatches_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.MatchFilter
	if tmp, ok := rawArgs["filter"]; ok {
		arg0, err = ec.unmarshalOMatchFilter2gitlabcomsiimplespbettingbettingfeedpkgmodelsMatchFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["page"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["page"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["perPage"]; ok {
		arg2, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["perPage"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["sortField"]; ok {
		arg3, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sortField"] = arg3
	var arg4 *string
	if tmp, ok := rawArgs["sortOrder"]; ok {
		arg4, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sortOrder"] = arg4
	return args, nil
}

func (ec *executionContext) field_Query_allOverUnderDefaults_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.OverUnderDefaultFilter
	if tmp, ok := rawArgs["filter"]; ok {
		arg0, err = ec.unmarshalOOverUnderDefaultFilter2gitlabcomsiimplespbettingbettingfeedpkgmodelsOverUnderDefaultFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["page"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["page"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["perPage"]; ok {
		arg2, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["perPage"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["sortField"]; ok {
		arg3, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sortField"] = arg3
	var arg4 *string
	if tmp, ok := rawArgs["sortOrder"]; ok {
		arg4, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sortOrder"] = arg4
	return args, nil
}

func (ec *executionContext) field_Query_allPlayers_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.PlayerFilter
	if tmp, ok := rawArgs["filter"]; ok {
		arg0, err = ec.unmarshalOPlayerFilter2gitlabcomsiimplespbettingbettingfeedpkgmodelsPlayerFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["page"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["page"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["perPage"]; ok {
		arg2, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["perPage"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["sortField"]; ok {
		arg3, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sortField"] = arg3
	var arg4 *string
	if tmp, ok := rawArgs["sortOrder"]; ok {
		arg4, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sortOrder"] = arg4
	return args, nil
}

func (ec *executionContext) field_Query_allPoolDefaults_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.PoolDefaultFilter
	if tmp, ok := rawArgs["filter"]; ok {
		arg0, err = ec.unmarshalOPoolDefaultFilter2gitlabcomsiimplespbettingbettingfeedpkgmodelsPoolDefaultFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["page"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["page"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["perPage"]; ok {
		arg2, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["perPage"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["sortField"]; ok {
		arg3, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sortField"] = arg3
	var arg4 *string
	if tmp, ok := rawArgs["sortOrder"]; ok {
		arg4, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sortOrder"] = arg4
	return args, nil
}

func (ec *executionContext) field_Query_allPools_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.PoolFilter
	if tmp, ok := rawArgs["filter"]; ok {
		arg0, err = ec.unmarshalOPoolFilter2gitlabcomsiimplespbettingbettingfeedpkgmodelsPoolFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["page"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["page"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["perPage"]; ok {
		arg2, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["perPage"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["sortField"]; ok {
		arg3, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sortField"] = arg3
	var arg4 *string
	if tmp, ok := rawArgs["sortOrder"]; ok {
		arg4, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sortOrder"] = arg4
	return args, nil
}

func (ec *executionContext) field_Query_allUsers_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.UserFilter
	if tmp, ok := rawArgs["filter"]; ok {
		arg0, err = ec.unmarshalOUserFilter2gitlabcomsiimplespbettingbettingfeedpkgmodelsUserFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["page"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["page"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["perPage"]; ok {
		arg2, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["perPage"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["sortField"]; ok {
		arg3, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sortField"] = arg3
	var arg4 *string
	if tmp, ok := rawArgs["sortOrder"]; ok {
		arg4, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sortOrder"] = arg4
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _Audit_id(ctx context.Context, field graphql.CollectedField, obj *models.Audit) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Audit",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Audit().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Audit_time(ctx context.Context, field graphql.CollectedField, obj *models.Audit) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Audit",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Time, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) _Audit_targetId(ctx context.Context, field graphql.CollectedField, obj *models.Audit) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Audit",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Audit().TargetID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Audit_targetType(ctx context.Context, field graphql.CollectedField, obj *models.Audit) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Audit",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TargetType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Audit_user(ctx context.Context, field graphql.CollectedField, obj *models.Audit) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Audit",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Audit().User(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.User)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNUser2gitlabcomsiimplespbettingbettingfeedpkgmodelsUser(ctx, field.Selections, res)
}

func (ec *executionContext) _Audit_editAction(ctx context.Context, field graphql.CollectedField, obj *models.Audit) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Audit",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EditAction, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.EditAction)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNEditAction2gitlabcomsiimplespbettingbettingfeedpkgmodelsEditAction(ctx, field.Selections, res)
}

func (ec *executionContext) _Audit_content(ctx context.Context, field graphql.CollectedField, obj *models.Audit) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Audit",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Content, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Competitor_id(ctx context.Context, field graphql.CollectedField, obj *models.Competitor) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Competitor",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Competitor().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Competitor_externalId(ctx context.Context, field graphql.CollectedField, obj *models.Competitor) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Competitor",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExternalID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Competitor_name(ctx context.Context, field graphql.CollectedField, obj *models.Competitor) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Competitor",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Competitor_logo(ctx context.Context, field graphql.CollectedField, obj *models.Competitor) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Competitor",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Logo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Competitor_matches(ctx context.Context, field graphql.CollectedField, obj *models.Competitor) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Competitor",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Matches, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]models.Match)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOMatch2gitlabcomsiimplespbettingbettingfeedpkgmodelsMatch(ctx, field.Selections, res)
}

func (ec *executionContext) _ConsolationPrize_guarantee(ctx context.Context, field graphql.CollectedField, obj *models.ConsolationPrize) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ConsolationPrize",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ConsolationPrize().Guarantee(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDecimal2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ConsolationPrize_carryIn(ctx context.Context, field graphql.CollectedField, obj *models.ConsolationPrize) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ConsolationPrize",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ConsolationPrize().CarryIn(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDecimal2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ConsolationPrize_allocation(ctx context.Context, field graphql.CollectedField, obj *models.ConsolationPrize) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ConsolationPrize",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ConsolationPrize().Allocation(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDecimal2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Event_id(ctx context.Context, field graphql.CollectedField, obj *models.Event) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Event",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Event().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Event_name(ctx context.Context, field graphql.CollectedField, obj *models.Event) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Event",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Event_externalId(ctx context.Context, field graphql.CollectedField, obj *models.Event) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Event",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExternalID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Event_type(ctx context.Context, field graphql.CollectedField, obj *models.Event) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Event",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.EventType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNEventType2gitlabcomsiimplespbettingbettingfeedpkgmodelsEventType(ctx, field.Selections, res)
}

func (ec *executionContext) _Event_game(ctx context.Context, field graphql.CollectedField, obj *models.Event) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Event",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Game, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.Game)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNGame2gitlabcomsiimplespbettingbettingfeedpkgmodelsGame(ctx, field.Selections, res)
}

func (ec *executionContext) _Event_logo(ctx context.Context, field graphql.CollectedField, obj *models.Event) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Event",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Logo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Event_startDate(ctx context.Context, field graphql.CollectedField, obj *models.Event) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Event",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) _Event_endDate(ctx context.Context, field graphql.CollectedField, obj *models.Event) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Event",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) _Event_isActive(ctx context.Context, field graphql.CollectedField, obj *models.Event) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Event",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsActive, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Event_isAutogenerated(ctx context.Context, field graphql.CollectedField, obj *models.Event) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Event",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsAutogenerated, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Event_matches(ctx context.Context, field graphql.CollectedField, obj *models.Event) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Event",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Matches, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]models.Match)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNMatch2gitlabcomsiimplespbettingbettingfeedpkgmodelsMatch(ctx, field.Selections, res)
}

func (ec *executionContext) _Leg_id(ctx context.Context, field graphql.CollectedField, obj *models.Leg) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Leg",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Leg().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Leg_lastSyncTime(ctx context.Context, field graphql.CollectedField, obj *models.Leg) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Leg",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastSyncTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) _Leg_threshold(ctx context.Context, field graphql.CollectedField, obj *models.Leg) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Leg",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Leg().Threshold(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDecimal2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Leg_matchId(ctx context.Context, field graphql.CollectedField, obj *models.Leg) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Leg",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Leg().MatchID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Leg_poolId(ctx context.Context, field graphql.CollectedField, obj *models.Leg) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Leg",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Leg().PoolID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ListMetadata_count(ctx context.Context, field graphql.CollectedField, obj *models.ListMetadata) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ListMetadata",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _Match_id(ctx context.Context, field graphql.CollectedField, obj *models.Match) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Match",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Match().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Match_eventId(ctx context.Context, field graphql.CollectedField, obj *models.Match) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Match",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Match().EventID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Match_externalId(ctx context.Context, field graphql.CollectedField, obj *models.Match) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Match",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExternalID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Match_name(ctx context.Context, field graphql.CollectedField, obj *models.Match) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Match",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Match_description(ctx context.Context, field graphql.CollectedField, obj *models.Match) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Match",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Match_startTime(ctx context.Context, field graphql.CollectedField, obj *models.Match) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Match",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) _Match_isActive(ctx context.Context, field graphql.CollectedField, obj *models.Match) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Match",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsActive, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Match_isAutogenerated(ctx context.Context, field graphql.CollectedField, obj *models.Match) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Match",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsAutogenerated, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Match_internalStatus(ctx context.Context, field graphql.CollectedField, obj *models.Match) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Match",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InternalStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.MatchInternalStatus)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNMatchInternalStatus2gitlabcomsiimplespbettingbettingfeedpkgmodelsMatchInternalStatus(ctx, field.Selections, res)
}

func (ec *executionContext) _Match_eventStage(ctx context.Context, field graphql.CollectedField, obj *models.Match) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Match",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EventStage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Match_competitors(ctx context.Context, field graphql.CollectedField, obj *models.Match) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Match",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Competitors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]models.Competitor)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNCompetitor2gitlabcomsiimplespbettingbettingfeedpkgmodelsCompetitor(ctx, field.Selections, res)
}

func (ec *executionContext) _Match_statistics(ctx context.Context, field graphql.CollectedField, obj *models.Match) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Match",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Match().Statistics(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNJSON2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Match_teamScores(ctx context.Context, field graphql.CollectedField, obj *models.Match) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Match",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Match().TeamScores(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.TeamScore)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNTeamScore2gitlabcomsiimplespbettingbettingfeedpkgmodelsTeamScore(ctx, field.Selections, res)
}

func (ec *executionContext) _Match_teamOuScores(ctx context.Context, field graphql.CollectedField, obj *models.Match) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Match",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Match().TeamOuScores(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.TeamScore)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNTeamScore2gitlabcomsiimplespbettingbettingfeedpkgmodelsTeamScore(ctx, field.Selections, res)
}

func (ec *executionContext) _Match_teamWinProbabilities(ctx context.Context, field graphql.CollectedField, obj *models.Match) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Match",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Match().TeamWinProbabilities(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.TeamWinProbability)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNTeamWinProbability2gitlabcomsiimplespbettingbettingfeedpkgmodelsTeamWinProbability(ctx, field.Selections, res)
}

func (ec *executionContext) _Match_format(ctx context.Context, field graphql.CollectedField, obj *models.Match) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Match",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Format, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.MatchFormat)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNMatchFormat2gitlabcomsiimplespbettingbettingfeedpkgmodelsMatchFormat(ctx, field.Selections, res)
}

func (ec *executionContext) _Match_history(ctx context.Context, field graphql.CollectedField, obj *models.Match) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Match",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Match().History(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.Audit)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOAudit2gitlabcomsiimplespbettingbettingfeedpkgmodelsAudit(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_createUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_createUser_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateUser(rctx, args["input"].(models.CreateUserInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.User)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNUser2gitlabcomsiimplespbettingbettingfeedpkgmodelsUser(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_updateUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_updateUser_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateUser(rctx, args["input"].(models.UpdateUserInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.User)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNUser2gitlabcomsiimplespbettingbettingfeedpkgmodelsUser(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_createSession(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_createSession_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateSession(rctx, args["input"].(models.AuthInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Session)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNSession2gitlabcomsiimplespbettingbettingfeedpkgmodelsSession(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_createEvent(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_createEvent_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateEvent(rctx, args["input"].(models.CreateEventInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Event)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNEvent2gitlabcomsiimplespbettingbettingfeedpkgmodelsEvent(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_updateEvent(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_updateEvent_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateEvent(rctx, args["input"].(models.UpdateEventInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Event)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNEvent2gitlabcomsiimplespbettingbettingfeedpkgmodelsEvent(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_deleteEvent(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_deleteEvent_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteEvent(rctx, args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Event)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNEvent2gitlabcomsiimplespbettingbettingfeedpkgmodelsEvent(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_createMatch(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_createMatch_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateMatch(rctx, args["input"].(models.CreateMatchInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Match)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNMatch2gitlabcomsiimplespbettingbettingfeedpkgmodelsMatch(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_updateMatch(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_updateMatch_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateMatch(rctx, args["input"].(models.UpdateMatchInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Match)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNMatch2gitlabcomsiimplespbettingbettingfeedpkgmodelsMatch(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_deleteMatch(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_deleteMatch_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteMatch(rctx, args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Match)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNMatch2gitlabcomsiimplespbettingbettingfeedpkgmodelsMatch(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_createCompetitor(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_createCompetitor_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateCompetitor(rctx, args["input"].(models.CreateCompetitorInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Competitor)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNCompetitor2gitlabcomsiimplespbettingbettingfeedpkgmodelsCompetitor(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_updateCompetitor(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_updateCompetitor_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateCompetitor(rctx, args["input"].(models.UpdateCompetitorInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Competitor)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNCompetitor2gitlabcomsiimplespbettingbettingfeedpkgmodelsCompetitor(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_deleteCompetitor(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_deleteCompetitor_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteCompetitor(rctx, args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Competitor)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNCompetitor2gitlabcomsiimplespbettingbettingfeedpkgmodelsCompetitor(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_createPlayer(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_createPlayer_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreatePlayer(rctx, args["input"].(models.CreatePlayerInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Player)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNPlayer2gitlabcomsiimplespbettingbettingfeedpkgmodelsPlayer(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_updatePlayer(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_updatePlayer_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdatePlayer(rctx, args["input"].(models.UpdatePlayerInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Player)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNPlayer2gitlabcomsiimplespbettingbettingfeedpkgmodelsPlayer(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_deletePlayer(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_deletePlayer_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeletePlayer(rctx, args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Player)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNPlayer2gitlabcomsiimplespbettingbettingfeedpkgmodelsPlayer(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_createPool(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_createPool_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreatePool(rctx, args["input"].(models.CreatePoolInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Pool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNPool2gitlabcomsiimplespbettingbettingfeedpkgmodelsPool(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_updatePool(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_updatePool_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdatePool(rctx, args["input"].(models.UpdatePoolInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Pool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNPool2gitlabcomsiimplespbettingbettingfeedpkgmodelsPool(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_deletePool(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_deletePool_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeletePool(rctx, args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Pool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNPool2gitlabcomsiimplespbettingbettingfeedpkgmodelsPool(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_createPoolDefault(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_createPoolDefault_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreatePoolDefault(rctx, args["input"].(models.CreatePoolDefaultInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.PoolDefault)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNPoolDefault2gitlabcomsiimplespbettingbettingfeedpkgmodelsPoolDefault(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_updatePoolDefault(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_updatePoolDefault_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdatePoolDefault(rctx, args["input"].(models.UpdatePoolDefaultInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.PoolDefault)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNPoolDefault2gitlabcomsiimplespbettingbettingfeedpkgmodelsPoolDefault(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_deletePoolDefault(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_deletePoolDefault_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeletePoolDefault(rctx, args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.PoolDefault)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNPoolDefault2gitlabcomsiimplespbettingbettingfeedpkgmodelsPoolDefault(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_createLeg(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_createLeg_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateLeg(rctx, args["input"].(models.CreateLegInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Leg)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNLeg2gitlabcomsiimplespbettingbettingfeedpkgmodelsLeg(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_updateLeg(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_updateLeg_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateLeg(rctx, args["input"].(models.UpdateLegInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Leg)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNLeg2gitlabcomsiimplespbettingbettingfeedpkgmodelsLeg(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_deleteLeg(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_deleteLeg_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteLeg(rctx, args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Leg)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNLeg2gitlabcomsiimplespbettingbettingfeedpkgmodelsLeg(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_createOverUnderDefault(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_createOverUnderDefault_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateOverUnderDefault(rctx, args["input"].(models.CreateOverUnderDefaultInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.OverUnderDefault)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNOverUnderDefault2gitlabcomsiimplespbettingbettingfeedpkgmodelsOverUnderDefault(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_updateOverUnderDefault(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_updateOverUnderDefault_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateOverUnderDefault(rctx, args["input"].(models.UpdateOverUnderDefaultInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.OverUnderDefault)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNOverUnderDefault2gitlabcomsiimplespbettingbettingfeedpkgmodelsOverUnderDefault(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_deleteOverUnderDefault(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Mutation",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_deleteOverUnderDefault_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteOverUnderDefault(rctx, args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.OverUnderDefault)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNOverUnderDefault2gitlabcomsiimplespbettingbettingfeedpkgmodelsOverUnderDefault(ctx, field.Selections, res)
}

func (ec *executionContext) _OverUnderDefault_id(ctx context.Context, field graphql.CollectedField, obj *models.OverUnderDefault) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "OverUnderDefault",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.OverUnderDefault().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _OverUnderDefault_game(ctx context.Context, field graphql.CollectedField, obj *models.OverUnderDefault) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "OverUnderDefault",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Game, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.Game)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNGame2gitlabcomsiimplespbettingbettingfeedpkgmodelsGame(ctx, field.Selections, res)
}

func (ec *executionContext) _OverUnderDefault_matchFormat(ctx context.Context, field graphql.CollectedField, obj *models.OverUnderDefault) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "OverUnderDefault",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MatchFormat, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.MatchFormat)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNMatchFormat2gitlabcomsiimplespbettingbettingfeedpkgmodelsMatchFormat(ctx, field.Selections, res)
}

func (ec *executionContext) _OverUnderDefault_evenThreshold(ctx context.Context, field graphql.CollectedField, obj *models.OverUnderDefault) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "OverUnderDefault",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.OverUnderDefault().EvenThreshold(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDecimal2string(ctx, field.Selections, res)
}

func (ec *executionContext) _OverUnderDefault_favoredThreshold(ctx context.Context, field graphql.CollectedField, obj *models.OverUnderDefault) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "OverUnderDefault",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.OverUnderDefault().FavoredThreshold(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDecimal2string(ctx, field.Selections, res)
}

func (ec *executionContext) _OverUnderDefault_note(ctx context.Context, field graphql.CollectedField, obj *models.OverUnderDefault) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "OverUnderDefault",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Note, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Player_id(ctx context.Context, field graphql.CollectedField, obj *models.Player) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Player",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Player().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Player_externalId(ctx context.Context, field graphql.CollectedField, obj *models.Player) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Player",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExternalID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Player_name(ctx context.Context, field graphql.CollectedField, obj *models.Player) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Player",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Player_nickname(ctx context.Context, field graphql.CollectedField, obj *models.Player) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Player",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nickname, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Player_teamId(ctx context.Context, field graphql.CollectedField, obj *models.Player) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Player",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Player().TeamID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Pool_id(ctx context.Context, field graphql.CollectedField, obj *models.Pool) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Pool",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Pool().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Pool_name(ctx context.Context, field graphql.CollectedField, obj *models.Pool) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Pool",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Pool_type(ctx context.Context, field graphql.CollectedField, obj *models.Pool) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Pool",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.PoolType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNPoolType2gitlabcomsiimplespbettingbettingfeedpkgmodelsPoolType(ctx, field.Selections, res)
}

func (ec *executionContext) _Pool_isActive(ctx context.Context, field graphql.CollectedField, obj *models.Pool) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Pool",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsActive, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Pool_guarantee(ctx context.Context, field graphql.CollectedField, obj *models.Pool) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Pool",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Pool().Guarantee(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDecimal2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Pool_carryIn(ctx context.Context, field graphql.CollectedField, obj *models.Pool) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Pool",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Pool().CarryIn(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDecimal2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Pool_allocation(ctx context.Context, field graphql.CollectedField, obj *models.Pool) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Pool",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Pool().Allocation(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDecimal2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Pool_note(ctx context.Context, field graphql.CollectedField, obj *models.Pool) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Pool",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Note, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Pool_unitValue(ctx context.Context, field graphql.CollectedField, obj *models.Pool) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Pool",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Pool().UnitValue(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDecimal2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Pool_minUnitPerLine(ctx context.Context, field graphql.CollectedField, obj *models.Pool) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Pool",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Pool().MinUnitPerLine(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDecimal2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Pool_maxUnitPerLine(ctx context.Context, field graphql.CollectedField, obj *models.Pool) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Pool",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Pool().MaxUnitPerLine(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDecimal2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Pool_minUnitPerTicket(ctx context.Context, field graphql.CollectedField, obj *models.Pool) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Pool",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Pool().MinUnitPerTicket(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDecimal2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Pool_maxUnitPerTicket(ctx context.Context, field graphql.CollectedField, obj *models.Pool) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Pool",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Pool().MaxUnitPerTicket(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDecimal2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Pool_currency(ctx context.Context, field graphql.CollectedField, obj *models.Pool) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Pool",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Currency, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.PoolCurrency)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNPoolCurrency2gitlabcomsiimplespbettingbettingfeedpkgmodelsPoolCurrency(ctx, field.Selections, res)
}

func (ec *executionContext) _Pool_isAutogenerated(ctx context.Context, field graphql.CollectedField, obj *models.Pool) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Pool",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsAutogenerated, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Pool_lastSyncTime(ctx context.Context, field graphql.CollectedField, obj *models.Pool) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Pool",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastSyncTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) _Pool_syncedColossusStatus(ctx context.Context, field graphql.CollectedField, obj *models.Pool) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Pool",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SyncedColossusStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.PoolStatus)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNPoolStatus2gitlabcomsiimplespbettingbettingfeedpkgmodelsPoolStatus(ctx, field.Selections, res)
}

func (ec *executionContext) _Pool_game(ctx context.Context, field graphql.CollectedField, obj *models.Pool) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Pool",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Game, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.Game)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNGame2gitlabcomsiimplespbettingbettingfeedpkgmodelsGame(ctx, field.Selections, res)
}

func (ec *executionContext) _Pool_legs(ctx context.Context, field graphql.CollectedField, obj *models.Pool) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Pool",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Legs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]models.Leg)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNLeg2gitlabcomsiimplespbettingbettingfeedpkgmodelsLeg(ctx, field.Selections, res)
}

func (ec *executionContext) _Pool_consolationPrizes(ctx context.Context, field graphql.CollectedField, obj *models.Pool) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Pool",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Pool().ConsolationPrizes(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.ConsolationPrize)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOConsolationPrize2gitlabcomsiimplespbettingbettingfeedpkgmodelsConsolationPrize(ctx, field.Selections, res)
}

func (ec *executionContext) _PoolDefault_id(ctx context.Context, field graphql.CollectedField, obj *models.PoolDefault) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "PoolDefault",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.PoolDefault().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PoolDefault_legCount(ctx context.Context, field graphql.CollectedField, obj *models.PoolDefault) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "PoolDefault",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.PoolDefault().LegCount(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDecimal2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PoolDefault_game(ctx context.Context, field graphql.CollectedField, obj *models.PoolDefault) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "PoolDefault",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Game, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.Game)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNGame2gitlabcomsiimplespbettingbettingfeedpkgmodelsGame(ctx, field.Selections, res)
}

func (ec *executionContext) _PoolDefault_type(ctx context.Context, field graphql.CollectedField, obj *models.PoolDefault) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "PoolDefault",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.PoolType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNPoolType2gitlabcomsiimplespbettingbettingfeedpkgmodelsPoolType(ctx, field.Selections, res)
}

func (ec *executionContext) _PoolDefault_guarantee(ctx context.Context, field graphql.CollectedField, obj *models.PoolDefault) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "PoolDefault",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.PoolDefault().Guarantee(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDecimal2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PoolDefault_carryIn(ctx context.Context, field graphql.CollectedField, obj *models.PoolDefault) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "PoolDefault",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.PoolDefault().CarryIn(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDecimal2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PoolDefault_allocation(ctx context.Context, field graphql.CollectedField, obj *models.PoolDefault) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "PoolDefault",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.PoolDefault().Allocation(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDecimal2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PoolDefault_unitValue(ctx context.Context, field graphql.CollectedField, obj *models.PoolDefault) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "PoolDefault",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.PoolDefault().UnitValue(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDecimal2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PoolDefault_minUnitPerLine(ctx context.Context, field graphql.CollectedField, obj *models.PoolDefault) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "PoolDefault",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.PoolDefault().MinUnitPerLine(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDecimal2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PoolDefault_maxUnitPerLine(ctx context.Context, field graphql.CollectedField, obj *models.PoolDefault) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "PoolDefault",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.PoolDefault().MaxUnitPerLine(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDecimal2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PoolDefault_minUnitPerTicket(ctx context.Context, field graphql.CollectedField, obj *models.PoolDefault) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "PoolDefault",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.PoolDefault().MinUnitPerTicket(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDecimal2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PoolDefault_maxUnitPerTicket(ctx context.Context, field graphql.CollectedField, obj *models.PoolDefault) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "PoolDefault",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.PoolDefault().MaxUnitPerTicket(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDecimal2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PoolDefault_currency(ctx context.Context, field graphql.CollectedField, obj *models.PoolDefault) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "PoolDefault",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Currency, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.PoolCurrency)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNPoolCurrency2gitlabcomsiimplespbettingbettingfeedpkgmodelsPoolCurrency(ctx, field.Selections, res)
}

func (ec *executionContext) _PoolDefault_note(ctx context.Context, field graphql.CollectedField, obj *models.PoolDefault) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "PoolDefault",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Note, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_Event(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_Event_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Event(rctx, args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Event)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNEvent2gitlabcomsiimplespbettingbettingfeedpkgmodelsEvent(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_allEvents(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_allEvents_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AllEvents(rctx, args["filter"].(*models.EventFilter), args["page"].(*int), args["perPage"].(*int), args["sortField"].(*string), args["sortOrder"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Event)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNEvent2gitlabcomsiimplespbettingbettingfeedpkgmodelsEvent(ctx, field.Selections, res)
}

func (ec *executionContext) _Query__allEventsMeta(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query__allEventsMeta_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query()._allEventsMeta(rctx, args["filter"].(*models.EventFilter), args["page"].(*int), args["perPage"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.ListMetadata)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOListMetadata2gitlabcomsiimplespbettingbettingfeedpkgmodelsListMetadata(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_Pool(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_Pool_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Pool(rctx, args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Pool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNPool2gitlabcomsiimplespbettingbettingfeedpkgmodelsPool(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_allPools(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_allPools_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AllPools(rctx, args["filter"].(*models.PoolFilter), args["page"].(*int), args["perPage"].(*int), args["sortField"].(*string), args["sortOrder"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Pool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNPool2gitlabcomsiimplespbettingbettingfeedpkgmodelsPool(ctx, field.Selections, res)
}

func (ec *executionContext) _Query__allPoolsMeta(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query__allPoolsMeta_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query()._allPoolsMeta(rctx, args["filter"].(*models.PoolFilter), args["page"].(*int), args["perPage"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.ListMetadata)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOListMetadata2gitlabcomsiimplespbettingbettingfeedpkgmodelsListMetadata(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_PoolDefault(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_PoolDefault_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().PoolDefault(rctx, args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.PoolDefault)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNPoolDefault2gitlabcomsiimplespbettingbettingfeedpkgmodelsPoolDefault(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_allPoolDefaults(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_allPoolDefaults_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AllPoolDefaults(rctx, args["filter"].(*models.PoolDefaultFilter), args["page"].(*int), args["perPage"].(*int), args["sortField"].(*string), args["sortOrder"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.PoolDefault)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNPoolDefault2gitlabcomsiimplespbettingbettingfeedpkgmodelsPoolDefault(ctx, field.Selections, res)
}

func (ec *executionContext) _Query__allPoolDefaultsMeta(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query__allPoolDefaultsMeta_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query()._allPoolDefaultsMeta(rctx, args["filter"].(*models.PoolDefaultFilter), args["page"].(*int), args["perPage"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.ListMetadata)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOListMetadata2gitlabcomsiimplespbettingbettingfeedpkgmodelsListMetadata(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_Leg(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_Leg_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Leg(rctx, args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Leg)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNLeg2gitlabcomsiimplespbettingbettingfeedpkgmodelsLeg(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_allLegs(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_allLegs_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AllLegs(rctx, args["filter"].(*models.LegFilter), args["page"].(*int), args["perPage"].(*int), args["sortField"].(*string), args["sortOrder"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Leg)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNLeg2gitlabcomsiimplespbettingbettingfeedpkgmodelsLeg(ctx, field.Selections, res)
}

func (ec *executionContext) _Query__allLegsMeta(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query__allLegsMeta_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query()._allLegsMeta(rctx, args["filter"].(*models.LegFilter), args["page"].(*int), args["perPage"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.ListMetadata)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOListMetadata2gitlabcomsiimplespbettingbettingfeedpkgmodelsListMetadata(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_Match(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_Match_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Match(rctx, args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Match)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNMatch2gitlabcomsiimplespbettingbettingfeedpkgmodelsMatch(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_allMatches(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_allMatches_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AllMatches(rctx, args["filter"].(*models.MatchFilter), args["page"].(*int), args["perPage"].(*int), args["sortField"].(*string), args["sortOrder"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Match)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNMatch2gitlabcomsiimplespbettingbettingfeedpkgmodelsMatch(ctx, field.Selections, res)
}

func (ec *executionContext) _Query__allMatchesMeta(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query__allMatchesMeta_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query()._allMatchesMeta(rctx, args["filter"].(*models.MatchFilter), args["page"].(*int), args["perPage"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.ListMetadata)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOListMetadata2gitlabcomsiimplespbettingbettingfeedpkgmodelsListMetadata(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_Competitor(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_Competitor_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Competitor(rctx, args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Competitor)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNCompetitor2gitlabcomsiimplespbettingbettingfeedpkgmodelsCompetitor(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_allCompetitors(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_allCompetitors_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AllCompetitors(rctx, args["filter"].(*models.CompetitorFilter), args["page"].(*int), args["perPage"].(*int), args["sortField"].(*string), args["sortOrder"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Competitor)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNCompetitor2gitlabcomsiimplespbettingbettingfeedpkgmodelsCompetitor(ctx, field.Selections, res)
}

func (ec *executionContext) _Query__allCompetitorsMeta(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query__allCompetitorsMeta_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query()._allCompetitorsMeta(rctx, args["filter"].(*models.CompetitorFilter), args["page"].(*int), args["perPage"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.ListMetadata)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOListMetadata2gitlabcomsiimplespbettingbettingfeedpkgmodelsListMetadata(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_Player(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_Player_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Player(rctx, args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Player)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNPlayer2gitlabcomsiimplespbettingbettingfeedpkgmodelsPlayer(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_allPlayers(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_allPlayers_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AllPlayers(rctx, args["filter"].(*models.PlayerFilter), args["page"].(*int), args["perPage"].(*int), args["sortField"].(*string), args["sortOrder"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Player)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNPlayer2gitlabcomsiimplespbettingbettingfeedpkgmodelsPlayer(ctx, field.Selections, res)
}

func (ec *executionContext) _Query__allPlayersMeta(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query__allPlayersMeta_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query()._allPlayersMeta(rctx, args["filter"].(*models.PlayerFilter), args["page"].(*int), args["perPage"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.ListMetadata)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOListMetadata2gitlabcomsiimplespbettingbettingfeedpkgmodelsListMetadata(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_User(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_User_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().User(rctx, args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.User)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNUser2gitlabcomsiimplespbettingbettingfeedpkgmodelsUser(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_allUsers(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_allUsers_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AllUsers(rctx, args["filter"].(*models.UserFilter), args["page"].(*int), args["perPage"].(*int), args["sortField"].(*string), args["sortOrder"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.User)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNUser2gitlabcomsiimplespbettingbettingfeedpkgmodelsUser(ctx, field.Selections, res)
}

func (ec *executionContext) _Query__allUsersMeta(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query__allUsersMeta_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query()._allUsersMeta(rctx, args["filter"].(*models.UserFilter), args["page"].(*int), args["perPage"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.ListMetadata)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOListMetadata2gitlabcomsiimplespbettingbettingfeedpkgmodelsListMetadata(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_Audit(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_Audit_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Audit(rctx, args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.Audit)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNAudit2gitlabcomsiimplespbettingbettingfeedpkgmodelsAudit(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_allAudits(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_allAudits_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AllAudits(rctx, args["filter"].(*models.AuditFilter), args["page"].(*int), args["perPage"].(*int), args["sortField"].(*string), args["sortOrder"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Audit)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNAudit2gitlabcomsiimplespbettingbettingfeedpkgmodelsAudit(ctx, field.Selections, res)
}

func (ec *executionContext) _Query__allAuditsMeta(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query__allAuditsMeta_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query()._allAuditsMeta(rctx, args["filter"].(*models.AuditFilter), args["page"].(*int), args["perPage"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.ListMetadata)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOListMetadata2gitlabcomsiimplespbettingbettingfeedpkgmodelsListMetadata(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_OverUnderDefault(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_OverUnderDefault_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().OverUnderDefault(rctx, args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.OverUnderDefault)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNOverUnderDefault2gitlabcomsiimplespbettingbettingfeedpkgmodelsOverUnderDefault(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_allOverUnderDefaults(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_allOverUnderDefaults_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AllOverUnderDefaults(rctx, args["filter"].(*models.OverUnderDefaultFilter), args["page"].(*int), args["perPage"].(*int), args["sortField"].(*string), args["sortOrder"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.OverUnderDefault)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNOverUnderDefault2gitlabcomsiimplespbettingbettingfeedpkgmodelsOverUnderDefault(ctx, field.Selections, res)
}

func (ec *executionContext) _Query__allOverUnderDefaultsMeta(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query__allOverUnderDefaultsMeta_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query()._allOverUnderDefaultsMeta(rctx, args["filter"].(*models.OverUnderDefaultFilter), args["page"].(*int), args["perPage"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.ListMetadata)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOListMetadata2gitlabcomsiimplespbettingbettingfeedpkgmodelsListMetadata(ctx, field.Selections, res)
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query___type_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx, field.Selections, res)
}

func (ec *executionContext) _Session_token(ctx context.Context, field graphql.CollectedField, obj *models.Session) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Session",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Token, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TeamProbabilities_teamId(ctx context.Context, field graphql.CollectedField, obj *models.TeamProbabilities) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "TeamProbabilities",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TeamID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TeamProbabilities_probability(ctx context.Context, field graphql.CollectedField, obj *models.TeamProbabilities) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "TeamProbabilities",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Probability, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _TeamScore_teamId(ctx context.Context, field graphql.CollectedField, obj *models.TeamScore) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "TeamScore",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TeamID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TeamScore_score(ctx context.Context, field graphql.CollectedField, obj *models.TeamScore) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "TeamScore",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Score, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _TeamScores_teamId(ctx context.Context, field graphql.CollectedField, obj *models.TeamScores) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "TeamScores",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TeamID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TeamScores_score(ctx context.Context, field graphql.CollectedField, obj *models.TeamScores) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "TeamScores",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Score, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _TeamWinProbability_teamId(ctx context.Context, field graphql.CollectedField, obj *models.TeamWinProbability) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "TeamWinProbability",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TeamID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TeamWinProbability_probability(ctx context.Context, field graphql.CollectedField, obj *models.TeamWinProbability) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "TeamWinProbability",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Probability, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDecimal2string(ctx, field.Selections, res)
}

func (ec *executionContext) _User_id(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) _User_email(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Email, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _User_token(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Token, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _User_accessRole(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "User",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AccessRole, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.AccessRole)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNAccessRole2gitlabcomsiimplespbettingbettingfeedpkgmodelsAccessRole(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__DirectiveLocation2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field___Type_fields_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field___Type_enumValues_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputAuditFilter(ctx context.Context, obj interface{}) (models.AuditFilter, error) {
	var it models.AuditFilter
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error
			it.ID, err = ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "targetId":
			var err error
			it.TargetID, err = ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "targetType":
			var err error
			it.TargetType, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "userId":
			var err error
			it.UserID, err = ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "editAction":
			var err error
			it.EditAction, err = ec.unmarshalOEditAction2gitlabcomsiimplespbettingbettingfeedpkgmodelsEditAction(ctx, v)
			if err != nil {
				return it, err
			}
		case "ids":
			var err error
			it.Ids, err = ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAuthInput(ctx context.Context, obj interface{}) (models.AuthInput, error) {
	var it models.AuthInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "email":
			var err error
			it.Email, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "password":
			var err error
			it.Password, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCompetitorFilter(ctx context.Context, obj interface{}) (models.CompetitorFilter, error) {
	var it models.CompetitorFilter
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error
			it.ID, err = ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error
			it.Name, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "externalId":
			var err error
			it.ExternalID, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "match_id":
			var err error
			it.MatchID, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "ids":
			var err error
			it.Ids, err = ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateCompetitorInput(ctx context.Context, obj interface{}) (models.CreateCompetitorInput, error) {
	var it models.CreateCompetitorInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name":
			var err error
			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "logo":
			var err error
			it.Logo, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateEventInput(ctx context.Context, obj interface{}) (models.CreateEventInput, error) {
	var it models.CreateEventInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name":
			var err error
			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "type":
			var err error
			it.Type, err = ec.unmarshalNEventType2gitlabcomsiimplespbettingbettingfeedpkgmodelsEventType(ctx, v)
			if err != nil {
				return it, err
			}
		case "game":
			var err error
			it.Game, err = ec.unmarshalNGame2gitlabcomsiimplespbettingbettingfeedpkgmodelsGame(ctx, v)
			if err != nil {
				return it, err
			}
		case "logo":
			var err error
			it.Logo, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "startDate":
			var err error
			it.StartDate, err = ec.unmarshalNTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "endDate":
			var err error
			it.EndDate, err = ec.unmarshalNTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "isActive":
			var err error
			it.IsActive, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateLegInput(ctx context.Context, obj interface{}) (models.CreateLegInput, error) {
	var it models.CreateLegInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "matchId":
			var err error
			it.MatchID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "poolId":
			var err error
			it.PoolID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "threshold":
			var err error
			it.Threshold, err = ec.unmarshalODecimal2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateMatchInput(ctx context.Context, obj interface{}) (models.CreateMatchInput, error) {
	var it models.CreateMatchInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name":
			var err error
			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "eventId":
			var err error
			it.EventID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "description":
			var err error
			it.Description, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "startTime":
			var err error
			it.StartTime, err = ec.unmarshalNTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "isActive":
			var err error
			it.IsActive, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "internalStatus":
			var err error
			it.InternalStatus, err = ec.unmarshalNMatchInternalStatus2gitlabcomsiimplespbettingbettingfeedpkgmodelsMatchInternalStatus(ctx, v)
			if err != nil {
				return it, err
			}
		case "eventStage":
			var err error
			it.EventStage, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "format":
			var err error
			it.Format, err = ec.unmarshalNMatchFormat2gitlabcomsiimplespbettingbettingfeedpkgmodelsMatchFormat(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateOverUnderDefaultInput(ctx context.Context, obj interface{}) (models.CreateOverUnderDefaultInput, error) {
	var it models.CreateOverUnderDefaultInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "game":
			var err error
			it.Game, err = ec.unmarshalNGame2gitlabcomsiimplespbettingbettingfeedpkgmodelsGame(ctx, v)
			if err != nil {
				return it, err
			}
		case "matchFormat":
			var err error
			it.MatchFormat, err = ec.unmarshalNMatchFormat2gitlabcomsiimplespbettingbettingfeedpkgmodelsMatchFormat(ctx, v)
			if err != nil {
				return it, err
			}
		case "evenThreshold":
			var err error
			it.EvenThreshold, err = ec.unmarshalNDecimal2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "favoredThreshold":
			var err error
			it.FavoredThreshold, err = ec.unmarshalNDecimal2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "note":
			var err error
			it.Note, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreatePlayerInput(ctx context.Context, obj interface{}) (models.CreatePlayerInput, error) {
	var it models.CreatePlayerInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name":
			var err error
			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nickname":
			var err error
			it.Nickname, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "teamId":
			var err error
			it.TeamID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreatePoolDefaultInput(ctx context.Context, obj interface{}) (models.CreatePoolDefaultInput, error) {
	var it models.CreatePoolDefaultInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "legCount":
			var err error
			it.LegCount, err = ec.unmarshalNDecimal2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "game":
			var err error
			it.Game, err = ec.unmarshalNGame2gitlabcomsiimplespbettingbettingfeedpkgmodelsGame(ctx, v)
			if err != nil {
				return it, err
			}
		case "type":
			var err error
			it.Type, err = ec.unmarshalNPoolType2gitlabcomsiimplespbettingbettingfeedpkgmodelsPoolType(ctx, v)
			if err != nil {
				return it, err
			}
		case "guarantee":
			var err error
			it.Guarantee, err = ec.unmarshalNDecimal2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "carryIn":
			var err error
			it.CarryIn, err = ec.unmarshalNDecimal2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "allocation":
			var err error
			it.Allocation, err = ec.unmarshalNDecimal2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "unitValue":
			var err error
			it.UnitValue, err = ec.unmarshalNDecimal2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "minUnitPerLine":
			var err error
			it.MinUnitPerLine, err = ec.unmarshalNDecimal2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "maxUnitPerLine":
			var err error
			it.MaxUnitPerLine, err = ec.unmarshalNDecimal2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "minUnitPerTicket":
			var err error
			it.MinUnitPerTicket, err = ec.unmarshalNDecimal2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "maxUnitPerTicket":
			var err error
			it.MaxUnitPerTicket, err = ec.unmarshalNDecimal2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "currency":
			var err error
			it.Currency, err = ec.unmarshalNPoolCurrency2gitlabcomsiimplespbettingbettingfeedpkgmodelsPoolCurrency(ctx, v)
			if err != nil {
				return it, err
			}
		case "note":
			var err error
			it.Note, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreatePoolInput(ctx context.Context, obj interface{}) (models.CreatePoolInput, error) {
	var it models.CreatePoolInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name":
			var err error
			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "type":
			var err error
			it.Type, err = ec.unmarshalNPoolType2gitlabcomsiimplespbettingbettingfeedpkgmodelsPoolType(ctx, v)
			if err != nil {
				return it, err
			}
		case "guarantee":
			var err error
			it.Guarantee, err = ec.unmarshalNDecimal2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "carryIn":
			var err error
			it.CarryIn, err = ec.unmarshalNDecimal2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "allocation":
			var err error
			it.Allocation, err = ec.unmarshalNDecimal2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "game":
			var err error
			it.Game, err = ec.unmarshalNGame2gitlabcomsiimplespbettingbettingfeedpkgmodelsGame(ctx, v)
			if err != nil {
				return it, err
			}
		case "note":
			var err error
			it.Note, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "unitValue":
			var err error
			it.UnitValue, err = ec.unmarshalNDecimal2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "currency":
			var err error
			it.Currency, err = ec.unmarshalNPoolCurrency2gitlabcomsiimplespbettingbettingfeedpkgmodelsPoolCurrency(ctx, v)
			if err != nil {
				return it, err
			}
		case "minUnitPerLine":
			var err error
			it.MinUnitPerLine, err = ec.unmarshalNDecimal2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "maxUnitPerLine":
			var err error
			it.MaxUnitPerLine, err = ec.unmarshalNDecimal2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "minUnitPerTicket":
			var err error
			it.MinUnitPerTicket, err = ec.unmarshalNDecimal2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "maxUnitPerTicket":
			var err error
			it.MaxUnitPerTicket, err = ec.unmarshalNDecimal2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateUserInput(ctx context.Context, obj interface{}) (models.CreateUserInput, error) {
	var it models.CreateUserInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "email":
			var err error
			it.Email, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "password":
			var err error
			it.Password, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "role":
			var err error
			it.Role, err = ec.unmarshalNAccessRole2gitlabcomsiimplespbettingbettingfeedpkgmodelsAccessRole(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputEventFilter(ctx context.Context, obj interface{}) (models.EventFilter, error) {
	var it models.EventFilter
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error
			it.ID, err = ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error
			it.Name, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "isActive":
			var err error
			it.IsActive, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "game":
			var err error
			it.Game, err = ec.unmarshalOGame2gitlabcomsiimplespbettingbettingfeedpkgmodelsGame(ctx, v)
			if err != nil {
				return it, err
			}
		case "externalId":
			var err error
			it.ExternalID, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "ids":
			var err error
			it.Ids, err = ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputLegFilter(ctx context.Context, obj interface{}) (models.LegFilter, error) {
	var it models.LegFilter
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error
			it.ID, err = ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "matchId":
			var err error
			it.MatchID, err = ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "poolId":
			var err error
			it.PoolID, err = ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "ids":
			var err error
			it.Ids, err = ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMatchFilter(ctx context.Context, obj interface{}) (models.MatchFilter, error) {
	var it models.MatchFilter
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error
			it.ID, err = ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error
			it.Name, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "externalId":
			var err error
			it.ExternalID, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "isActive":
			var err error
			it.IsActive, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "isAutogenerated":
			var err error
			it.IsAutogenerated, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "internalStatus":
			var err error
			it.InternalStatus, err = ec.unmarshalOMatchInternalStatus2gitlabcomsiimplespbettingbettingfeedpkgmodelsMatchInternalStatus(ctx, v)
			if err != nil {
				return it, err
			}
		case "format":
			var err error
			it.Format, err = ec.unmarshalOMatchFormat2gitlabcomsiimplespbettingbettingfeedpkgmodelsMatchFormat(ctx, v)
			if err != nil {
				return it, err
			}
		case "eventStage":
			var err error
			it.EventStage, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "eventId":
			var err error
			it.EventID, err = ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "ids":
			var err error
			it.Ids, err = ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputOverUnderDefaultFilter(ctx context.Context, obj interface{}) (models.OverUnderDefaultFilter, error) {
	var it models.OverUnderDefaultFilter
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "game":
			var err error
			it.Game, err = ec.unmarshalOGame2gitlabcomsiimplespbettingbettingfeedpkgmodelsGame(ctx, v)
			if err != nil {
				return it, err
			}
		case "matchFormat":
			var err error
			it.MatchFormat, err = ec.unmarshalOMatchFormat2gitlabcomsiimplespbettingbettingfeedpkgmodelsMatchFormat(ctx, v)
			if err != nil {
				return it, err
			}
		case "ids":
			var err error
			it.Ids, err = ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPlayerFilter(ctx context.Context, obj interface{}) (models.PlayerFilter, error) {
	var it models.PlayerFilter
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error
			it.ID, err = ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error
			it.Name, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nickname":
			var err error
			it.Nickname, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "externalId":
			var err error
			it.ExternalID, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "teamId":
			var err error
			it.TeamID, err = ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "ids":
			var err error
			it.Ids, err = ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPoolDefaultFilter(ctx context.Context, obj interface{}) (models.PoolDefaultFilter, error) {
	var it models.PoolDefaultFilter
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "type":
			var err error
			it.Type, err = ec.unmarshalOPoolType2gitlabcomsiimplespbettingbettingfeedpkgmodelsPoolType(ctx, v)
			if err != nil {
				return it, err
			}
		case "game":
			var err error
			it.Game, err = ec.unmarshalOGame2gitlabcomsiimplespbettingbettingfeedpkgmodelsGame(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPoolFilter(ctx context.Context, obj interface{}) (models.PoolFilter, error) {
	var it models.PoolFilter
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error
			it.ID, err = ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error
			it.Name, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "isActive":
			var err error
			it.IsActive, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "isAutogenerated":
			var err error
			it.IsAutogenerated, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "poolStatus":
			var err error
			it.PoolStatus, err = ec.unmarshalOPoolStatus2gitlabcomsiimplespbettingbettingfeedpkgmodelsPoolStatus(ctx, v)
			if err != nil {
				return it, err
			}
		case "guarantee":
			var err error
			it.Guarantee, err = ec.unmarshalODecimal2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "legCount":
			var err error
			it.LegCount, err = ec.unmarshalODecimal2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "type":
			var err error
			it.Type, err = ec.unmarshalOPoolType2gitlabcomsiimplespbettingbettingfeedpkgmodelsPoolType(ctx, v)
			if err != nil {
				return it, err
			}
		case "game":
			var err error
			it.Game, err = ec.unmarshalOGame2gitlabcomsiimplespbettingbettingfeedpkgmodelsGame(ctx, v)
			if err != nil {
				return it, err
			}
		case "eventId":
			var err error
			it.EventID, err = ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSyncTimeBefore":
			var err error
			it.LastSyncTimeBefore, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "lastSyncTimeAfter":
			var err error
			it.LastSyncTimeAfter, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "ids":
			var err error
			it.Ids, err = ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateCompetitorInput(ctx context.Context, obj interface{}) (models.UpdateCompetitorInput, error) {
	var it models.UpdateCompetitorInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error
			it.ID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error
			it.Name, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "logo":
			var err error
			it.Logo, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateConsolationPrize(ctx context.Context, obj interface{}) (models.UpdateConsolationPrize, error) {
	var it models.UpdateConsolationPrize
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "guarantee":
			var err error
			it.Guarantee, err = ec.unmarshalNDecimal2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "carryIn":
			var err error
			it.CarryIn, err = ec.unmarshalNDecimal2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "allocation":
			var err error
			it.Allocation, err = ec.unmarshalNDecimal2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateEventInput(ctx context.Context, obj interface{}) (models.UpdateEventInput, error) {
	var it models.UpdateEventInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error
			it.ID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error
			it.Name, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "type":
			var err error
			it.Type, err = ec.unmarshalOEventType2gitlabcomsiimplespbettingbettingfeedpkgmodelsEventType(ctx, v)
			if err != nil {
				return it, err
			}
		case "game":
			var err error
			it.Game, err = ec.unmarshalOGame2gitlabcomsiimplespbettingbettingfeedpkgmodelsGame(ctx, v)
			if err != nil {
				return it, err
			}
		case "logo":
			var err error
			it.Logo, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "startDate":
			var err error
			it.StartDate, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "endDate":
			var err error
			it.EndDate, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "isActive":
			var err error
			it.IsActive, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateLegInput(ctx context.Context, obj interface{}) (models.UpdateLegInput, error) {
	var it models.UpdateLegInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error
			it.ID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "threshold":
			var err error
			it.Threshold, err = ec.unmarshalODecimal2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "matchId":
			var err error
			it.MatchID, err = ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "poolId":
			var err error
			it.PoolID, err = ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateMatchInput(ctx context.Context, obj interface{}) (models.UpdateMatchInput, error) {
	var it models.UpdateMatchInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error
			it.ID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error
			it.Name, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "description":
			var err error
			it.Description, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "startTime":
			var err error
			it.StartTime, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "isActive":
			var err error
			it.IsActive, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "internalStatus":
			var err error
			it.InternalStatus, err = ec.unmarshalOMatchInternalStatus2gitlabcomsiimplespbettingbettingfeedpkgmodelsMatchInternalStatus(ctx, v)
			if err != nil {
				return it, err
			}
		case "eventStage":
			var err error
			it.EventStage, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "eventId":
			var err error
			it.EventID, err = ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "teamScores":
			var err error
			it.TeamScores, err = ec.unmarshalOUpdateTeamScores2gitlabcomsiimplespbettingbettingfeedpkgmodelsUpdateTeamScores(ctx, v)
			if err != nil {
				return it, err
			}
		case "teamOuScores":
			var err error
			it.TeamOuScores, err = ec.unmarshalOUpdateTeamScores2gitlabcomsiimplespbettingbettingfeedpkgmodelsUpdateTeamScores(ctx, v)
			if err != nil {
				return it, err
			}
		case "teamWinProbabilities":
			var err error
			it.TeamWinProbabilities, err = ec.unmarshalOUpdateTeamProbabilities2gitlabcomsiimplespbettingbettingfeedpkgmodelsUpdateTeamProbabilities(ctx, v)
			if err != nil {
				return it, err
			}
		case "format":
			var err error
			it.Format, err = ec.unmarshalOMatchFormat2gitlabcomsiimplespbettingbettingfeedpkgmodelsMatchFormat(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateOverUnderDefaultInput(ctx context.Context, obj interface{}) (models.UpdateOverUnderDefaultInput, error) {
	var it models.UpdateOverUnderDefaultInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error
			it.ID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "evenThreshold":
			var err error
			it.EvenThreshold, err = ec.unmarshalODecimal2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "favoredThreshold":
			var err error
			it.FavoredThreshold, err = ec.unmarshalODecimal2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "note":
			var err error
			it.Note, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdatePlayerInput(ctx context.Context, obj interface{}) (models.UpdatePlayerInput, error) {
	var it models.UpdatePlayerInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error
			it.ID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error
			it.Name, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "nickname":
			var err error
			it.Nickname, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "teamId":
			var err error
			it.TeamID, err = ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdatePoolDefaultInput(ctx context.Context, obj interface{}) (models.UpdatePoolDefaultInput, error) {
	var it models.UpdatePoolDefaultInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error
			it.ID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "legCount":
			var err error
			it.LegCount, err = ec.unmarshalODecimal2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "game":
			var err error
			it.Game, err = ec.unmarshalOGame2gitlabcomsiimplespbettingbettingfeedpkgmodelsGame(ctx, v)
			if err != nil {
				return it, err
			}
		case "type":
			var err error
			it.Type, err = ec.unmarshalOPoolType2gitlabcomsiimplespbettingbettingfeedpkgmodelsPoolType(ctx, v)
			if err != nil {
				return it, err
			}
		case "guarantee":
			var err error
			it.Guarantee, err = ec.unmarshalODecimal2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "carryIn":
			var err error
			it.CarryIn, err = ec.unmarshalODecimal2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "allocation":
			var err error
			it.Allocation, err = ec.unmarshalODecimal2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "unitValue":
			var err error
			it.UnitValue, err = ec.unmarshalODecimal2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "minUnitPerLine":
			var err error
			it.MinUnitPerLine, err = ec.unmarshalODecimal2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "maxUnitPerLine":
			var err error
			it.MaxUnitPerLine, err = ec.unmarshalODecimal2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "minUnitPerTicket":
			var err error
			it.MinUnitPerTicket, err = ec.unmarshalODecimal2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "maxUnitPerTicket":
			var err error
			it.MaxUnitPerTicket, err = ec.unmarshalODecimal2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "currency":
			var err error
			it.Currency, err = ec.unmarshalOPoolCurrency2gitlabcomsiimplespbettingbettingfeedpkgmodelsPoolCurrency(ctx, v)
			if err != nil {
				return it, err
			}
		case "note":
			var err error
			it.Note, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdatePoolInput(ctx context.Context, obj interface{}) (models.UpdatePoolInput, error) {
	var it models.UpdatePoolInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error
			it.ID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error
			it.Name, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "isActive":
			var err error
			it.IsActive, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "guarantee":
			var err error
			it.Guarantee, err = ec.unmarshalNDecimal2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "carryIn":
			var err error
			it.CarryIn, err = ec.unmarshalNDecimal2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "allocation":
			var err error
			it.Allocation, err = ec.unmarshalNDecimal2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "note":
			var err error
			it.Note, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "unitValue":
			var err error
			it.UnitValue, err = ec.unmarshalODecimal2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "minUnitPerLine":
			var err error
			it.MinUnitPerLine, err = ec.unmarshalODecimal2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "maxUnitPerLine":
			var err error
			it.MaxUnitPerLine, err = ec.unmarshalODecimal2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "minUnitPerTicket":
			var err error
			it.MinUnitPerTicket, err = ec.unmarshalODecimal2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "maxUnitPerTicket":
			var err error
			it.MaxUnitPerTicket, err = ec.unmarshalODecimal2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "currency":
			var err error
			it.Currency, err = ec.unmarshalOPoolCurrency2gitlabcomsiimplespbettingbettingfeedpkgmodelsPoolCurrency(ctx, v)
			if err != nil {
				return it, err
			}
		case "syncedColossusStatus":
			var err error
			it.SyncedColossusStatus, err = ec.unmarshalOPoolStatus2gitlabcomsiimplespbettingbettingfeedpkgmodelsPoolStatus(ctx, v)
			if err != nil {
				return it, err
			}
		case "legsIds":
			var err error
			it.LegsIds, err = ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "consolationPrizes":
			var err error
			it.ConsolationPrizes, err = ec.unmarshalOUpdateConsolationPrize2gitlabcomsiimplespbettingbettingfeedpkgmodelsUpdateConsolationPrize(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateTeamProbabilities(ctx context.Context, obj interface{}) (models.UpdateTeamProbabilities, error) {
	var it models.UpdateTeamProbabilities
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "teamId":
			var err error
			it.TeamID, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "probability":
			var err error
			it.Probability, err = ec.unmarshalNFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateTeamScores(ctx context.Context, obj interface{}) (models.UpdateTeamScores, error) {
	var it models.UpdateTeamScores
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "teamId":
			var err error
			it.TeamID, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "score":
			var err error
			it.Score, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateUserInput(ctx context.Context, obj interface{}) (models.UpdateUserInput, error) {
	var it models.UpdateUserInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "id":
			var err error
			it.ID, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "email":
			var err error
			it.Email, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "password":
			var err error
			it.Password, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "accessRole":
			var err error
			it.AccessRole, err = ec.unmarshalOAccessRole2gitlabcomsiimplespbettingbettingfeedpkgmodelsAccessRole(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUserFilter(ctx context.Context, obj interface{}) (models.UserFilter, error) {
	var it models.UserFilter
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "email":
			var err error
			it.Email, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "role":
			var err error
			it.Role, err = ec.unmarshalOAccessRole2gitlabcomsiimplespbettingbettingfeedpkgmodelsAccessRole(ctx, v)
			if err != nil {
				return it, err
			}
		case "ids":
			var err error
			it.Ids, err = ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var auditImplementors = []string{"Audit"}

func (ec *executionContext) _Audit(ctx context.Context, sel ast.SelectionSet, obj *models.Audit) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, auditImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Audit")
		case "id":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Audit_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "time":
			out.Values[i] = ec._Audit_time(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "targetId":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Audit_targetId(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "targetType":
			out.Values[i] = ec._Audit_targetType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "user":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Audit_user(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "editAction":
			out.Values[i] = ec._Audit_editAction(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "content":
			out.Values[i] = ec._Audit_content(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var competitorImplementors = []string{"Competitor"}

func (ec *executionContext) _Competitor(ctx context.Context, sel ast.SelectionSet, obj *models.Competitor) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, competitorImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Competitor")
		case "id":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Competitor_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "externalId":
			out.Values[i] = ec._Competitor_externalId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "name":
			out.Values[i] = ec._Competitor_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "logo":
			out.Values[i] = ec._Competitor_logo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "matches":
			out.Values[i] = ec._Competitor_matches(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var consolationPrizeImplementors = []string{"ConsolationPrize"}

func (ec *executionContext) _ConsolationPrize(ctx context.Context, sel ast.SelectionSet, obj *models.ConsolationPrize) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, consolationPrizeImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ConsolationPrize")
		case "guarantee":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ConsolationPrize_guarantee(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "carryIn":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ConsolationPrize_carryIn(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "allocation":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ConsolationPrize_allocation(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var eventImplementors = []string{"Event"}

func (ec *executionContext) _Event(ctx context.Context, sel ast.SelectionSet, obj *models.Event) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, eventImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Event")
		case "id":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Event_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "name":
			out.Values[i] = ec._Event_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "externalId":
			out.Values[i] = ec._Event_externalId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "type":
			out.Values[i] = ec._Event_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "game":
			out.Values[i] = ec._Event_game(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "logo":
			out.Values[i] = ec._Event_logo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "startDate":
			out.Values[i] = ec._Event_startDate(ctx, field, obj)
		case "endDate":
			out.Values[i] = ec._Event_endDate(ctx, field, obj)
		case "isActive":
			out.Values[i] = ec._Event_isActive(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "isAutogenerated":
			out.Values[i] = ec._Event_isAutogenerated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "matches":
			out.Values[i] = ec._Event_matches(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var legImplementors = []string{"Leg"}

func (ec *executionContext) _Leg(ctx context.Context, sel ast.SelectionSet, obj *models.Leg) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, legImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Leg")
		case "id":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Leg_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "lastSyncTime":
			out.Values[i] = ec._Leg_lastSyncTime(ctx, field, obj)
		case "threshold":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Leg_threshold(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "matchId":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Leg_matchId(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "poolId":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Leg_poolId(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var listMetadataImplementors = []string{"ListMetadata"}

func (ec *executionContext) _ListMetadata(ctx context.Context, sel ast.SelectionSet, obj *models.ListMetadata) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, listMetadataImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ListMetadata")
		case "count":
			out.Values[i] = ec._ListMetadata_count(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var matchImplementors = []string{"Match"}

func (ec *executionContext) _Match(ctx context.Context, sel ast.SelectionSet, obj *models.Match) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, matchImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Match")
		case "id":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Match_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "eventId":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Match_eventId(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "externalId":
			out.Values[i] = ec._Match_externalId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "name":
			out.Values[i] = ec._Match_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "description":
			out.Values[i] = ec._Match_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "startTime":
			out.Values[i] = ec._Match_startTime(ctx, field, obj)
		case "isActive":
			out.Values[i] = ec._Match_isActive(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "isAutogenerated":
			out.Values[i] = ec._Match_isAutogenerated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "internalStatus":
			out.Values[i] = ec._Match_internalStatus(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "eventStage":
			out.Values[i] = ec._Match_eventStage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "competitors":
			out.Values[i] = ec._Match_competitors(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "statistics":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Match_statistics(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "teamScores":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Match_teamScores(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "teamOuScores":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Match_teamOuScores(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "teamWinProbabilities":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Match_teamWinProbabilities(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "format":
			out.Values[i] = ec._Match_format(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "history":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Match_history(ctx, field, obj)
				return res
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, mutationImplementors)

	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "createUser":
			out.Values[i] = ec._Mutation_createUser(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updateUser":
			out.Values[i] = ec._Mutation_updateUser(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createSession":
			out.Values[i] = ec._Mutation_createSession(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createEvent":
			out.Values[i] = ec._Mutation_createEvent(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updateEvent":
			out.Values[i] = ec._Mutation_updateEvent(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deleteEvent":
			out.Values[i] = ec._Mutation_deleteEvent(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createMatch":
			out.Values[i] = ec._Mutation_createMatch(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updateMatch":
			out.Values[i] = ec._Mutation_updateMatch(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deleteMatch":
			out.Values[i] = ec._Mutation_deleteMatch(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createCompetitor":
			out.Values[i] = ec._Mutation_createCompetitor(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updateCompetitor":
			out.Values[i] = ec._Mutation_updateCompetitor(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deleteCompetitor":
			out.Values[i] = ec._Mutation_deleteCompetitor(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createPlayer":
			out.Values[i] = ec._Mutation_createPlayer(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updatePlayer":
			out.Values[i] = ec._Mutation_updatePlayer(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deletePlayer":
			out.Values[i] = ec._Mutation_deletePlayer(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createPool":
			out.Values[i] = ec._Mutation_createPool(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updatePool":
			out.Values[i] = ec._Mutation_updatePool(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deletePool":
			out.Values[i] = ec._Mutation_deletePool(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createPoolDefault":
			out.Values[i] = ec._Mutation_createPoolDefault(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updatePoolDefault":
			out.Values[i] = ec._Mutation_updatePoolDefault(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deletePoolDefault":
			out.Values[i] = ec._Mutation_deletePoolDefault(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createLeg":
			out.Values[i] = ec._Mutation_createLeg(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updateLeg":
			out.Values[i] = ec._Mutation_updateLeg(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deleteLeg":
			out.Values[i] = ec._Mutation_deleteLeg(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createOverUnderDefault":
			out.Values[i] = ec._Mutation_createOverUnderDefault(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updateOverUnderDefault":
			out.Values[i] = ec._Mutation_updateOverUnderDefault(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deleteOverUnderDefault":
			out.Values[i] = ec._Mutation_deleteOverUnderDefault(ctx, field)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var overUnderDefaultImplementors = []string{"OverUnderDefault"}

func (ec *executionContext) _OverUnderDefault(ctx context.Context, sel ast.SelectionSet, obj *models.OverUnderDefault) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, overUnderDefaultImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OverUnderDefault")
		case "id":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._OverUnderDefault_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "game":
			out.Values[i] = ec._OverUnderDefault_game(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "matchFormat":
			out.Values[i] = ec._OverUnderDefault_matchFormat(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "evenThreshold":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._OverUnderDefault_evenThreshold(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "favoredThreshold":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._OverUnderDefault_favoredThreshold(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "note":
			out.Values[i] = ec._OverUnderDefault_note(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var playerImplementors = []string{"Player"}

func (ec *executionContext) _Player(ctx context.Context, sel ast.SelectionSet, obj *models.Player) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, playerImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Player")
		case "id":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Player_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "externalId":
			out.Values[i] = ec._Player_externalId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "name":
			out.Values[i] = ec._Player_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "nickname":
			out.Values[i] = ec._Player_nickname(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "teamId":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Player_teamId(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var poolImplementors = []string{"Pool"}

func (ec *executionContext) _Pool(ctx context.Context, sel ast.SelectionSet, obj *models.Pool) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, poolImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Pool")
		case "id":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Pool_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "name":
			out.Values[i] = ec._Pool_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "type":
			out.Values[i] = ec._Pool_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "isActive":
			out.Values[i] = ec._Pool_isActive(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "guarantee":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Pool_guarantee(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "carryIn":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Pool_carryIn(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "allocation":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Pool_allocation(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "note":
			out.Values[i] = ec._Pool_note(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "unitValue":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Pool_unitValue(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "minUnitPerLine":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Pool_minUnitPerLine(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "maxUnitPerLine":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Pool_maxUnitPerLine(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "minUnitPerTicket":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Pool_minUnitPerTicket(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "maxUnitPerTicket":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Pool_maxUnitPerTicket(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "currency":
			out.Values[i] = ec._Pool_currency(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "isAutogenerated":
			out.Values[i] = ec._Pool_isAutogenerated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "lastSyncTime":
			out.Values[i] = ec._Pool_lastSyncTime(ctx, field, obj)
		case "syncedColossusStatus":
			out.Values[i] = ec._Pool_syncedColossusStatus(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "game":
			out.Values[i] = ec._Pool_game(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "legs":
			out.Values[i] = ec._Pool_legs(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "consolationPrizes":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Pool_consolationPrizes(ctx, field, obj)
				return res
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var poolDefaultImplementors = []string{"PoolDefault"}

func (ec *executionContext) _PoolDefault(ctx context.Context, sel ast.SelectionSet, obj *models.PoolDefault) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, poolDefaultImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PoolDefault")
		case "id":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._PoolDefault_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "legCount":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._PoolDefault_legCount(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "game":
			out.Values[i] = ec._PoolDefault_game(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "type":
			out.Values[i] = ec._PoolDefault_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "guarantee":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._PoolDefault_guarantee(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "carryIn":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._PoolDefault_carryIn(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "allocation":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._PoolDefault_allocation(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "unitValue":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._PoolDefault_unitValue(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "minUnitPerLine":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._PoolDefault_minUnitPerLine(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "maxUnitPerLine":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._PoolDefault_maxUnitPerLine(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "minUnitPerTicket":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._PoolDefault_minUnitPerTicket(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "maxUnitPerTicket":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._PoolDefault_maxUnitPerTicket(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "currency":
			out.Values[i] = ec._PoolDefault_currency(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "note":
			out.Values[i] = ec._PoolDefault_note(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, queryImplementors)

	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "Event":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_Event(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "allEvents":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_allEvents(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "_allEventsMeta":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query__allEventsMeta(ctx, field)
				return res
			})
		case "Pool":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_Pool(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "allPools":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_allPools(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "_allPoolsMeta":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query__allPoolsMeta(ctx, field)
				return res
			})
		case "PoolDefault":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_PoolDefault(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "allPoolDefaults":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_allPoolDefaults(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "_allPoolDefaultsMeta":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query__allPoolDefaultsMeta(ctx, field)
				return res
			})
		case "Leg":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_Leg(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "allLegs":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_allLegs(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "_allLegsMeta":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query__allLegsMeta(ctx, field)
				return res
			})
		case "Match":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_Match(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "allMatches":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_allMatches(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "_allMatchesMeta":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query__allMatchesMeta(ctx, field)
				return res
			})
		case "Competitor":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_Competitor(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "allCompetitors":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_allCompetitors(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "_allCompetitorsMeta":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query__allCompetitorsMeta(ctx, field)
				return res
			})
		case "Player":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_Player(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "allPlayers":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_allPlayers(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "_allPlayersMeta":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query__allPlayersMeta(ctx, field)
				return res
			})
		case "User":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_User(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "allUsers":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_allUsers(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "_allUsersMeta":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query__allUsersMeta(ctx, field)
				return res
			})
		case "Audit":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_Audit(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "allAudits":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_allAudits(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "_allAuditsMeta":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query__allAuditsMeta(ctx, field)
				return res
			})
		case "OverUnderDefault":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_OverUnderDefault(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "allOverUnderDefaults":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_allOverUnderDefaults(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "_allOverUnderDefaultsMeta":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query__allOverUnderDefaultsMeta(ctx, field)
				return res
			})
		case "__type":
			out.Values[i] = ec._Query___type(ctx, field)
		case "__schema":
			out.Values[i] = ec._Query___schema(ctx, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var sessionImplementors = []string{"Session"}

func (ec *executionContext) _Session(ctx context.Context, sel ast.SelectionSet, obj *models.Session) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, sessionImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Session")
		case "token":
			out.Values[i] = ec._Session_token(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var teamProbabilitiesImplementors = []string{"TeamProbabilities"}

func (ec *executionContext) _TeamProbabilities(ctx context.Context, sel ast.SelectionSet, obj *models.TeamProbabilities) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, teamProbabilitiesImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamProbabilities")
		case "teamId":
			out.Values[i] = ec._TeamProbabilities_teamId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "probability":
			out.Values[i] = ec._TeamProbabilities_probability(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var teamScoreImplementors = []string{"TeamScore"}

func (ec *executionContext) _TeamScore(ctx context.Context, sel ast.SelectionSet, obj *models.TeamScore) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, teamScoreImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamScore")
		case "teamId":
			out.Values[i] = ec._TeamScore_teamId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "score":
			out.Values[i] = ec._TeamScore_score(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var teamScoresImplementors = []string{"TeamScores"}

func (ec *executionContext) _TeamScores(ctx context.Context, sel ast.SelectionSet, obj *models.TeamScores) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, teamScoresImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamScores")
		case "teamId":
			out.Values[i] = ec._TeamScores_teamId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "score":
			out.Values[i] = ec._TeamScores_score(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var teamWinProbabilityImplementors = []string{"TeamWinProbability"}

func (ec *executionContext) _TeamWinProbability(ctx context.Context, sel ast.SelectionSet, obj *models.TeamWinProbability) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, teamWinProbabilityImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TeamWinProbability")
		case "teamId":
			out.Values[i] = ec._TeamWinProbability_teamId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "probability":
			out.Values[i] = ec._TeamWinProbability_probability(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var userImplementors = []string{"User"}

func (ec *executionContext) _User(ctx context.Context, sel ast.SelectionSet, obj *models.User) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, userImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("User")
		case "id":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			})
		case "email":
			out.Values[i] = ec._User_email(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "token":
			out.Values[i] = ec._User_token(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "accessRole":
			out.Values[i] = ec._User_accessRole(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) unmarshalNAccessRole2gitlabcomsiimplespbettingbettingfeedpkgmodelsAccessRole(ctx context.Context, v interface{}) (models.AccessRole, error) {
	var res models.AccessRole
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNAccessRole2gitlabcomsiimplespbettingbettingfeedpkgmodelsAccessRole(ctx context.Context, sel ast.SelectionSet, v models.AccessRole) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNAudit2gitlabcomsiimplespbettingbettingfeedpkgmodelsAudit(ctx context.Context, sel ast.SelectionSet, v models.Audit) graphql.Marshaler {
	return ec._Audit(ctx, sel, &v)
}

func (ec *executionContext) marshalNAudit2gitlabcomsiimplespbettingbettingfeedpkgmodelsAudit(ctx context.Context, sel ast.SelectionSet, v []*models.Audit) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAudit2gitlabcomsiimplespbettingbettingfeedpkgmodelsAudit(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNAudit2gitlabcomsiimplespbettingbettingfeedpkgmodelsAudit(ctx context.Context, sel ast.SelectionSet, v *models.Audit) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Audit(ctx, sel, v)
}

func (ec *executionContext) unmarshalNAuthInput2gitlabcomsiimplespbettingbettingfeedpkgmodelsAuthInput(ctx context.Context, v interface{}) (models.AuthInput, error) {
	return ec.unmarshalInputAuthInput(ctx, v)
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	return graphql.UnmarshalBoolean(v)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) marshalNCompetitor2gitlabcomsiimplespbettingbettingfeedpkgmodelsCompetitor(ctx context.Context, sel ast.SelectionSet, v models.Competitor) graphql.Marshaler {
	return ec._Competitor(ctx, sel, &v)
}

func (ec *executionContext) marshalNCompetitor2gitlabcomsiimplespbettingbettingfeedpkgmodelsCompetitor(ctx context.Context, sel ast.SelectionSet, v []models.Competitor) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCompetitor2gitlabcomsiimplespbettingbettingfeedpkgmodelsCompetitor(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNCompetitor2gitlabcomsiimplespbettingbettingfeedpkgmodelsCompetitor(ctx context.Context, sel ast.SelectionSet, v []*models.Competitor) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCompetitor2gitlabcomsiimplespbettingbettingfeedpkgmodelsCompetitor(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNCompetitor2gitlabcomsiimplespbettingbettingfeedpkgmodelsCompetitor(ctx context.Context, sel ast.SelectionSet, v *models.Competitor) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Competitor(ctx, sel, v)
}

func (ec *executionContext) marshalNConsolationPrize2gitlabcomsiimplespbettingbettingfeedpkgmodelsConsolationPrize(ctx context.Context, sel ast.SelectionSet, v models.ConsolationPrize) graphql.Marshaler {
	return ec._ConsolationPrize(ctx, sel, &v)
}

func (ec *executionContext) marshalNConsolationPrize2gitlabcomsiimplespbettingbettingfeedpkgmodelsConsolationPrize(ctx context.Context, sel ast.SelectionSet, v *models.ConsolationPrize) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._ConsolationPrize(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCreateCompetitorInput2gitlabcomsiimplespbettingbettingfeedpkgmodelsCreateCompetitorInput(ctx context.Context, v interface{}) (models.CreateCompetitorInput, error) {
	return ec.unmarshalInputCreateCompetitorInput(ctx, v)
}

func (ec *executionContext) unmarshalNCreateEventInput2gitlabcomsiimplespbettingbettingfeedpkgmodelsCreateEventInput(ctx context.Context, v interface{}) (models.CreateEventInput, error) {
	return ec.unmarshalInputCreateEventInput(ctx, v)
}

func (ec *executionContext) unmarshalNCreateLegInput2gitlabcomsiimplespbettingbettingfeedpkgmodelsCreateLegInput(ctx context.Context, v interface{}) (models.CreateLegInput, error) {
	return ec.unmarshalInputCreateLegInput(ctx, v)
}

func (ec *executionContext) unmarshalNCreateMatchInput2gitlabcomsiimplespbettingbettingfeedpkgmodelsCreateMatchInput(ctx context.Context, v interface{}) (models.CreateMatchInput, error) {
	return ec.unmarshalInputCreateMatchInput(ctx, v)
}

func (ec *executionContext) unmarshalNCreateOverUnderDefaultInput2gitlabcomsiimplespbettingbettingfeedpkgmodelsCreateOverUnderDefaultInput(ctx context.Context, v interface{}) (models.CreateOverUnderDefaultInput, error) {
	return ec.unmarshalInputCreateOverUnderDefaultInput(ctx, v)
}

func (ec *executionContext) unmarshalNCreatePlayerInput2gitlabcomsiimplespbettingbettingfeedpkgmodelsCreatePlayerInput(ctx context.Context, v interface{}) (models.CreatePlayerInput, error) {
	return ec.unmarshalInputCreatePlayerInput(ctx, v)
}

func (ec *executionContext) unmarshalNCreatePoolDefaultInput2gitlabcomsiimplespbettingbettingfeedpkgmodelsCreatePoolDefaultInput(ctx context.Context, v interface{}) (models.CreatePoolDefaultInput, error) {
	return ec.unmarshalInputCreatePoolDefaultInput(ctx, v)
}

func (ec *executionContext) unmarshalNCreatePoolInput2gitlabcomsiimplespbettingbettingfeedpkgmodelsCreatePoolInput(ctx context.Context, v interface{}) (models.CreatePoolInput, error) {
	return ec.unmarshalInputCreatePoolInput(ctx, v)
}

func (ec *executionContext) unmarshalNCreateUserInput2gitlabcomsiimplespbettingbettingfeedpkgmodelsCreateUserInput(ctx context.Context, v interface{}) (models.CreateUserInput, error) {
	return ec.unmarshalInputCreateUserInput(ctx, v)
}

func (ec *executionContext) unmarshalNDecimal2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalNDecimal2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNEditAction2gitlabcomsiimplespbettingbettingfeedpkgmodelsEditAction(ctx context.Context, v interface{}) (models.EditAction, error) {
	var res models.EditAction
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNEditAction2gitlabcomsiimplespbettingbettingfeedpkgmodelsEditAction(ctx context.Context, sel ast.SelectionSet, v models.EditAction) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNEvent2gitlabcomsiimplespbettingbettingfeedpkgmodelsEvent(ctx context.Context, sel ast.SelectionSet, v models.Event) graphql.Marshaler {
	return ec._Event(ctx, sel, &v)
}

func (ec *executionContext) marshalNEvent2gitlabcomsiimplespbettingbettingfeedpkgmodelsEvent(ctx context.Context, sel ast.SelectionSet, v []*models.Event) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNEvent2gitlabcomsiimplespbettingbettingfeedpkgmodelsEvent(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNEvent2gitlabcomsiimplespbettingbettingfeedpkgmodelsEvent(ctx context.Context, sel ast.SelectionSet, v *models.Event) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Event(ctx, sel, v)
}

func (ec *executionContext) unmarshalNEventType2gitlabcomsiimplespbettingbettingfeedpkgmodelsEventType(ctx context.Context, v interface{}) (models.EventType, error) {
	var res models.EventType
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNEventType2gitlabcomsiimplespbettingbettingfeedpkgmodelsEventType(ctx context.Context, sel ast.SelectionSet, v models.EventType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNFloat2float64(ctx context.Context, v interface{}) (float64, error) {
	return graphql.UnmarshalFloat(v)
}

func (ec *executionContext) marshalNFloat2float64(ctx context.Context, sel ast.SelectionSet, v float64) graphql.Marshaler {
	res := graphql.MarshalFloat(v)
	if res == graphql.Null {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNGame2gitlabcomsiimplespbettingbettingfeedpkgmodelsGame(ctx context.Context, v interface{}) (models.Game, error) {
	var res models.Game
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNGame2gitlabcomsiimplespbettingbettingfeedpkgmodelsGame(ctx context.Context, sel ast.SelectionSet, v models.Game) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNID2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalID(v)
}

func (ec *executionContext) marshalNID2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalID(v)
	if res == graphql.Null {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v interface{}) (int, error) {
	return graphql.UnmarshalInt(v)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNJSON2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalNJSON2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) marshalNLeg2gitlabcomsiimplespbettingbettingfeedpkgmodelsLeg(ctx context.Context, sel ast.SelectionSet, v models.Leg) graphql.Marshaler {
	return ec._Leg(ctx, sel, &v)
}

func (ec *executionContext) marshalNLeg2gitlabcomsiimplespbettingbettingfeedpkgmodelsLeg(ctx context.Context, sel ast.SelectionSet, v []models.Leg) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNLeg2gitlabcomsiimplespbettingbettingfeedpkgmodelsLeg(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNLeg2gitlabcomsiimplespbettingbettingfeedpkgmodelsLeg(ctx context.Context, sel ast.SelectionSet, v []*models.Leg) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNLeg2gitlabcomsiimplespbettingbettingfeedpkgmodelsLeg(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNLeg2gitlabcomsiimplespbettingbettingfeedpkgmodelsLeg(ctx context.Context, sel ast.SelectionSet, v *models.Leg) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Leg(ctx, sel, v)
}

func (ec *executionContext) marshalNMatch2gitlabcomsiimplespbettingbettingfeedpkgmodelsMatch(ctx context.Context, sel ast.SelectionSet, v models.Match) graphql.Marshaler {
	return ec._Match(ctx, sel, &v)
}

func (ec *executionContext) marshalNMatch2gitlabcomsiimplespbettingbettingfeedpkgmodelsMatch(ctx context.Context, sel ast.SelectionSet, v []models.Match) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMatch2gitlabcomsiimplespbettingbettingfeedpkgmodelsMatch(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNMatch2gitlabcomsiimplespbettingbettingfeedpkgmodelsMatch(ctx context.Context, sel ast.SelectionSet, v []*models.Match) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMatch2gitlabcomsiimplespbettingbettingfeedpkgmodelsMatch(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNMatch2gitlabcomsiimplespbettingbettingfeedpkgmodelsMatch(ctx context.Context, sel ast.SelectionSet, v *models.Match) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Match(ctx, sel, v)
}

func (ec *executionContext) unmarshalNMatchFormat2gitlabcomsiimplespbettingbettingfeedpkgmodelsMatchFormat(ctx context.Context, v interface{}) (models.MatchFormat, error) {
	var res models.MatchFormat
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNMatchFormat2gitlabcomsiimplespbettingbettingfeedpkgmodelsMatchFormat(ctx context.Context, sel ast.SelectionSet, v models.MatchFormat) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNMatchInternalStatus2gitlabcomsiimplespbettingbettingfeedpkgmodelsMatchInternalStatus(ctx context.Context, v interface{}) (models.MatchInternalStatus, error) {
	var res models.MatchInternalStatus
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNMatchInternalStatus2gitlabcomsiimplespbettingbettingfeedpkgmodelsMatchInternalStatus(ctx context.Context, sel ast.SelectionSet, v models.MatchInternalStatus) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNOverUnderDefault2gitlabcomsiimplespbettingbettingfeedpkgmodelsOverUnderDefault(ctx context.Context, sel ast.SelectionSet, v models.OverUnderDefault) graphql.Marshaler {
	return ec._OverUnderDefault(ctx, sel, &v)
}

func (ec *executionContext) marshalNOverUnderDefault2gitlabcomsiimplespbettingbettingfeedpkgmodelsOverUnderDefault(ctx context.Context, sel ast.SelectionSet, v []*models.OverUnderDefault) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNOverUnderDefault2gitlabcomsiimplespbettingbettingfeedpkgmodelsOverUnderDefault(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNOverUnderDefault2gitlabcomsiimplespbettingbettingfeedpkgmodelsOverUnderDefault(ctx context.Context, sel ast.SelectionSet, v *models.OverUnderDefault) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._OverUnderDefault(ctx, sel, v)
}

func (ec *executionContext) marshalNPlayer2gitlabcomsiimplespbettingbettingfeedpkgmodelsPlayer(ctx context.Context, sel ast.SelectionSet, v models.Player) graphql.Marshaler {
	return ec._Player(ctx, sel, &v)
}

func (ec *executionContext) marshalNPlayer2gitlabcomsiimplespbettingbettingfeedpkgmodelsPlayer(ctx context.Context, sel ast.SelectionSet, v []*models.Player) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPlayer2gitlabcomsiimplespbettingbettingfeedpkgmodelsPlayer(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNPlayer2gitlabcomsiimplespbettingbettingfeedpkgmodelsPlayer(ctx context.Context, sel ast.SelectionSet, v *models.Player) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Player(ctx, sel, v)
}

func (ec *executionContext) marshalNPool2gitlabcomsiimplespbettingbettingfeedpkgmodelsPool(ctx context.Context, sel ast.SelectionSet, v models.Pool) graphql.Marshaler {
	return ec._Pool(ctx, sel, &v)
}

func (ec *executionContext) marshalNPool2gitlabcomsiimplespbettingbettingfeedpkgmodelsPool(ctx context.Context, sel ast.SelectionSet, v []*models.Pool) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPool2gitlabcomsiimplespbettingbettingfeedpkgmodelsPool(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNPool2gitlabcomsiimplespbettingbettingfeedpkgmodelsPool(ctx context.Context, sel ast.SelectionSet, v *models.Pool) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Pool(ctx, sel, v)
}

func (ec *executionContext) unmarshalNPoolCurrency2gitlabcomsiimplespbettingbettingfeedpkgmodelsPoolCurrency(ctx context.Context, v interface{}) (models.PoolCurrency, error) {
	var res models.PoolCurrency
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNPoolCurrency2gitlabcomsiimplespbettingbettingfeedpkgmodelsPoolCurrency(ctx context.Context, sel ast.SelectionSet, v models.PoolCurrency) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNPoolDefault2gitlabcomsiimplespbettingbettingfeedpkgmodelsPoolDefault(ctx context.Context, sel ast.SelectionSet, v models.PoolDefault) graphql.Marshaler {
	return ec._PoolDefault(ctx, sel, &v)
}

func (ec *executionContext) marshalNPoolDefault2gitlabcomsiimplespbettingbettingfeedpkgmodelsPoolDefault(ctx context.Context, sel ast.SelectionSet, v []*models.PoolDefault) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPoolDefault2gitlabcomsiimplespbettingbettingfeedpkgmodelsPoolDefault(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNPoolDefault2gitlabcomsiimplespbettingbettingfeedpkgmodelsPoolDefault(ctx context.Context, sel ast.SelectionSet, v *models.PoolDefault) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._PoolDefault(ctx, sel, v)
}

func (ec *executionContext) unmarshalNPoolStatus2gitlabcomsiimplespbettingbettingfeedpkgmodelsPoolStatus(ctx context.Context, v interface{}) (models.PoolStatus, error) {
	var res models.PoolStatus
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNPoolStatus2gitlabcomsiimplespbettingbettingfeedpkgmodelsPoolStatus(ctx context.Context, sel ast.SelectionSet, v models.PoolStatus) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNPoolType2gitlabcomsiimplespbettingbettingfeedpkgmodelsPoolType(ctx context.Context, v interface{}) (models.PoolType, error) {
	var res models.PoolType
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNPoolType2gitlabcomsiimplespbettingbettingfeedpkgmodelsPoolType(ctx context.Context, sel ast.SelectionSet, v models.PoolType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNSession2gitlabcomsiimplespbettingbettingfeedpkgmodelsSession(ctx context.Context, sel ast.SelectionSet, v models.Session) graphql.Marshaler {
	return ec._Session(ctx, sel, &v)
}

func (ec *executionContext) marshalNSession2gitlabcomsiimplespbettingbettingfeedpkgmodelsSession(ctx context.Context, sel ast.SelectionSet, v *models.Session) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._Session(ctx, sel, v)
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) marshalNTeamScore2gitlabcomsiimplespbettingbettingfeedpkgmodelsTeamScore(ctx context.Context, sel ast.SelectionSet, v models.TeamScore) graphql.Marshaler {
	return ec._TeamScore(ctx, sel, &v)
}

func (ec *executionContext) marshalNTeamScore2gitlabcomsiimplespbettingbettingfeedpkgmodelsTeamScore(ctx context.Context, sel ast.SelectionSet, v []*models.TeamScore) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTeamScore2gitlabcomsiimplespbettingbettingfeedpkgmodelsTeamScore(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNTeamScore2gitlabcomsiimplespbettingbettingfeedpkgmodelsTeamScore(ctx context.Context, sel ast.SelectionSet, v *models.TeamScore) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._TeamScore(ctx, sel, v)
}

func (ec *executionContext) marshalNTeamWinProbability2gitlabcomsiimplespbettingbettingfeedpkgmodelsTeamWinProbability(ctx context.Context, sel ast.SelectionSet, v models.TeamWinProbability) graphql.Marshaler {
	return ec._TeamWinProbability(ctx, sel, &v)
}

func (ec *executionContext) marshalNTeamWinProbability2gitlabcomsiimplespbettingbettingfeedpkgmodelsTeamWinProbability(ctx context.Context, sel ast.SelectionSet, v []*models.TeamWinProbability) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTeamWinProbability2gitlabcomsiimplespbettingbettingfeedpkgmodelsTeamWinProbability(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNTeamWinProbability2gitlabcomsiimplespbettingbettingfeedpkgmodelsTeamWinProbability(ctx context.Context, sel ast.SelectionSet, v *models.TeamWinProbability) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._TeamWinProbability(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTime2timeTime(ctx context.Context, v interface{}) (time.Time, error) {
	return graphql.UnmarshalTime(v)
}

func (ec *executionContext) marshalNTime2timeTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	res := graphql.MarshalTime(v)
	if res == graphql.Null {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNUpdateCompetitorInput2gitlabcomsiimplespbettingbettingfeedpkgmodelsUpdateCompetitorInput(ctx context.Context, v interface{}) (models.UpdateCompetitorInput, error) {
	return ec.unmarshalInputUpdateCompetitorInput(ctx, v)
}

func (ec *executionContext) unmarshalNUpdateConsolationPrize2gitlabcomsiimplespbettingbettingfeedpkgmodelsUpdateConsolationPrize(ctx context.Context, v interface{}) (models.UpdateConsolationPrize, error) {
	return ec.unmarshalInputUpdateConsolationPrize(ctx, v)
}

func (ec *executionContext) unmarshalNUpdateConsolationPrize2gitlabcomsiimplespbettingbettingfeedpkgmodelsUpdateConsolationPrize(ctx context.Context, v interface{}) (*models.UpdateConsolationPrize, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalNUpdateConsolationPrize2gitlabcomsiimplespbettingbettingfeedpkgmodelsUpdateConsolationPrize(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalNUpdateEventInput2gitlabcomsiimplespbettingbettingfeedpkgmodelsUpdateEventInput(ctx context.Context, v interface{}) (models.UpdateEventInput, error) {
	return ec.unmarshalInputUpdateEventInput(ctx, v)
}

func (ec *executionContext) unmarshalNUpdateLegInput2gitlabcomsiimplespbettingbettingfeedpkgmodelsUpdateLegInput(ctx context.Context, v interface{}) (models.UpdateLegInput, error) {
	return ec.unmarshalInputUpdateLegInput(ctx, v)
}

func (ec *executionContext) unmarshalNUpdateMatchInput2gitlabcomsiimplespbettingbettingfeedpkgmodelsUpdateMatchInput(ctx context.Context, v interface{}) (models.UpdateMatchInput, error) {
	return ec.unmarshalInputUpdateMatchInput(ctx, v)
}

func (ec *executionContext) unmarshalNUpdateOverUnderDefaultInput2gitlabcomsiimplespbettingbettingfeedpkgmodelsUpdateOverUnderDefaultInput(ctx context.Context, v interface{}) (models.UpdateOverUnderDefaultInput, error) {
	return ec.unmarshalInputUpdateOverUnderDefaultInput(ctx, v)
}

func (ec *executionContext) unmarshalNUpdatePlayerInput2gitlabcomsiimplespbettingbettingfeedpkgmodelsUpdatePlayerInput(ctx context.Context, v interface{}) (models.UpdatePlayerInput, error) {
	return ec.unmarshalInputUpdatePlayerInput(ctx, v)
}

func (ec *executionContext) unmarshalNUpdatePoolDefaultInput2gitlabcomsiimplespbettingbettingfeedpkgmodelsUpdatePoolDefaultInput(ctx context.Context, v interface{}) (models.UpdatePoolDefaultInput, error) {
	return ec.unmarshalInputUpdatePoolDefaultInput(ctx, v)
}

func (ec *executionContext) unmarshalNUpdatePoolInput2gitlabcomsiimplespbettingbettingfeedpkgmodelsUpdatePoolInput(ctx context.Context, v interface{}) (models.UpdatePoolInput, error) {
	return ec.unmarshalInputUpdatePoolInput(ctx, v)
}

func (ec *executionContext) unmarshalNUpdateTeamProbabilities2gitlabcomsiimplespbettingbettingfeedpkgmodelsUpdateTeamProbabilities(ctx context.Context, v interface{}) (models.UpdateTeamProbabilities, error) {
	return ec.unmarshalInputUpdateTeamProbabilities(ctx, v)
}

func (ec *executionContext) unmarshalNUpdateTeamProbabilities2gitlabcomsiimplespbettingbettingfeedpkgmodelsUpdateTeamProbabilities(ctx context.Context, v interface{}) (*models.UpdateTeamProbabilities, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalNUpdateTeamProbabilities2gitlabcomsiimplespbettingbettingfeedpkgmodelsUpdateTeamProbabilities(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalNUpdateTeamScores2gitlabcomsiimplespbettingbettingfeedpkgmodelsUpdateTeamScores(ctx context.Context, v interface{}) (models.UpdateTeamScores, error) {
	return ec.unmarshalInputUpdateTeamScores(ctx, v)
}

func (ec *executionContext) unmarshalNUpdateTeamScores2gitlabcomsiimplespbettingbettingfeedpkgmodelsUpdateTeamScores(ctx context.Context, v interface{}) (*models.UpdateTeamScores, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalNUpdateTeamScores2gitlabcomsiimplespbettingbettingfeedpkgmodelsUpdateTeamScores(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalNUpdateUserInput2gitlabcomsiimplespbettingbettingfeedpkgmodelsUpdateUserInput(ctx context.Context, v interface{}) (models.UpdateUserInput, error) {
	return ec.unmarshalInputUpdateUserInput(ctx, v)
}

func (ec *executionContext) marshalNUser2gitlabcomsiimplespbettingbettingfeedpkgmodelsUser(ctx context.Context, sel ast.SelectionSet, v models.User) graphql.Marshaler {
	return ec._User(ctx, sel, &v)
}

func (ec *executionContext) marshalNUser2gitlabcomsiimplespbettingbettingfeedpkgmodelsUser(ctx context.Context, sel ast.SelectionSet, v []*models.User) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUser2gitlabcomsiimplespbettingbettingfeedpkgmodelsUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNUser2gitlabcomsiimplespbettingbettingfeedpkgmodelsUser(ctx context.Context, sel ast.SelectionSet, v *models.User) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec._User(ctx, sel, v)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalOAccessRole2gitlabcomsiimplespbettingbettingfeedpkgmodelsAccessRole(ctx context.Context, v interface{}) (models.AccessRole, error) {
	var res models.AccessRole
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalOAccessRole2gitlabcomsiimplespbettingbettingfeedpkgmodelsAccessRole(ctx context.Context, sel ast.SelectionSet, v models.AccessRole) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOAccessRole2gitlabcomsiimplespbettingbettingfeedpkgmodelsAccessRole(ctx context.Context, v interface{}) (*models.AccessRole, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOAccessRole2gitlabcomsiimplespbettingbettingfeedpkgmodelsAccessRole(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOAccessRole2gitlabcomsiimplespbettingbettingfeedpkgmodelsAccessRole(ctx context.Context, sel ast.SelectionSet, v *models.AccessRole) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOAudit2gitlabcomsiimplespbettingbettingfeedpkgmodelsAudit(ctx context.Context, sel ast.SelectionSet, v []*models.Audit) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAudit2gitlabcomsiimplespbettingbettingfeedpkgmodelsAudit(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOAuditFilter2gitlabcomsiimplespbettingbettingfeedpkgmodelsAuditFilter(ctx context.Context, v interface{}) (models.AuditFilter, error) {
	return ec.unmarshalInputAuditFilter(ctx, v)
}

func (ec *executionContext) unmarshalOAuditFilter2gitlabcomsiimplespbettingbettingfeedpkgmodelsAuditFilter(ctx context.Context, v interface{}) (*models.AuditFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOAuditFilter2gitlabcomsiimplespbettingbettingfeedpkgmodelsAuditFilter(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	return graphql.UnmarshalBoolean(v)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	return graphql.MarshalBoolean(v)
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOBoolean2bool(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOBoolean2bool(ctx, sel, *v)
}

func (ec *executionContext) unmarshalOCompetitorFilter2gitlabcomsiimplespbettingbettingfeedpkgmodelsCompetitorFilter(ctx context.Context, v interface{}) (models.CompetitorFilter, error) {
	return ec.unmarshalInputCompetitorFilter(ctx, v)
}

func (ec *executionContext) unmarshalOCompetitorFilter2gitlabcomsiimplespbettingbettingfeedpkgmodelsCompetitorFilter(ctx context.Context, v interface{}) (*models.CompetitorFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOCompetitorFilter2gitlabcomsiimplespbettingbettingfeedpkgmodelsCompetitorFilter(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOConsolationPrize2gitlabcomsiimplespbettingbettingfeedpkgmodelsConsolationPrize(ctx context.Context, sel ast.SelectionSet, v []*models.ConsolationPrize) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNConsolationPrize2gitlabcomsiimplespbettingbettingfeedpkgmodelsConsolationPrize(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalODecimal2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalODecimal2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return graphql.MarshalString(v)
}

func (ec *executionContext) unmarshalODecimal2string(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalODecimal2string(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalODecimal2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalODecimal2string(ctx, sel, *v)
}

func (ec *executionContext) unmarshalOEditAction2gitlabcomsiimplespbettingbettingfeedpkgmodelsEditAction(ctx context.Context, v interface{}) (models.EditAction, error) {
	var res models.EditAction
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalOEditAction2gitlabcomsiimplespbettingbettingfeedpkgmodelsEditAction(ctx context.Context, sel ast.SelectionSet, v models.EditAction) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOEditAction2gitlabcomsiimplespbettingbettingfeedpkgmodelsEditAction(ctx context.Context, v interface{}) (*models.EditAction, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOEditAction2gitlabcomsiimplespbettingbettingfeedpkgmodelsEditAction(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOEditAction2gitlabcomsiimplespbettingbettingfeedpkgmodelsEditAction(ctx context.Context, sel ast.SelectionSet, v *models.EditAction) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOEventFilter2gitlabcomsiimplespbettingbettingfeedpkgmodelsEventFilter(ctx context.Context, v interface{}) (models.EventFilter, error) {
	return ec.unmarshalInputEventFilter(ctx, v)
}

func (ec *executionContext) unmarshalOEventFilter2gitlabcomsiimplespbettingbettingfeedpkgmodelsEventFilter(ctx context.Context, v interface{}) (*models.EventFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOEventFilter2gitlabcomsiimplespbettingbettingfeedpkgmodelsEventFilter(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOEventType2gitlabcomsiimplespbettingbettingfeedpkgmodelsEventType(ctx context.Context, v interface{}) (models.EventType, error) {
	var res models.EventType
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalOEventType2gitlabcomsiimplespbettingbettingfeedpkgmodelsEventType(ctx context.Context, sel ast.SelectionSet, v models.EventType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOEventType2gitlabcomsiimplespbettingbettingfeedpkgmodelsEventType(ctx context.Context, v interface{}) (*models.EventType, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOEventType2gitlabcomsiimplespbettingbettingfeedpkgmodelsEventType(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOEventType2gitlabcomsiimplespbettingbettingfeedpkgmodelsEventType(ctx context.Context, sel ast.SelectionSet, v *models.EventType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOGame2gitlabcomsiimplespbettingbettingfeedpkgmodelsGame(ctx context.Context, v interface{}) (models.Game, error) {
	var res models.Game
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalOGame2gitlabcomsiimplespbettingbettingfeedpkgmodelsGame(ctx context.Context, sel ast.SelectionSet, v models.Game) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOGame2gitlabcomsiimplespbettingbettingfeedpkgmodelsGame(ctx context.Context, v interface{}) (*models.Game, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOGame2gitlabcomsiimplespbettingbettingfeedpkgmodelsGame(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOGame2gitlabcomsiimplespbettingbettingfeedpkgmodelsGame(ctx context.Context, sel ast.SelectionSet, v *models.Game) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOID2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalID(v)
}

func (ec *executionContext) marshalOID2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return graphql.MarshalID(v)
}

func (ec *executionContext) unmarshalOID2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNID2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOID2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNID2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOID2string(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOID2string(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOID2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOID2string(ctx, sel, *v)
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v interface{}) (int, error) {
	return graphql.UnmarshalInt(v)
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	return graphql.MarshalInt(v)
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOInt2int(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOInt2int(ctx, sel, *v)
}

func (ec *executionContext) unmarshalOLegFilter2gitlabcomsiimplespbettingbettingfeedpkgmodelsLegFilter(ctx context.Context, v interface{}) (models.LegFilter, error) {
	return ec.unmarshalInputLegFilter(ctx, v)
}

func (ec *executionContext) unmarshalOLegFilter2gitlabcomsiimplespbettingbettingfeedpkgmodelsLegFilter(ctx context.Context, v interface{}) (*models.LegFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOLegFilter2gitlabcomsiimplespbettingbettingfeedpkgmodelsLegFilter(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOListMetadata2gitlabcomsiimplespbettingbettingfeedpkgmodelsListMetadata(ctx context.Context, sel ast.SelectionSet, v models.ListMetadata) graphql.Marshaler {
	return ec._ListMetadata(ctx, sel, &v)
}

func (ec *executionContext) marshalOListMetadata2gitlabcomsiimplespbettingbettingfeedpkgmodelsListMetadata(ctx context.Context, sel ast.SelectionSet, v *models.ListMetadata) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ListMetadata(ctx, sel, v)
}

func (ec *executionContext) marshalOMatch2gitlabcomsiimplespbettingbettingfeedpkgmodelsMatch(ctx context.Context, sel ast.SelectionSet, v models.Match) graphql.Marshaler {
	return ec._Match(ctx, sel, &v)
}

func (ec *executionContext) marshalOMatch2gitlabcomsiimplespbettingbettingfeedpkgmodelsMatch(ctx context.Context, sel ast.SelectionSet, v []models.Match) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOMatch2gitlabcomsiimplespbettingbettingfeedpkgmodelsMatch(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOMatchFilter2gitlabcomsiimplespbettingbettingfeedpkgmodelsMatchFilter(ctx context.Context, v interface{}) (models.MatchFilter, error) {
	return ec.unmarshalInputMatchFilter(ctx, v)
}

func (ec *executionContext) unmarshalOMatchFilter2gitlabcomsiimplespbettingbettingfeedpkgmodelsMatchFilter(ctx context.Context, v interface{}) (*models.MatchFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOMatchFilter2gitlabcomsiimplespbettingbettingfeedpkgmodelsMatchFilter(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOMatchFormat2gitlabcomsiimplespbettingbettingfeedpkgmodelsMatchFormat(ctx context.Context, v interface{}) (models.MatchFormat, error) {
	var res models.MatchFormat
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalOMatchFormat2gitlabcomsiimplespbettingbettingfeedpkgmodelsMatchFormat(ctx context.Context, sel ast.SelectionSet, v models.MatchFormat) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOMatchFormat2gitlabcomsiimplespbettingbettingfeedpkgmodelsMatchFormat(ctx context.Context, v interface{}) (*models.MatchFormat, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOMatchFormat2gitlabcomsiimplespbettingbettingfeedpkgmodelsMatchFormat(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOMatchFormat2gitlabcomsiimplespbettingbettingfeedpkgmodelsMatchFormat(ctx context.Context, sel ast.SelectionSet, v *models.MatchFormat) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOMatchInternalStatus2gitlabcomsiimplespbettingbettingfeedpkgmodelsMatchInternalStatus(ctx context.Context, v interface{}) (models.MatchInternalStatus, error) {
	var res models.MatchInternalStatus
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalOMatchInternalStatus2gitlabcomsiimplespbettingbettingfeedpkgmodelsMatchInternalStatus(ctx context.Context, sel ast.SelectionSet, v models.MatchInternalStatus) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOMatchInternalStatus2gitlabcomsiimplespbettingbettingfeedpkgmodelsMatchInternalStatus(ctx context.Context, v interface{}) (*models.MatchInternalStatus, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOMatchInternalStatus2gitlabcomsiimplespbettingbettingfeedpkgmodelsMatchInternalStatus(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOMatchInternalStatus2gitlabcomsiimplespbettingbettingfeedpkgmodelsMatchInternalStatus(ctx context.Context, sel ast.SelectionSet, v *models.MatchInternalStatus) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOOverUnderDefaultFilter2gitlabcomsiimplespbettingbettingfeedpkgmodelsOverUnderDefaultFilter(ctx context.Context, v interface{}) (models.OverUnderDefaultFilter, error) {
	return ec.unmarshalInputOverUnderDefaultFilter(ctx, v)
}

func (ec *executionContext) unmarshalOOverUnderDefaultFilter2gitlabcomsiimplespbettingbettingfeedpkgmodelsOverUnderDefaultFilter(ctx context.Context, v interface{}) (*models.OverUnderDefaultFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOOverUnderDefaultFilter2gitlabcomsiimplespbettingbettingfeedpkgmodelsOverUnderDefaultFilter(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOPlayerFilter2gitlabcomsiimplespbettingbettingfeedpkgmodelsPlayerFilter(ctx context.Context, v interface{}) (models.PlayerFilter, error) {
	return ec.unmarshalInputPlayerFilter(ctx, v)
}

func (ec *executionContext) unmarshalOPlayerFilter2gitlabcomsiimplespbettingbettingfeedpkgmodelsPlayerFilter(ctx context.Context, v interface{}) (*models.PlayerFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOPlayerFilter2gitlabcomsiimplespbettingbettingfeedpkgmodelsPlayerFilter(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOPoolCurrency2gitlabcomsiimplespbettingbettingfeedpkgmodelsPoolCurrency(ctx context.Context, v interface{}) (models.PoolCurrency, error) {
	var res models.PoolCurrency
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalOPoolCurrency2gitlabcomsiimplespbettingbettingfeedpkgmodelsPoolCurrency(ctx context.Context, sel ast.SelectionSet, v models.PoolCurrency) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOPoolCurrency2gitlabcomsiimplespbettingbettingfeedpkgmodelsPoolCurrency(ctx context.Context, v interface{}) (*models.PoolCurrency, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOPoolCurrency2gitlabcomsiimplespbettingbettingfeedpkgmodelsPoolCurrency(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOPoolCurrency2gitlabcomsiimplespbettingbettingfeedpkgmodelsPoolCurrency(ctx context.Context, sel ast.SelectionSet, v *models.PoolCurrency) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOPoolDefaultFilter2gitlabcomsiimplespbettingbettingfeedpkgmodelsPoolDefaultFilter(ctx context.Context, v interface{}) (models.PoolDefaultFilter, error) {
	return ec.unmarshalInputPoolDefaultFilter(ctx, v)
}

func (ec *executionContext) unmarshalOPoolDefaultFilter2gitlabcomsiimplespbettingbettingfeedpkgmodelsPoolDefaultFilter(ctx context.Context, v interface{}) (*models.PoolDefaultFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOPoolDefaultFilter2gitlabcomsiimplespbettingbettingfeedpkgmodelsPoolDefaultFilter(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOPoolFilter2gitlabcomsiimplespbettingbettingfeedpkgmodelsPoolFilter(ctx context.Context, v interface{}) (models.PoolFilter, error) {
	return ec.unmarshalInputPoolFilter(ctx, v)
}

func (ec *executionContext) unmarshalOPoolFilter2gitlabcomsiimplespbettingbettingfeedpkgmodelsPoolFilter(ctx context.Context, v interface{}) (*models.PoolFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOPoolFilter2gitlabcomsiimplespbettingbettingfeedpkgmodelsPoolFilter(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOPoolStatus2gitlabcomsiimplespbettingbettingfeedpkgmodelsPoolStatus(ctx context.Context, v interface{}) (models.PoolStatus, error) {
	var res models.PoolStatus
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalOPoolStatus2gitlabcomsiimplespbettingbettingfeedpkgmodelsPoolStatus(ctx context.Context, sel ast.SelectionSet, v models.PoolStatus) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOPoolStatus2gitlabcomsiimplespbettingbettingfeedpkgmodelsPoolStatus(ctx context.Context, v interface{}) (*models.PoolStatus, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOPoolStatus2gitlabcomsiimplespbettingbettingfeedpkgmodelsPoolStatus(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOPoolStatus2gitlabcomsiimplespbettingbettingfeedpkgmodelsPoolStatus(ctx context.Context, sel ast.SelectionSet, v *models.PoolStatus) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOPoolType2gitlabcomsiimplespbettingbettingfeedpkgmodelsPoolType(ctx context.Context, v interface{}) (models.PoolType, error) {
	var res models.PoolType
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalOPoolType2gitlabcomsiimplespbettingbettingfeedpkgmodelsPoolType(ctx context.Context, sel ast.SelectionSet, v models.PoolType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOPoolType2gitlabcomsiimplespbettingbettingfeedpkgmodelsPoolType(ctx context.Context, v interface{}) (*models.PoolType, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOPoolType2gitlabcomsiimplespbettingbettingfeedpkgmodelsPoolType(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOPoolType2gitlabcomsiimplespbettingbettingfeedpkgmodelsPoolType(ctx context.Context, sel ast.SelectionSet, v *models.PoolType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return graphql.MarshalString(v)
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOString2string(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOString2string(ctx, sel, *v)
}

func (ec *executionContext) unmarshalOTime2timeTime(ctx context.Context, v interface{}) (time.Time, error) {
	return graphql.UnmarshalTime(v)
}

func (ec *executionContext) marshalOTime2timeTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	return graphql.MarshalTime(v)
}

func (ec *executionContext) unmarshalOTime2timeTime(ctx context.Context, v interface{}) (*time.Time, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOTime2timeTime(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOTime2timeTime(ctx context.Context, sel ast.SelectionSet, v *time.Time) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOTime2timeTime(ctx, sel, *v)
}

func (ec *executionContext) unmarshalOUpdateConsolationPrize2gitlabcomsiimplespbettingbettingfeedpkgmodelsUpdateConsolationPrize(ctx context.Context, v interface{}) ([]*models.UpdateConsolationPrize, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*models.UpdateConsolationPrize, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNUpdateConsolationPrize2gitlabcomsiimplespbettingbettingfeedpkgmodelsUpdateConsolationPrize(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOUpdateTeamProbabilities2gitlabcomsiimplespbettingbettingfeedpkgmodelsUpdateTeamProbabilities(ctx context.Context, v interface{}) ([]*models.UpdateTeamProbabilities, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*models.UpdateTeamProbabilities, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNUpdateTeamProbabilities2gitlabcomsiimplespbettingbettingfeedpkgmodelsUpdateTeamProbabilities(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOUpdateTeamScores2gitlabcomsiimplespbettingbettingfeedpkgmodelsUpdateTeamScores(ctx context.Context, v interface{}) ([]*models.UpdateTeamScores, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*models.UpdateTeamScores, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNUpdateTeamScores2gitlabcomsiimplespbettingbettingfeedpkgmodelsUpdateTeamScores(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOUserFilter2gitlabcomsiimplespbettingbettingfeedpkgmodelsUserFilter(ctx context.Context, v interface{}) (models.UserFilter, error) {
	return ec.unmarshalInputUserFilter(ctx, v)
}

func (ec *executionContext) unmarshalOUserFilter2gitlabcomsiimplespbettingbettingfeedpkgmodelsUserFilter(ctx context.Context, v interface{}) (*models.UserFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOUserFilter2gitlabcomsiimplespbettingbettingfeedpkgmodelsUserFilter(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx context.Context, sel ast.SelectionSet, v introspection.Schema) graphql.Marshaler {
	return ec.___Schema(ctx, sel, &v)
}

func (ec *executionContext) marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************

package graphql

import (
	context "context"
	"encoding/json"
	"fmt"
	"sort"
	"strings"

	sq "github.com/Masterminds/squirrel"
	"github.com/shopspring/decimal"
	"gitlab.com/siimpl/esp-betting/betting-feed/pkg/audit"
	"gitlab.com/siimpl/esp-betting/betting-feed/pkg/auth"
	models "gitlab.com/siimpl/esp-betting/betting-feed/pkg/models"
	"gitlab.com/siimpl/esp-betting/betting-feed/pkg/repository"
)

type matchResolver struct{ *Resolver }

func (r *matchResolver) ID(ctx context.Context, obj *models.Match) (string, error) {
	return obj.GetID(), nil
}

func (r *matchResolver) Statistics(ctx context.Context, obj *models.Match) (string, error) {
	statisticsJSON, err := json.Marshal(obj.Statistics)
	if err != nil {
		return "", err
	}
	return string(statisticsJSON), nil
}

func (r *matchResolver) TeamScores(ctx context.Context, obj *models.Match) ([]*models.TeamScore, error) {
	scores := []*models.TeamScore{}
	for k, v := range obj.TeamScores {
		score := &models.TeamScore{
			TeamID: k,
			Score:  v,
		}
		scores = append(scores, score)
	}

	sort.Slice(scores, func(i, j int) bool { return strings.Compare(scores[i].TeamID, scores[j].TeamID) < 0 })

	return scores, nil
}

func (r *matchResolver) TeamOuScores(ctx context.Context, obj *models.Match) ([]*models.TeamScore, error) {
	scores := []*models.TeamScore{}
	for k, v := range obj.TeamOuScores {
		score := &models.TeamScore{
			TeamID: k,
			Score:  v,
		}
		scores = append(scores, score)
	}

	sort.Slice(scores, func(i, j int) bool { return strings.Compare(scores[i].TeamID, scores[j].TeamID) < 0 })

	return scores, nil
}

func (r *matchResolver) TeamWinProbabilities(ctx context.Context, obj *models.Match) ([]*models.TeamWinProbability, error) {
	probabilities := []*models.TeamWinProbability{}
	for k, v := range obj.TeamWinProbabilities {
		prob := &models.TeamWinProbability{
			TeamID:      k,
			Probability: v.String(),
		}
		probabilities = append(probabilities, prob)
	}

	sort.Slice(probabilities, func(i, j int) bool { return strings.Compare(probabilities[i].TeamID, probabilities[j].TeamID) < 0 })

	return probabilities, nil
}

func (r *matchResolver) EventID(ctx context.Context, obj *models.Match) (string, error) {
	return obj.GetEventID(), nil
}

func (r *matchResolver) History(ctx context.Context, obj *models.Match) ([]*models.Audit, error) {
	_, err := auth.Authorize(ctx, []models.AccessRole{
		models.AccessRoleSuperAdmin,
		models.AccessRoleAdmin,
		models.AccessRoleUser,
		models.AccessRoleGuestAPIOnly,
	})
	if err != nil {
		return []*models.Audit{}, err
	}
	audits := []*models.Audit{}
	sqlmatches := sq.Select("audits.*").From("audits").Where(sq.Eq{fmt.Sprintf("%s.target_id", "audits"): obj.ID})

	sql, args, _ := sqlmatches.ToSql()
	_, err = r.DB.Query(&audits, sql, args...)

	return audits, err
}

func (r *queryResolver) Match(ctx context.Context, id string) (*models.Match, error) {
	_, err := auth.Authorize(ctx, []models.AccessRole{
		models.AccessRoleSuperAdmin,
		models.AccessRoleAdmin,
		models.AccessRoleUser,
		models.AccessRoleGuestAPIOnly,
	})
	if err != nil {
		return &models.Match{}, err
	}

	match := models.Match{}
	sqlmatches := sq.Select("matches.*").From("matches").Where(sq.Eq{fmt.Sprintf("%s.id", "matches"): id})

	sql, args, _ := sqlmatches.ToSql()
	_, err = r.DB.QueryOne(&match, sql, args...)

	return &match, err
}

func (r *queryResolver) AllMatches(ctx context.Context, filter *models.MatchFilter, page *int, perPage *int, sortField *string, sortOrder *string) ([]*models.Match, error) {
	_, err := auth.Authorize(ctx, []models.AccessRole{
		models.AccessRoleSuperAdmin,
		models.AccessRoleAdmin,
		models.AccessRoleUser,
	})
	if err != nil {
		return []*models.Match{}, err
	}
	var matches []*models.Match

	sqlbuilder := sq.Select("matches.*").From("matches")
	sql, args := createAllMatchesSQL(sqlbuilder, filter, page, perPage, sortField, sortOrder)
	_, err = r.DB.Query(&matches, sql, args...)

	return matches, err
}

func (r *queryResolver) _allMatchesMeta(ctx context.Context, filter *models.MatchFilter, page *int, perPage *int) (*models.ListMetadata, error) {
	_, err := auth.Authorize(ctx, []models.AccessRole{
		models.AccessRoleSuperAdmin,
		models.AccessRoleAdmin,
		models.AccessRoleUser,
	})
	if err != nil {
		return &models.ListMetadata{}, err
	}

	var count int
	sqlbuilder := sq.Select("COUNT(id)").From("matches")
	sql, args := createAllMatchesSQL(sqlbuilder, filter, nil, nil, nil, nil)
	_, err = r.DB.Query(&count, sql, args...)
	return &models.ListMetadata{Count: count}, err
}

func createAllMatchesSQL(builder sq.SelectBuilder, filter *models.MatchFilter, page *int, perPage *int, sortField *string, sortOrder *string) (sql string, args []interface{}) {
	if filter.IsActive != nil {
		val := false
		if *filter.IsActive {
			val = true
		}
		builder = builder.Where("matches.is_active = ?", val)
	}
	if filter.IsAutogenerated != nil {
		val := false
		if *filter.IsAutogenerated {
			val = true
		}
		builder = builder.Where("matches.is_autogenerated = ?", val)
	}

	if filter.InternalStatus != nil {
		builder = builder.Where("matches.internal_status = ?", *filter.InternalStatus)
	}

	if filter.EventStage != nil {
		builder = builder.Where("matches.event_stage ILIKE ?", fmt.Sprint("%", *filter.EventStage, "%"))
	}

	if filter.ExternalID != nil {
		builder = builder.Where("matches.external_id ILIKE ?", fmt.Sprint("%", *filter.ExternalID, "%"))
	}

	if filter.EventID != nil {
		builder = builder.Where("matches.event_id = ?", *filter.EventID)
	}

	if filter.Format != nil {
		builder = builder.Where("matches.format = ?", filter.Format.String())
	}

	if filter.ID != nil {
		filter.Ids = append(filter.Ids, *filter.ID)
	}

	builder = filterByIDs(builder, filter.Ids, "matches")
	builder = addDefaultSort(builder, sortField, sortOrder)
	builder = addStandardPagination(builder, page, perPage)

	sql, args, _ = builder.ToSql()
	return sql, args
}

func (r *mutationResolver) CreateMatch(ctx context.Context, input models.CreateMatchInput) (*models.Match, error) {
	userID, err := auth.Authorize(ctx, []models.AccessRole{
		models.AccessRoleSuperAdmin,
		models.AccessRoleAdmin,
	})
	if err != nil {
		return &models.Match{}, err
	}

	match := models.Match{
		Name:           input.Name,
		EventID:        repository.NewSQLCompatUUIDFromStr(input.EventID),
		StartTime:      input.StartTime,
		InternalStatus: input.InternalStatus,
		EventStage:     input.EventStage,
		Format:         input.Format,
	}

	if input.IsActive != nil {
		match.IsActive = *input.IsActive
	}

	if input.Description != nil {
		match.Description = *input.Description
	}

	err = r.DB.Insert(&match)

	if err != nil {
		return &models.Match{}, err
	}

	match.ExternalID = models.GenerateInternalXID(&models.Match{}, match.GetID())
	_, err = r.DB.Model(&match).WherePK().Update()

	if err == nil {
		audit.CreateAudit(r.DB, match.ID, repository.NewSQLCompatUUIDFromStr(userID), models.EditActionCreate, match)
	}

	return &match, err
}

func (r *mutationResolver) UpdateMatch(ctx context.Context, input models.UpdateMatchInput) (*models.Match, error) {
	userID, err := auth.Authorize(ctx, []models.AccessRole{
		models.AccessRoleSuperAdmin,
		models.AccessRoleAdmin,
	})
	if err != nil {
		return &models.Match{}, err
	}

	var event models.Match

	sqlbuilder := sq.Update("matches")
	field := fmt.Sprintf("%s.id", "matches")
	sqlbuilder = sqlbuilder.Where(sq.Eq{field: input.ID})

	if input.EventID != nil {
		sqlbuilder = sqlbuilder.Set("event_id", input.EventID)
	}

	if input.Name != nil {
		sqlbuilder = sqlbuilder.Set("name", input.Name)
	}

	if input.Description != nil {
		sqlbuilder = sqlbuilder.Set("description", input.Description)
	}

	if input.IsActive != nil {
		sqlbuilder = sqlbuilder.Set("is_active", *input.IsActive)
	}

	if input.EventStage != nil {
		sqlbuilder = sqlbuilder.Set("event_stage", *input.EventStage)
	}

	if input.InternalStatus != nil {
		sqlbuilder = sqlbuilder.Set("internal_status", *input.InternalStatus)
	}

	if input.StartTime != nil {
		sqlbuilder = sqlbuilder.Set("start_time", *input.StartTime)
	}

	if input.TeamScores != nil {
		teamscores := make(map[string]int)
		for i := 0; i < len(input.TeamScores); i++ {
			teamscores[input.TeamScores[i].TeamID] = input.TeamScores[i].Score
		}
		sqlbuilder = sqlbuilder.Set("team_scores", teamscores)
	}

	if input.TeamOuScores != nil {
		teamscores := make(map[string]int)
		for i := 0; i < len(input.TeamOuScores); i++ {
			teamscores[input.TeamOuScores[i].TeamID] = input.TeamOuScores[i].Score
		}
		sqlbuilder = sqlbuilder.Set("team_ou_scores", teamscores)
	}

	if input.TeamWinProbabilities != nil {
		teamprobabilities := make(map[string]decimal.Decimal)
		for i := 0; i < len(input.TeamWinProbabilities); i++ {
			teamprobabilities[input.TeamWinProbabilities[i].TeamID] = decimal.NewFromFloat(input.TeamWinProbabilities[i].Probability)
		}
		sqlbuilder = sqlbuilder.Set("team_win_probabilities", teamprobabilities)
	}

	if input.Format != nil {
		sqlbuilder = sqlbuilder.Set("format", input.Format.String())
	}

	sqlbuilder = sqlbuilder.Suffix("RETURNING *")
	sql, args, _ := sqlbuilder.ToSql()
	_, err = r.DB.Query(&event, sql, args...)

	if err == nil {
		audit.CreateAudit(r.DB, event.ID, repository.NewSQLCompatUUIDFromStr(userID), models.EditActionUpdate, event)
	}

	return &event, err
}

func (r *mutationResolver) DeleteMatch(ctx context.Context, id string) (*models.Match, error) {
	_, err := auth.Authorize(ctx, []models.AccessRole{
		models.AccessRoleSuperAdmin,
		models.AccessRoleAdmin,
	})
	if err != nil {
		return &models.Match{}, err
	}
	panic("not implemented")
}

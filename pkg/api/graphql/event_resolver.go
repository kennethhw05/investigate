package graphql

import (
	context "context"
	"fmt"
	"strings"

	sq "github.com/Masterminds/squirrel"
	"gitlab.com/siimpl/esp-betting/betting-feed/pkg/audit"
	"gitlab.com/siimpl/esp-betting/betting-feed/pkg/auth"
	"gitlab.com/siimpl/esp-betting/betting-feed/pkg/models"
	"gitlab.com/siimpl/esp-betting/betting-feed/pkg/repository"
)

type eventResolver struct{ *Resolver }

func (r *eventResolver) ID(ctx context.Context, obj *models.Event) (string, error) {
	return obj.GetID(), nil
}

func (r *queryResolver) Event(ctx context.Context, id string) (*models.Event, error) {
	_, err := auth.Authorize(ctx, []models.AccessRole{
		models.AccessRoleSuperAdmin,
		models.AccessRoleAdmin,
		models.AccessRoleUser,
		models.AccessRoleGuestAPIOnly,
	})
	if err != nil {
		return &models.Event{}, err
	}
	event := models.Event{}
	sqlmatches := sq.Select("events.*").From("events").Where(sq.Eq{"events.id": id})

	sql, args, _ := sqlmatches.ToSql()
	_, err = r.DB.QueryOne(&event, sql, args...)

	return &event, err
}

func (r *queryResolver) AllEvents(ctx context.Context, filter *models.EventFilter, page *int, perPage *int, sortField *string, sortOrder *string) ([]*models.Event, error) {
	_, err := auth.Authorize(ctx, []models.AccessRole{
		models.AccessRoleSuperAdmin,
		models.AccessRoleAdmin,
		models.AccessRoleUser,
	})
	if err != nil {
		return []*models.Event{}, err
	}

	var events []*models.Event

	sqlbuilder := sq.Select("events.*").From("events")
	sql, args := createAllEventsSQL(sqlbuilder, filter, page, perPage, sortField, sortOrder)
	_, err = r.DB.Query(&events, sql, args...)

	return events, err
}

func (r *queryResolver) _allEventsMeta(ctx context.Context, filter *models.EventFilter, page *int, perPage *int) (*models.ListMetadata, error) {
	_, err := auth.Authorize(ctx, []models.AccessRole{
		models.AccessRoleSuperAdmin,
		models.AccessRoleAdmin,
		models.AccessRoleUser,
	})
	if err != nil {
		return &models.ListMetadata{}, err
	}

	var count int
	sqlbuilder := sq.Select("COUNT(id)").From("events")
	sql, args := createAllEventsSQL(sqlbuilder, filter, nil, nil, nil, nil)
	_, err = r.DB.Query(&count, sql, args...)
	return &models.ListMetadata{Count: count}, err
}

func createAllEventsSQL(builder sq.SelectBuilder, filter *models.EventFilter, page *int, perPage *int, sortField *string, sortOrder *string) (sql string, args []interface{}) {
	if filter != nil {
		if filter.Name != nil {
			builder = builder.Where("events.name ILIKE ?", fmt.Sprint("%", strings.Trim(*filter.Name, " "), "%"))
		}

		if filter.IsActive != nil {
			val := false
			if *filter.IsActive {
				val = true
			}
			builder = builder.Where("events.is_active = ?", val)
		}

		if filter.ExternalID != nil {
			builder = builder.Where("events.external_id ILIKE ?", fmt.Sprint("%", *filter.ExternalID, "%"))
		}

		if filter.Game != nil {
			builder = builder.Where("events.game = ?", *filter.Game)
		}

		if filter.ID != nil {
			filter.Ids = append(filter.Ids, *filter.ID)
		}

		builder = filterByIDs(builder, filter.Ids, "events")
		builder = addDefaultSort(builder, sortField, sortOrder)
		builder = addStandardPagination(builder, page, perPage)
	}
	sql, args, _ = builder.ToSql()
	return sql, args
}

func (r *mutationResolver) CreateEvent(ctx context.Context, input models.CreateEventInput) (*models.Event, error) {
	userID, err := auth.Authorize(ctx, []models.AccessRole{
		models.AccessRoleSuperAdmin,
		models.AccessRoleAdmin,
	})
	if err != nil {
		return &models.Event{}, err
	}

	event := models.Event{
		StartDate:       input.StartDate,
		EndDate:         input.EndDate,
		Name:            input.Name,
		Type:            input.Type,
		Game:            input.Game,
		IsAutogenerated: false,
	}

	if input.IsActive != nil {
		event.IsActive = *input.IsActive
	}

	if input.Logo != nil {
		event.Logo = *input.Logo
	}

	_, err = r.DB.
		Model(&event).
		Insert()

	if err != nil {
		return &models.Event{}, err
	}

	event.ExternalID = models.GenerateInternalXID(&models.Event{}, event.GetID())
	_, err = r.DB.Model(&event).WherePK().Update()

	if err == nil {
		audit.CreateAudit(r.DB, event.ID, repository.NewSQLCompatUUIDFromStr(userID), models.EditActionCreate, event)
	}
	return &event, err
}

func (r *mutationResolver) UpdateEvent(ctx context.Context, input models.UpdateEventInput) (*models.Event, error) {
	userID, err := auth.Authorize(ctx, []models.AccessRole{
		models.AccessRoleSuperAdmin,
		models.AccessRoleAdmin,
	})
	if err != nil {
		return &models.Event{}, err
	}

	var event models.Event

	sqlbuilder := sq.Update("events")
	field := fmt.Sprintf("%s.id", "events")
	sqlbuilder = sqlbuilder.Where(sq.Eq{field: input.ID})

	if input.Name != nil {
		sqlbuilder = sqlbuilder.Set("name", input.Name)
	}

	if input.Logo != nil {
		sqlbuilder = sqlbuilder.Set("logo", input.Logo)
	}

	if input.IsActive != nil {
		sqlbuilder = sqlbuilder.Set("is_active", *input.IsActive)
	}

	if input.StartDate != nil {
		sqlbuilder = sqlbuilder.Set("start_date", *input.StartDate)
	}
	if input.EndDate != nil {
		sqlbuilder = sqlbuilder.Set("end_date", *input.EndDate)
	}

	sqlbuilder = sqlbuilder.Suffix("RETURNING *")
	sql, args, _ := sqlbuilder.ToSql()
	_, err = r.DB.Query(&event, sql, args...)

	if err == nil {
		audit.CreateAudit(r.DB, event.ID, repository.NewSQLCompatUUIDFromStr(userID), models.EditActionUpdate, event)
	}

	return &event, err
}

func (r *mutationResolver) DeleteEvent(ctx context.Context, id string) (*models.Event, error) {
	_, err := auth.Authorize(ctx, []models.AccessRole{
		models.AccessRoleSuperAdmin,
		models.AccessRoleAdmin,
	})
	if err != nil {
		return &models.Event{}, err
	}
	panic("not implemented")
}

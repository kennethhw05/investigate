package datafeeder

import (
	"fmt"
	"time"

	"gitlab.com/siimpl/esp-betting/betting-feed/pkg/external/oddsgg"

	"github.com/pkg/errors"
	"github.com/shopspring/decimal"
	"github.com/sirupsen/logrus"
	"gitlab.com/siimpl/esp-betting/betting-feed/pkg/config"
	"gitlab.com/siimpl/esp-betting/betting-feed/pkg/dataconverter"
	"gitlab.com/siimpl/esp-betting/betting-feed/pkg/models"
	"gitlab.com/siimpl/esp-betting/betting-feed/pkg/repository"
)

type oddsggInternalEsportsFeeder struct {
	apiClient         *oddsgg.Client
	db                repository.DataSource
	converter         *dataconverter.OddsggConverter
	logger            *logrus.Logger
	sleepTime         time.Duration
	cachedLeagues     map[int]oddsgg.League
	partialLeaguePull bool
}

func (feeder *oddsggInternalEsportsFeeder) FeedJob() {
	for {
		resultChan := make(chan Result)

		go feeder.feed(resultChan)
		for result := range resultChan {
			if result.Error != nil {
				feeder.logger.Errorf("Error while processing oddsgg feed job: %+v", result.Error)
			} else {
				feeder.logger.Info(result.Message)
			}
		}

		feeder.logger.Infof("Completed oddsgg to internal job")
		time.Sleep(feeder.sleepTime)
	}
}

func (feeder *oddsggInternalEsportsFeeder) feed(resultChan chan Result) {
	defer close(resultChan)

	leagues, err := feeder.apiClient.GetSportLeagues(oddsgg.ESportsID, feeder.partialLeaguePull)
	if err != nil {
		feeder.partialLeaguePull = false
		resultChan <- Result{Error: errors.Wrap(err, "error pulling sport leagues")}
		return
	}
	feeder.partialLeaguePull = true

	for _, league := range leagues {
		feeder.cachedLeagues[league.ID] = league
	}

	extToIntTournIDMap := feeder.iterateLeagues(resultChan)
	feeder.iterateTournaments(extToIntTournIDMap, resultChan)
}

func (feeder *oddsggInternalEsportsFeeder) iterateLeagues(resultChan chan Result) map[int]string {
	extToIntTournIDMap := make(map[int]string)
	for _, v := range feeder.cachedLeagues {
		game := feeder.converter.ToEsportsGame(v.CategoryName)
		//fmt.Printf("iterateLeagues %v \n", v.Tournaments)
		for _, tournament := range v.Tournaments {
			internalEventID, err := feeder.feedTournamentToDatastore(tournament, game)
			if err != nil {
				resultChan <- Result{
					Error: errors.Wrapf(err, "event internal id %s external id %d", internalEventID, tournament.ID),
				}
				continue
			}
			extToIntTournIDMap[tournament.ID] = internalEventID
			resultChan <- Result{
				Message: fmt.Sprintf("Finished processing [game %s - event %s] for internal system", game, internalEventID),
			}
		}
	}
	return extToIntTournIDMap
}

func (feeder *oddsggInternalEsportsFeeder) iterateTournaments(extToIntTournIDMap map[int]string, resultChan chan Result) {
	extTournIds := make([]int, 0, len(extToIntTournIDMap))
	for k := range extToIntTournIDMap {
		extTournIds = append(extTournIds, k)
	}

	//fmt.Printf("iterateTournaments %v \n", extTournIds)
	matches, err := feeder.apiClient.GetLiveTournamentMatches(
		oddsgg.TournamentLiveMatchesPayload{
			TournamentIDs: extTournIds,
			IsLive:        true,
		},
		false,
	)
	if err != nil {
		resultChan <- Result{
			Error: errors.Wrapf(err, "error pulling live tournament matches from oddsgg api"),
		}
		return
	}

	for _, match := range matches {
		val, ok := extToIntTournIDMap[match.TournamentID]
		if !ok {
			continue
		}

		err = feeder.feedMatchToDatastore(match, val)
		if err != nil {
			resultChan <- Result{
				Error: errors.Wrapf(
					err, "error pulling tournament %d live match %d from oddsgg api",
					match.TournamentID, match.ID,
				),
			}
		}
	}
}

func (feeder *oddsggInternalEsportsFeeder) feedTournamentToDatastore(tournament oddsgg.Tournament, game models.Game) (string, error) {
	updatedInternalEvent := feeder.converter.ToEsportsEvent(tournament, game)
	eventSelect := models.Event{}
	err := feeder.db.Model(&eventSelect).Where("game = ? and external_id = ?", updatedInternalEvent.Game, updatedInternalEvent.ExternalID).Select()
	if !(err == nil && updatedInternalEvent.EqualsShallow(&eventSelect)) {

		query := feeder.db.
			Model(updatedInternalEvent).
			Set("start_date = ?start_date, end_date = ?end_date, name = ?name, is_active = ?is_active, is_autogenerated = ?is_autogenerated, type = ?type")

		if err == nil && updatedInternalEvent.Game == eventSelect.Game && updatedInternalEvent.ExternalID == eventSelect.ExternalID {
			//Entity already exists in db then Update
			_, err = query.Where("game = ? and external_id = ?", updatedInternalEvent.Game, updatedInternalEvent.ExternalID).Returning("*").Update()
		} else {
			_, err = query.Insert()
		}

		if err != nil {
			return "", errors.Wrap(err, "error inserting or updating event in database")
		}
	} else {
		updatedInternalEvent = &eventSelect
	}

	return updatedInternalEvent.GetID(), nil
}

func (feeder *oddsggInternalEsportsFeeder) feedMatchToDatastore(match oddsgg.Match, eventID string) (err error) {
	updatedInternalMatch := feeder.converter.ToEsportsMatch(match, eventID)
	updatedInternalMatch.TeamScores = feeder.converter.ToEsportsCompetitorScores(match)
	probabilities, err := feeder.getProbabilitiesForMatch(match, updatedInternalMatch.TeamWinProbabilities)
	if err != nil {
		return errors.Wrap(err, fmt.Sprintf("issue getting probabilities for oddsgg match %d", match.ID))
	}

	updatedInternalMatch.TeamWinProbabilities = probabilities

	matchSelect := models.Match{}
	err = feeder.db.Model(&matchSelect).Where("event_id = ? and external_id = ?", updatedInternalMatch.EventID, updatedInternalMatch.ExternalID).Select()

	//fmt.Printf("feedmatchtodatastore %v %v \n", updatedInternalMatch.EventID, updatedInternalMatch.ExternalID)
	if !(err == nil && updatedInternalMatch.EqualsShallow(&matchSelect)) {
		query := feeder.db.
			Model(updatedInternalMatch).
			Set("name = ?name, start_time = ?start_time, internal_status = ?internal_status, team_scores = ?team_scores, team_ou_scores = ?team_ou_scores, statistics = ?statistics, is_active = ?is_active, is_autogenerated = ?is_autogenerated")

		if err == nil && updatedInternalMatch.EventID == matchSelect.EventID && updatedInternalMatch.ExternalID == matchSelect.ExternalID {
			//Entity already exists in db then Update
			_, err = query.Where("event_id = ? and external_id = ?", updatedInternalMatch.EventID, updatedInternalMatch.ExternalID).Returning("*").Update()
		} else {
			_, err = query.Insert()
		}
	} else {
		updatedInternalMatch = &matchSelect
	}

	if err != nil {
		return errors.Wrap(err, "error inserting or updating match in database")
	}

	err = feeder.feedCompetitorToDatastore(match.HomeTeamID, match.HomeTeamName, updatedInternalMatch.GetID())
	if err != nil {
		return errors.Wrap(err, "error inserting or updating home team in database")
	}
	err = feeder.feedCompetitorToDatastore(match.AwayTeamID, match.AwayTeamName, updatedInternalMatch.GetID())
	if err != nil {
		return errors.Wrap(err, "error inserting or updating away team in database")
	}

	return nil
}

func (feeder *oddsggInternalEsportsFeeder) getProbabilitiesForMatch(match oddsgg.Match, oldProbabilities map[string]decimal.Decimal) (map[string]decimal.Decimal, error) {
	//fmt.Printf("getmatchmarkets %v \n", match.ID)
	markets, err := feeder.apiClient.GetMatchMarkets(
		oddsgg.MatchMarketsPayload{
			MatchIDs: []int{match.ID},
		},
		true,
	)
	if err != nil {
		return nil, err
	}

	// Use best odds because sometimes update calls drop a better probability.
	newProbabilities := feeder.converter.ToEsportsTeamWinProbabilities(markets, match)
	defaultProb := decimal.NewFromFloat(50.0)
	if oldProbabilities != nil {
		for k, v := range newProbabilities {
			val, ok := oldProbabilities[k]
			if ok && !val.Equal(defaultProb) && v.Equal(defaultProb) {
				newProbabilities[k] = val
			}
		}
	}

	return newProbabilities, nil
}

func (feeder *oddsggInternalEsportsFeeder) feedCompetitorToDatastore(competitorID int, competitorName string, matchID string) (err error) {
	updatedInternalCompetitor := feeder.converter.ToEsportsCompetitor(competitorID, competitorName)
	competitorSelect := models.Competitor{}

	err = feeder.db.Model(&competitorSelect).Where("name = ? and external_id = ?", competitorName, updatedInternalCompetitor.ExternalID).Select()
	if !(err == nil && updatedInternalCompetitor.EqualsShallow(&competitorSelect)) {
		query := feeder.db.
			Model(updatedInternalCompetitor).
			Set("name = ?name")

		if err == nil && updatedInternalCompetitor.Name == competitorSelect.Name && updatedInternalCompetitor.ExternalID == competitorSelect.ExternalID {
			//Entity already exists in db then Update
			_, err = query.Where("name = ? and external_id = ?", updatedInternalCompetitor.Name, updatedInternalCompetitor.ExternalID).Returning("*").Update()
		} else {
			_, err = query.Insert()
		}

		if err != nil {
			return err
		}

	} else {
		updatedInternalCompetitor = &competitorSelect
	}

	//TODO What about removing previous relationships if they changed?

	//Setup match relationship to competitor
	competitorMatch := models.CompetitorMatch{}
	match := &models.Match{ID: repository.NewSQLCompatUUIDFromStr(matchID)}
	err = competitorMatch.AddRelationship(updatedInternalCompetitor, match, feeder.db)
	if err != nil {
		return err
	}

	return nil
}

func newOddsggToInternalEsportsFeeder(config *config.Config, db repository.DataSource, logger *logrus.Logger) (dataFeeder, error) {
	if config == nil {
		return nil, errors.New("config cannot be nil")
	}
	apiKey := config.OddsggAPIKey
	if apiKey == "" {
		return nil, errors.New("api key for oddsgg not present in config")
	}

	return &oddsggInternalEsportsFeeder{
		apiClient: oddsgg.New(apiKey),
		converter: &dataconverter.OddsggConverter{
			Logger: logger,
		},
		db:                db,
		logger:            logger,
		sleepTime:         time.Duration(config.InFeedTimeGap) * time.Minute,
		cachedLeagues:     make(map[int]oddsgg.League),
		partialLeaguePull: false,
	}, nil
}
